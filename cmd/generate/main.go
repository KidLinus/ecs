package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"os"
	"strings"
)

func main() {
	depth := flag.Int("depth", 5, "How many layers of generics. Eg 4 means up to Query5 and Set5 will be generated")
	file := flag.String("file", "methods_generated.go", "File name to create")
	flag.Parse()
	f, err := os.Create(*file)
	if err != nil {
		panic(err)
	}
	defer f.Close()
	pkg := os.Getenv("GOPACKAGE")
	if pkg == "" {
		pkg = "ecs"
	}
	buffer := &bytes.Buffer{}
	buffer.WriteString("// Code generated by generate command. DO NOT EDIT.\n")
	buffer.WriteString(fmt.Sprintf("package %s\n\nimport (\n\"fmt\"\n)\n", pkg))

	for i := 0; i < *depth; i++ {
		buildSetFunc(buffer, i+1)
	}

	for i := 0; i < *depth; i++ {
		buildQueryType(buffer, i+1)
	}

	for i := 0; i < *depth; i++ {
		buildQueryFunc(buffer, i+1)
	}

	for i := 0; i < *depth; i++ {
		buildQueryEachFunc(buffer, i+1)
	}

	fmt, err := format.Source(buffer.Bytes())
	if err != nil {
		panic(err)
	}
	// fmt := buffer.Bytes()
	if _, err := f.Write(fmt); err != nil {
		panic(err)
	}
}

// func Set1[ID Int, T1 any](storage *Storage[ID], id ID, v1 T1) {
//  storage.lock.Lock()
//  defer storage.lock.Unlock()
// 	components := []int{storage.componentEnsure(v1)}
// 	hashes := []int{componentHash(v1)}
// 	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
// 	storage.Entitys[id] = entity
// 	compound := storage.Compounds[entity.Compound]
// 	compound.Entitys = append(compound.Entitys, id)
// if compound.Components[0].Data == nil {
// 	compound.Components[0].Data = slice[T1]{data: []T1{v1}}
// 	return
// }
// compound.Components[0].Data.(slice[T1]).append(v1)
// }

func buildSetFunc(buffer *bytes.Buffer, depth int) {
	var genericParams string
	var genericReturns string
	var ensures []string
	var hashes []string
	var valueSetNil string
	var valueSet string
	for i := 1; i <= depth; i++ {
		genericParams += fmt.Sprintf(",T%d", i)
		genericReturns += fmt.Sprintf(",v%d T%d", i, i)
		ensures = append(ensures, fmt.Sprintf("storage.componentEnsure(v%d)", i))
		hashes = append(hashes, fmt.Sprintf("componentHash(v%d)", i))
		valueSetNil += fmt.Sprintf("compound.Components[%d].Data = &slice[T%d]{Data: []T%d{v%d}}\n", i-1, i, i, i)
		valueSet += fmt.Sprintf("compound.Components[%d].Data.(*slice[T%d]).append(v%d)\n", i-1, i, i)
	}
	buffer.WriteString(fmt.Sprintf(`
func Set%d[ID Int%s any](storage *Storage[ID], id ID%s) {
	storage.lock.Lock()
	defer storage.lock.Unlock()
	components := []int{%s}
	hashes := []int{%s}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.Entitys = append(compound.Entitys, id)
	if compound.Components[0].Data == nil {
		%s
		return
	}
	%s
}
`, depth, genericParams, genericReturns, strings.Join(ensures, ","), strings.Join(hashes, ","), valueSetNil, valueSet))
}

func buildQueryType(buffer *bytes.Buffer, depth int) {
	var genericParams string
	var genericReturn string
	for i := 1; i <= depth; i++ {
		genericParams += fmt.Sprintf(",T%d any", i)
		genericReturn += fmt.Sprintf(",T%d", i)
	}
	buffer.WriteString(fmt.Sprintf("type Q%d[ID Int%s]struct{\nstorage *Storage[ID]\nComponents [%d]int\nErrors []error\n}\n", depth, genericParams, depth))
	buffer.WriteString(fmt.Sprintf("type Q%dOption struct{\nOptional [%d]bool\nStop *bool\nHash *ComponentHash\n}\n", depth, depth))
}

func buildQueryFunc(buffer *bytes.Buffer, depth int) {
	var genericParams string
	var genericReturn string
	for i := 1; i <= depth; i++ {
		genericParams += fmt.Sprintf("T%d any,", i)
		genericReturn += fmt.Sprintf(",T%d", i)
	}
	buffer.WriteString(fmt.Sprintf("func Query%d[%s ID Int](storage *Storage[ID]) *Q%d[ID%s]{\n", depth, genericParams, depth, genericReturn))
	buffer.WriteString("storage.lock.RLock()\ndefer storage.lock.RUnlock()\n")
	buffer.WriteString(fmt.Sprintf("q := &Q%d[ID%s]{storage: storage}\n", depth, genericReturn))
	for i := 1; i <= depth; i++ {
		buffer.WriteString(fmt.Sprintf(`{
	name := typeName[T%d]()
	id, ok := storage.getComponent(name)
	q.Components[%d] = id
	if !ok {
		q.Errors = append(q.Errors, fmt.Errorf("component %d \"%%s\" does not exist", name))
	}
}
`, i, i-1, i))
	}
	buffer.WriteString("return q\n}\n\n")
}

// func (q *Q1[ID, T1]) Each(fn func(ID, *T1), queryOptions ...Q1Option) {
// 	// Skip if there is an error
// 	if q.Errors != nil {
// 		return
// 	}
// 	var options Q1Option
// 	if len(queryOptions) == 1 {
// 		options = queryOptions[0]
// 	}
// 	if options.Stop == nil {
// 		options.Stop = new(bool)
// 	}
// 	// Filter and run compounds
// 	var compoundCleanup []int
// 	q.storage.lock.RLock()
// LOOP:
// 	for id, compound := range q.storage.Compounds {
// 		var v1s []T1

// 		for _, component := range compound.Components {
// 			if options.Hash != nil && component.ID == options.Hash.ID && component.Hash != options.Hash.Hash {
// 				continue LOOP
// 			}
// 			if component.ID == q.Components[0] {
// 				v1s = component.Data.(*slice[T1]).Data
// 				continue
// 			}

// 		}
// 		if v1s == nil && !options.Optional[0] {
// 			continue
// 		}

// 		if compound.EntitysRemoved != nil {
// 			if !compound.cleanupTime.Swap(true) {
// 				compoundCleanup = append(compoundCleanup, id)
// 				continue LOOP
// 			}
// 			loopEach:
// 			for idx, id := range compound.Entitys {
// 				for _, r := range compound.EntitysRemoved {
// 					if r == id {
// 						continue loopEach
// 					}
// 				}
// 				fn(id, getOptional(v1s, idx))
// 				if *options.Stop {
// 					break LOOP
// 				}
// 			}
// 			continue
// 		}
// 		// Loop
// 		for idx, id := range compound.Entitys {
// 			fn(id, getOptional(v1s, idx))
// 			if *options.Stop {
// 				// q.storage.lock.RUnlock()
// 				break LOOP
// 			}
// 		}
// 	}
// 	q.storage.lock.RUnlock()
// 	if compoundCleanup == nil {
// 		return
// 	}
// 	// Run cleanups
// 	q.storage.lock.Lock()
// 	for _, id := range compoundCleanup {
// 		compound := q.storage.Compounds[id]
// 		// Abort if we're not going to run the data
// 		if *options.Stop {
// 			continue
// 		}
// 		// Select components
// 		var v1s []T1

// 		for _, component := range compound.Components {
// 			if component.ID == q.Components[0] {
// 				v1s = component.Data.(*slice[T1]).Data
// 				continue
// 			}

// 		}
// 		// Run data
// 		idxRemove := make([]int,0, len(compound.EntitysRemoved))
// 		loopRemove:
// 		for idx, id := range compound.Entitys {
// 			for rIdx, r := range compound.EntitysRemoved {
// 				if r == id {
// 					idxRemove = append(idxRemove, idx)
// 					compound.EntitysRemoved = sliceRemove(compound.EntitysRemoved, rIdx)
// 					continue loopRemove
// 				}
// 			}
// 			fn(id, getOptional(v1s, idx))
// 			if *options.Stop {
// 				continue
// 			}
// 		}
// 		// Cleanup
// 		for i := len(idxRemove) - 1; i >= 0; i-- {
// 			idx := idxRemove[i]
// 			compound.Entitys = sliceRemove(compound.Entitys, idx)
// 			for _, component := range compound.Components {
// 				component.Data.remove(idx)
// 			}
// 		}
// 		compound.EntitysRemoved = nil
// 	}
// 	for _, id := range compoundCleanup {
// 		compound := q.storage.Compounds[id]
// 		compound.cleanupTime.Store(false)
// 	}
// 	q.storage.lock.Unlock()
// }

func buildQueryEachFunc(buffer *bytes.Buffer, depth int) {
	var genericParams string
	var genericReturn string
	var sliceConstructors string
	var sliceSelectors string
	var sliceOptionalChecks string
	var optionals string
	for i := 1; i <= depth; i++ {
		genericParams += fmt.Sprintf(",*T%d", i)
		genericReturn += fmt.Sprintf(",T%d", i)
		sliceConstructors += fmt.Sprintf("var v%ds []T%d\n", i, i)
		sliceSelectors += fmt.Sprintf("if component.ID == q.Components[%d] {\nv%ds = component.Data.(*slice[T%d]).Data\ncontinue\n}\n", i-1, i, i)
		sliceOptionalChecks += fmt.Sprintf("if v%ds == nil && !options.Optional[%d] {\ncontinue\n}\n", i, i-1)
		optionals += fmt.Sprintf(", getOptional(v%ds, idx)", i)
	}
	// optionals
	buffer.WriteString(fmt.Sprintf(`func (q *Q%d[ID%s]) Each(fn func(ID%s), queryOptions ...Q%dOption) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q%dOption
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
	var compoundCleanup []int
	q.storage.lock.RLock()
LOOP:
	for id, compound := range q.storage.Compounds {
		%s
		for _, component := range compound.Components {
			if options.Hash != nil && component.ID == options.Hash.ID && component.Hash != options.Hash.Hash {
				continue LOOP
			}
			%s
		}
		%s
		if compound.EntitysRemoved != nil {
			if !compound.cleanupTime.Swap(true) {
				compoundCleanup = append(compoundCleanup, id)
				continue LOOP
			}
			loopEach:
			for idx, id := range compound.Entitys {
				for _, r := range compound.EntitysRemoved {
					if r == id {
						continue loopEach
					}
				}
				fn(id%s)
				if *options.Stop {
					break LOOP
				}
			}
			continue
		}
		// Loop
		for idx, id := range compound.Entitys {
			fn(id%s)
			if *options.Stop {
				break LOOP
			}
		}
	}
	q.storage.lock.RUnlock()
	if compoundCleanup == nil {
		return
	}
	// Run cleanups
	q.storage.lock.Lock()
	for _, id := range compoundCleanup {
		compound := q.storage.Compounds[id]
		// Abort if we're not going to run the data
		if *options.Stop {
			continue
		}
		// Select components
		%s
		for _, component := range compound.Components {
			%s
		}
		// Run data
		idxRemove := make([]int,0, len(compound.EntitysRemoved))
		loopRemove:
		for idx, id := range compound.Entitys {
			for rIdx, r := range compound.EntitysRemoved {
				if r == id {
					idxRemove = append(idxRemove, idx)
					compound.EntitysRemoved = sliceRemove(compound.EntitysRemoved, rIdx)
					continue loopRemove
				}
			}
			fn(id%s)
			if *options.Stop {
				continue
			}
		}
		// Cleanup
		for i := len(idxRemove) - 1; i >= 0; i-- {
			idx := idxRemove[i]
			compound.Entitys = sliceRemove(compound.Entitys, idx)
			for _, component := range compound.Components {
				component.Data.remove(idx)
			}
		}
		compound.EntitysRemoved = nil
	}
	for _, id := range compoundCleanup {
		compound := q.storage.Compounds[id]
		compound.cleanupTime.Store(false)
	}
	q.storage.lock.Unlock()
}
`, depth, genericReturn, genericParams, depth, depth, sliceConstructors, sliceSelectors, sliceOptionalChecks, optionals, optionals,
		sliceConstructors, sliceSelectors, optionals))
}
