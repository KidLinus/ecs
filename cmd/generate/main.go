package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"os"
	"strings"
)

func main() {
	depth := flag.Int("depth", 5, "How many layers of generics. Eg 4 means up to Query5 and Set5 will be generated")
	file := flag.String("file", "methods_generated.go", "File name to create")
	flag.Parse()
	f, err := os.Create(*file)
	if err != nil {
		panic(err)
	}
	defer f.Close()
	buffer := &bytes.Buffer{}
	buffer.WriteString("// Code generated by generate command. DO NOT EDIT.\n")
	buffer.WriteString(fmt.Sprintf("package %s\n\nimport (\n\"fmt\"\n\"slices\"\n)\n", os.Getenv("GOPACKAGE")))

	for i := 0; i < *depth; i++ {
		buildSetFunc(buffer, i+1)
	}

	for i := 0; i < *depth; i++ {
		buildQueryType(buffer, i+1)
	}

	for i := 0; i < *depth; i++ {
		buildQueryFunc(buffer, i+1)
	}

	for i := 0; i < *depth; i++ {
		buildQueryEachFunc(buffer, i+1)
	}

	fmt, err := format.Source(buffer.Bytes())
	if err != nil {
		panic(err)
	}
	// fmt := buffer.Bytes()
	if _, err := f.Write(fmt); err != nil {
		panic(err)
	}
}

func buildSetFunc(buffer *bytes.Buffer, depth int) {
	var genericParams string
	var genericReturns string
	var ensures []string
	var hashes []string
	var valueSetNil string
	var valueSet string
	for i := 1; i <= depth; i++ {
		genericParams += fmt.Sprintf(",T%d", i)
		genericReturns += fmt.Sprintf(",v%d T%d", i, i)
		ensures = append(ensures, fmt.Sprintf("storage.componentEnsure(v%d)", i))
		hashes = append(hashes, fmt.Sprintf("componentHash(v%d)", i))
		valueSetNil += fmt.Sprintf("compound.Values[components[%d]] = []T%d{v%d}\n", i-1, i, i)
		valueSet += fmt.Sprintf("compound.Values[components[%d]] = append(compound.Values[components[%d]].([]T%d), v%d)\n", i-1, i-1, i, i)
	}
	buffer.WriteString(fmt.Sprintf(`
func Set%d[ID Int%s any](storage *Storage[ID], id ID%s) {
	components := []int{%s}
	hashes := []int{%s}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.IDs = append(compound.IDs, id)
	if compound.Values == nil {
		compound.Values = make([]any, slices.Max(components)+1)
		%s
		return
	}
	%s}
`, depth, genericParams, genericReturns, strings.Join(ensures, ","), strings.Join(hashes, ","), valueSetNil, valueSet))
}

func buildQueryType(buffer *bytes.Buffer, depth int) {
	var genericParams string
	var genericReturn string
	for i := 1; i <= depth; i++ {
		genericParams += fmt.Sprintf(",T%d any", i)
		genericReturn += fmt.Sprintf(",T%d", i)
	}
	buffer.WriteString(fmt.Sprintf("type Q%d[ID Int%s]struct{\nstorage *Storage[ID]\nComponents [%d]int\nErrors []error\n}\n", depth, genericParams, depth))
	buffer.WriteString(fmt.Sprintf("type Q%dOption struct{\nOptional [%d]bool\nStop *bool\nHash *ComponentHash\n}\n", depth, depth))
}

func buildQueryFunc(buffer *bytes.Buffer, depth int) {
	var genericParams string
	var genericReturn string
	for i := 1; i <= depth; i++ {
		genericParams += fmt.Sprintf("T%d any,", i)
		genericReturn += fmt.Sprintf(",T%d", i)
	}
	buffer.WriteString(fmt.Sprintf("func Query%d[%s ID Int](storage *Storage[ID]) *Q%d[ID%s]{\n", depth, genericParams, depth, genericReturn))
	buffer.WriteString(fmt.Sprintf("q := &Q%d[ID%s]{storage: storage}\n", depth, genericReturn))
	for i := 1; i <= depth; i++ {
		buffer.WriteString(fmt.Sprintf(`{
	name := typeName[T%d]()
	id, ok := storage.getComponent(name)
	q.Components[%d] = id
	if !ok {
		q.Errors = append(q.Errors, fmt.Errorf("component %d \"%%s\" does not exist", name))
	}
}
`, i, i-1, i))
	}
	buffer.WriteString("return q\n}\n\n")
}

func buildQueryEachFunc(buffer *bytes.Buffer, depth int) {
	var genericParams string
	var genericReturn string
	for i := 1; i <= depth; i++ {
		genericParams += fmt.Sprintf(",*T%d", i)
		genericReturn += fmt.Sprintf(",T%d", i)
	}
	buffer.WriteString(fmt.Sprintf(`
func (q *Q%d[ID%s]) Each(fn func(ID%s), queryOptions ...Q%dOption) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q%dOption
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
	for compoundIdx, compound := range q.storage.Compounds {
		if options.Hash != nil {
			if i, ok := sliceFind(compound.Components, options.Hash.ID); ok {
				if compound.Hashes[i] != options.Hash.Hash {
					continue
				}
			} else {
				continue
			}
		}
		componentMax := len(compound.Values) - 1`, depth, genericReturn, genericParams, depth, depth))
	for i := 1; i <= depth; i++ {
		buffer.WriteString(fmt.Sprintf(`
		var v%ds []T%d
		if q.Components[%d] > componentMax || compound.Values[q.Components[%d]] == nil {
			if !options.Optional[%d] {
				continue
			}
		} else {
			v%ds = compound.Values[q.Components[%d]].([]T%d)
		}`, i, i, i-1, i-1, i-1, i, i-1, i))
	}
	buffer.WriteString(`
		// If it has removed items, also flush them
		if compound.Removed != nil {
			count := len(compound.Removed)
			if len(compound.IDs) == count { // Compound is empty, throw away
				q.storage.Compounds = sliceRemove(q.storage.Compounds, compoundIdx)
				continue
			}
			idxRemove := make([]int, count)
			skip, skipped := compound.Removed[0], 0
			for idx, id := range compound.IDs {
				if id == skip {
					idxRemove[skipped] = idx
					if skipped < count-1 {
						skipped++
						skip = compound.Removed[skipped]
					}
					continue
				}
		`)
	var optionals string
	for i := 1; i <= depth; i++ {
		optionals += fmt.Sprintf(", getOptional(v%ds, idx)", i)
	}
	buffer.WriteString(fmt.Sprintf(`
	fn(id%s)
				if *options.Stop {
					return
				}
			}
			// Remove items and flush
			for i := len(idxRemove) - 1; i >= 0; i-- {
				compound.IDs = sliceRemove(compound.IDs, idxRemove[i])
	`, optionals))
	for i := 1; i <= depth; i++ {
		buffer.WriteString(fmt.Sprintf("v%ds = sliceRemove(v%ds, idxRemove[i])\n", i, i))
	}
	buffer.WriteString("}\n")
	for i := 1; i <= depth; i++ {
		buffer.WriteString(fmt.Sprintf("compound.Values[q.Components[%d]] = v%ds\n", i-1, i))
	}
	buffer.WriteString(fmt.Sprintf(`
			compound.Removed = nil
			continue
		}
		// Normal loop
		for idx, id := range compound.IDs {
			fn(id%s)
			if *options.Stop {
				return
			}
		}
	}
}
`, optionals))
}
