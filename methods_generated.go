// Code generated by generate command. DO NOT EDIT.
package ecs

import (
	"fmt"
	"slices"
)

func Set1[ID Int, T1 any](storage *Storage[ID], id ID, v1 T1) {
	components := []int{storage.componentEnsure(v1)}
	hashes := []int{componentHash(v1)}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.IDs = append(compound.IDs, id)
	if compound.Values == nil {
		compound.Values = make([]any, slices.Max(components)+1)
		compound.Values[components[0]] = []T1{v1}

		return
	}
	compound.Values[components[0]] = append(compound.Values[components[0]].([]T1), v1)
}

func Set2[ID Int, T1, T2 any](storage *Storage[ID], id ID, v1 T1, v2 T2) {
	components := []int{storage.componentEnsure(v1), storage.componentEnsure(v2)}
	hashes := []int{componentHash(v1), componentHash(v2)}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.IDs = append(compound.IDs, id)
	if compound.Values == nil {
		compound.Values = make([]any, slices.Max(components)+1)
		compound.Values[components[0]] = []T1{v1}
		compound.Values[components[1]] = []T2{v2}

		return
	}
	compound.Values[components[0]] = append(compound.Values[components[0]].([]T1), v1)
	compound.Values[components[1]] = append(compound.Values[components[1]].([]T2), v2)
}

func Set3[ID Int, T1, T2, T3 any](storage *Storage[ID], id ID, v1 T1, v2 T2, v3 T3) {
	components := []int{storage.componentEnsure(v1), storage.componentEnsure(v2), storage.componentEnsure(v3)}
	hashes := []int{componentHash(v1), componentHash(v2), componentHash(v3)}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.IDs = append(compound.IDs, id)
	if compound.Values == nil {
		compound.Values = make([]any, slices.Max(components)+1)
		compound.Values[components[0]] = []T1{v1}
		compound.Values[components[1]] = []T2{v2}
		compound.Values[components[2]] = []T3{v3}

		return
	}
	compound.Values[components[0]] = append(compound.Values[components[0]].([]T1), v1)
	compound.Values[components[1]] = append(compound.Values[components[1]].([]T2), v2)
	compound.Values[components[2]] = append(compound.Values[components[2]].([]T3), v3)
}

func Set4[ID Int, T1, T2, T3, T4 any](storage *Storage[ID], id ID, v1 T1, v2 T2, v3 T3, v4 T4) {
	components := []int{storage.componentEnsure(v1), storage.componentEnsure(v2), storage.componentEnsure(v3), storage.componentEnsure(v4)}
	hashes := []int{componentHash(v1), componentHash(v2), componentHash(v3), componentHash(v4)}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.IDs = append(compound.IDs, id)
	if compound.Values == nil {
		compound.Values = make([]any, slices.Max(components)+1)
		compound.Values[components[0]] = []T1{v1}
		compound.Values[components[1]] = []T2{v2}
		compound.Values[components[2]] = []T3{v3}
		compound.Values[components[3]] = []T4{v4}

		return
	}
	compound.Values[components[0]] = append(compound.Values[components[0]].([]T1), v1)
	compound.Values[components[1]] = append(compound.Values[components[1]].([]T2), v2)
	compound.Values[components[2]] = append(compound.Values[components[2]].([]T3), v3)
	compound.Values[components[3]] = append(compound.Values[components[3]].([]T4), v4)
}

func Set5[ID Int, T1, T2, T3, T4, T5 any](storage *Storage[ID], id ID, v1 T1, v2 T2, v3 T3, v4 T4, v5 T5) {
	components := []int{storage.componentEnsure(v1), storage.componentEnsure(v2), storage.componentEnsure(v3), storage.componentEnsure(v4), storage.componentEnsure(v5)}
	hashes := []int{componentHash(v1), componentHash(v2), componentHash(v3), componentHash(v4), componentHash(v5)}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.IDs = append(compound.IDs, id)
	if compound.Values == nil {
		compound.Values = make([]any, slices.Max(components)+1)
		compound.Values[components[0]] = []T1{v1}
		compound.Values[components[1]] = []T2{v2}
		compound.Values[components[2]] = []T3{v3}
		compound.Values[components[3]] = []T4{v4}
		compound.Values[components[4]] = []T5{v5}

		return
	}
	compound.Values[components[0]] = append(compound.Values[components[0]].([]T1), v1)
	compound.Values[components[1]] = append(compound.Values[components[1]].([]T2), v2)
	compound.Values[components[2]] = append(compound.Values[components[2]].([]T3), v3)
	compound.Values[components[3]] = append(compound.Values[components[3]].([]T4), v4)
	compound.Values[components[4]] = append(compound.Values[components[4]].([]T5), v5)
}

func Set6[ID Int, T1, T2, T3, T4, T5, T6 any](storage *Storage[ID], id ID, v1 T1, v2 T2, v3 T3, v4 T4, v5 T5, v6 T6) {
	components := []int{storage.componentEnsure(v1), storage.componentEnsure(v2), storage.componentEnsure(v3), storage.componentEnsure(v4), storage.componentEnsure(v5), storage.componentEnsure(v6)}
	hashes := []int{componentHash(v1), componentHash(v2), componentHash(v3), componentHash(v4), componentHash(v5), componentHash(v6)}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.IDs = append(compound.IDs, id)
	if compound.Values == nil {
		compound.Values = make([]any, slices.Max(components)+1)
		compound.Values[components[0]] = []T1{v1}
		compound.Values[components[1]] = []T2{v2}
		compound.Values[components[2]] = []T3{v3}
		compound.Values[components[3]] = []T4{v4}
		compound.Values[components[4]] = []T5{v5}
		compound.Values[components[5]] = []T6{v6}

		return
	}
	compound.Values[components[0]] = append(compound.Values[components[0]].([]T1), v1)
	compound.Values[components[1]] = append(compound.Values[components[1]].([]T2), v2)
	compound.Values[components[2]] = append(compound.Values[components[2]].([]T3), v3)
	compound.Values[components[3]] = append(compound.Values[components[3]].([]T4), v4)
	compound.Values[components[4]] = append(compound.Values[components[4]].([]T5), v5)
	compound.Values[components[5]] = append(compound.Values[components[5]].([]T6), v6)
}

func Set7[ID Int, T1, T2, T3, T4, T5, T6, T7 any](storage *Storage[ID], id ID, v1 T1, v2 T2, v3 T3, v4 T4, v5 T5, v6 T6, v7 T7) {
	components := []int{storage.componentEnsure(v1), storage.componentEnsure(v2), storage.componentEnsure(v3), storage.componentEnsure(v4), storage.componentEnsure(v5), storage.componentEnsure(v6), storage.componentEnsure(v7)}
	hashes := []int{componentHash(v1), componentHash(v2), componentHash(v3), componentHash(v4), componentHash(v5), componentHash(v6), componentHash(v7)}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.IDs = append(compound.IDs, id)
	if compound.Values == nil {
		compound.Values = make([]any, slices.Max(components)+1)
		compound.Values[components[0]] = []T1{v1}
		compound.Values[components[1]] = []T2{v2}
		compound.Values[components[2]] = []T3{v3}
		compound.Values[components[3]] = []T4{v4}
		compound.Values[components[4]] = []T5{v5}
		compound.Values[components[5]] = []T6{v6}
		compound.Values[components[6]] = []T7{v7}

		return
	}
	compound.Values[components[0]] = append(compound.Values[components[0]].([]T1), v1)
	compound.Values[components[1]] = append(compound.Values[components[1]].([]T2), v2)
	compound.Values[components[2]] = append(compound.Values[components[2]].([]T3), v3)
	compound.Values[components[3]] = append(compound.Values[components[3]].([]T4), v4)
	compound.Values[components[4]] = append(compound.Values[components[4]].([]T5), v5)
	compound.Values[components[5]] = append(compound.Values[components[5]].([]T6), v6)
	compound.Values[components[6]] = append(compound.Values[components[6]].([]T7), v7)
}

func Set8[ID Int, T1, T2, T3, T4, T5, T6, T7, T8 any](storage *Storage[ID], id ID, v1 T1, v2 T2, v3 T3, v4 T4, v5 T5, v6 T6, v7 T7, v8 T8) {
	components := []int{storage.componentEnsure(v1), storage.componentEnsure(v2), storage.componentEnsure(v3), storage.componentEnsure(v4), storage.componentEnsure(v5), storage.componentEnsure(v6), storage.componentEnsure(v7), storage.componentEnsure(v8)}
	hashes := []int{componentHash(v1), componentHash(v2), componentHash(v3), componentHash(v4), componentHash(v5), componentHash(v6), componentHash(v7), componentHash(v8)}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.IDs = append(compound.IDs, id)
	if compound.Values == nil {
		compound.Values = make([]any, slices.Max(components)+1)
		compound.Values[components[0]] = []T1{v1}
		compound.Values[components[1]] = []T2{v2}
		compound.Values[components[2]] = []T3{v3}
		compound.Values[components[3]] = []T4{v4}
		compound.Values[components[4]] = []T5{v5}
		compound.Values[components[5]] = []T6{v6}
		compound.Values[components[6]] = []T7{v7}
		compound.Values[components[7]] = []T8{v8}

		return
	}
	compound.Values[components[0]] = append(compound.Values[components[0]].([]T1), v1)
	compound.Values[components[1]] = append(compound.Values[components[1]].([]T2), v2)
	compound.Values[components[2]] = append(compound.Values[components[2]].([]T3), v3)
	compound.Values[components[3]] = append(compound.Values[components[3]].([]T4), v4)
	compound.Values[components[4]] = append(compound.Values[components[4]].([]T5), v5)
	compound.Values[components[5]] = append(compound.Values[components[5]].([]T6), v6)
	compound.Values[components[6]] = append(compound.Values[components[6]].([]T7), v7)
	compound.Values[components[7]] = append(compound.Values[components[7]].([]T8), v8)
}

func Set9[ID Int, T1, T2, T3, T4, T5, T6, T7, T8, T9 any](storage *Storage[ID], id ID, v1 T1, v2 T2, v3 T3, v4 T4, v5 T5, v6 T6, v7 T7, v8 T8, v9 T9) {
	components := []int{storage.componentEnsure(v1), storage.componentEnsure(v2), storage.componentEnsure(v3), storage.componentEnsure(v4), storage.componentEnsure(v5), storage.componentEnsure(v6), storage.componentEnsure(v7), storage.componentEnsure(v8), storage.componentEnsure(v9)}
	hashes := []int{componentHash(v1), componentHash(v2), componentHash(v3), componentHash(v4), componentHash(v5), componentHash(v6), componentHash(v7), componentHash(v8), componentHash(v9)}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.IDs = append(compound.IDs, id)
	if compound.Values == nil {
		compound.Values = make([]any, slices.Max(components)+1)
		compound.Values[components[0]] = []T1{v1}
		compound.Values[components[1]] = []T2{v2}
		compound.Values[components[2]] = []T3{v3}
		compound.Values[components[3]] = []T4{v4}
		compound.Values[components[4]] = []T5{v5}
		compound.Values[components[5]] = []T6{v6}
		compound.Values[components[6]] = []T7{v7}
		compound.Values[components[7]] = []T8{v8}
		compound.Values[components[8]] = []T9{v9}

		return
	}
	compound.Values[components[0]] = append(compound.Values[components[0]].([]T1), v1)
	compound.Values[components[1]] = append(compound.Values[components[1]].([]T2), v2)
	compound.Values[components[2]] = append(compound.Values[components[2]].([]T3), v3)
	compound.Values[components[3]] = append(compound.Values[components[3]].([]T4), v4)
	compound.Values[components[4]] = append(compound.Values[components[4]].([]T5), v5)
	compound.Values[components[5]] = append(compound.Values[components[5]].([]T6), v6)
	compound.Values[components[6]] = append(compound.Values[components[6]].([]T7), v7)
	compound.Values[components[7]] = append(compound.Values[components[7]].([]T8), v8)
	compound.Values[components[8]] = append(compound.Values[components[8]].([]T9), v9)
}

func Set10[ID Int, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10 any](storage *Storage[ID], id ID, v1 T1, v2 T2, v3 T3, v4 T4, v5 T5, v6 T6, v7 T7, v8 T8, v9 T9, v10 T10) {
	components := []int{storage.componentEnsure(v1), storage.componentEnsure(v2), storage.componentEnsure(v3), storage.componentEnsure(v4), storage.componentEnsure(v5), storage.componentEnsure(v6), storage.componentEnsure(v7), storage.componentEnsure(v8), storage.componentEnsure(v9), storage.componentEnsure(v10)}
	hashes := []int{componentHash(v1), componentHash(v2), componentHash(v3), componentHash(v4), componentHash(v5), componentHash(v6), componentHash(v7), componentHash(v8), componentHash(v9), componentHash(v10)}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.IDs = append(compound.IDs, id)
	if compound.Values == nil {
		compound.Values = make([]any, slices.Max(components)+1)
		compound.Values[components[0]] = []T1{v1}
		compound.Values[components[1]] = []T2{v2}
		compound.Values[components[2]] = []T3{v3}
		compound.Values[components[3]] = []T4{v4}
		compound.Values[components[4]] = []T5{v5}
		compound.Values[components[5]] = []T6{v6}
		compound.Values[components[6]] = []T7{v7}
		compound.Values[components[7]] = []T8{v8}
		compound.Values[components[8]] = []T9{v9}
		compound.Values[components[9]] = []T10{v10}

		return
	}
	compound.Values[components[0]] = append(compound.Values[components[0]].([]T1), v1)
	compound.Values[components[1]] = append(compound.Values[components[1]].([]T2), v2)
	compound.Values[components[2]] = append(compound.Values[components[2]].([]T3), v3)
	compound.Values[components[3]] = append(compound.Values[components[3]].([]T4), v4)
	compound.Values[components[4]] = append(compound.Values[components[4]].([]T5), v5)
	compound.Values[components[5]] = append(compound.Values[components[5]].([]T6), v6)
	compound.Values[components[6]] = append(compound.Values[components[6]].([]T7), v7)
	compound.Values[components[7]] = append(compound.Values[components[7]].([]T8), v8)
	compound.Values[components[8]] = append(compound.Values[components[8]].([]T9), v9)
	compound.Values[components[9]] = append(compound.Values[components[9]].([]T10), v10)
}

func Set11[ID Int, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11 any](storage *Storage[ID], id ID, v1 T1, v2 T2, v3 T3, v4 T4, v5 T5, v6 T6, v7 T7, v8 T8, v9 T9, v10 T10, v11 T11) {
	components := []int{storage.componentEnsure(v1), storage.componentEnsure(v2), storage.componentEnsure(v3), storage.componentEnsure(v4), storage.componentEnsure(v5), storage.componentEnsure(v6), storage.componentEnsure(v7), storage.componentEnsure(v8), storage.componentEnsure(v9), storage.componentEnsure(v10), storage.componentEnsure(v11)}
	hashes := []int{componentHash(v1), componentHash(v2), componentHash(v3), componentHash(v4), componentHash(v5), componentHash(v6), componentHash(v7), componentHash(v8), componentHash(v9), componentHash(v10), componentHash(v11)}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.IDs = append(compound.IDs, id)
	if compound.Values == nil {
		compound.Values = make([]any, slices.Max(components)+1)
		compound.Values[components[0]] = []T1{v1}
		compound.Values[components[1]] = []T2{v2}
		compound.Values[components[2]] = []T3{v3}
		compound.Values[components[3]] = []T4{v4}
		compound.Values[components[4]] = []T5{v5}
		compound.Values[components[5]] = []T6{v6}
		compound.Values[components[6]] = []T7{v7}
		compound.Values[components[7]] = []T8{v8}
		compound.Values[components[8]] = []T9{v9}
		compound.Values[components[9]] = []T10{v10}
		compound.Values[components[10]] = []T11{v11}

		return
	}
	compound.Values[components[0]] = append(compound.Values[components[0]].([]T1), v1)
	compound.Values[components[1]] = append(compound.Values[components[1]].([]T2), v2)
	compound.Values[components[2]] = append(compound.Values[components[2]].([]T3), v3)
	compound.Values[components[3]] = append(compound.Values[components[3]].([]T4), v4)
	compound.Values[components[4]] = append(compound.Values[components[4]].([]T5), v5)
	compound.Values[components[5]] = append(compound.Values[components[5]].([]T6), v6)
	compound.Values[components[6]] = append(compound.Values[components[6]].([]T7), v7)
	compound.Values[components[7]] = append(compound.Values[components[7]].([]T8), v8)
	compound.Values[components[8]] = append(compound.Values[components[8]].([]T9), v9)
	compound.Values[components[9]] = append(compound.Values[components[9]].([]T10), v10)
	compound.Values[components[10]] = append(compound.Values[components[10]].([]T11), v11)
}

func Set12[ID Int, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12 any](storage *Storage[ID], id ID, v1 T1, v2 T2, v3 T3, v4 T4, v5 T5, v6 T6, v7 T7, v8 T8, v9 T9, v10 T10, v11 T11, v12 T12) {
	components := []int{storage.componentEnsure(v1), storage.componentEnsure(v2), storage.componentEnsure(v3), storage.componentEnsure(v4), storage.componentEnsure(v5), storage.componentEnsure(v6), storage.componentEnsure(v7), storage.componentEnsure(v8), storage.componentEnsure(v9), storage.componentEnsure(v10), storage.componentEnsure(v11), storage.componentEnsure(v12)}
	hashes := []int{componentHash(v1), componentHash(v2), componentHash(v3), componentHash(v4), componentHash(v5), componentHash(v6), componentHash(v7), componentHash(v8), componentHash(v9), componentHash(v10), componentHash(v11), componentHash(v12)}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.IDs = append(compound.IDs, id)
	if compound.Values == nil {
		compound.Values = make([]any, slices.Max(components)+1)
		compound.Values[components[0]] = []T1{v1}
		compound.Values[components[1]] = []T2{v2}
		compound.Values[components[2]] = []T3{v3}
		compound.Values[components[3]] = []T4{v4}
		compound.Values[components[4]] = []T5{v5}
		compound.Values[components[5]] = []T6{v6}
		compound.Values[components[6]] = []T7{v7}
		compound.Values[components[7]] = []T8{v8}
		compound.Values[components[8]] = []T9{v9}
		compound.Values[components[9]] = []T10{v10}
		compound.Values[components[10]] = []T11{v11}
		compound.Values[components[11]] = []T12{v12}

		return
	}
	compound.Values[components[0]] = append(compound.Values[components[0]].([]T1), v1)
	compound.Values[components[1]] = append(compound.Values[components[1]].([]T2), v2)
	compound.Values[components[2]] = append(compound.Values[components[2]].([]T3), v3)
	compound.Values[components[3]] = append(compound.Values[components[3]].([]T4), v4)
	compound.Values[components[4]] = append(compound.Values[components[4]].([]T5), v5)
	compound.Values[components[5]] = append(compound.Values[components[5]].([]T6), v6)
	compound.Values[components[6]] = append(compound.Values[components[6]].([]T7), v7)
	compound.Values[components[7]] = append(compound.Values[components[7]].([]T8), v8)
	compound.Values[components[8]] = append(compound.Values[components[8]].([]T9), v9)
	compound.Values[components[9]] = append(compound.Values[components[9]].([]T10), v10)
	compound.Values[components[10]] = append(compound.Values[components[10]].([]T11), v11)
	compound.Values[components[11]] = append(compound.Values[components[11]].([]T12), v12)
}

func Set13[ID Int, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13 any](storage *Storage[ID], id ID, v1 T1, v2 T2, v3 T3, v4 T4, v5 T5, v6 T6, v7 T7, v8 T8, v9 T9, v10 T10, v11 T11, v12 T12, v13 T13) {
	components := []int{storage.componentEnsure(v1), storage.componentEnsure(v2), storage.componentEnsure(v3), storage.componentEnsure(v4), storage.componentEnsure(v5), storage.componentEnsure(v6), storage.componentEnsure(v7), storage.componentEnsure(v8), storage.componentEnsure(v9), storage.componentEnsure(v10), storage.componentEnsure(v11), storage.componentEnsure(v12), storage.componentEnsure(v13)}
	hashes := []int{componentHash(v1), componentHash(v2), componentHash(v3), componentHash(v4), componentHash(v5), componentHash(v6), componentHash(v7), componentHash(v8), componentHash(v9), componentHash(v10), componentHash(v11), componentHash(v12), componentHash(v13)}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.IDs = append(compound.IDs, id)
	if compound.Values == nil {
		compound.Values = make([]any, slices.Max(components)+1)
		compound.Values[components[0]] = []T1{v1}
		compound.Values[components[1]] = []T2{v2}
		compound.Values[components[2]] = []T3{v3}
		compound.Values[components[3]] = []T4{v4}
		compound.Values[components[4]] = []T5{v5}
		compound.Values[components[5]] = []T6{v6}
		compound.Values[components[6]] = []T7{v7}
		compound.Values[components[7]] = []T8{v8}
		compound.Values[components[8]] = []T9{v9}
		compound.Values[components[9]] = []T10{v10}
		compound.Values[components[10]] = []T11{v11}
		compound.Values[components[11]] = []T12{v12}
		compound.Values[components[12]] = []T13{v13}

		return
	}
	compound.Values[components[0]] = append(compound.Values[components[0]].([]T1), v1)
	compound.Values[components[1]] = append(compound.Values[components[1]].([]T2), v2)
	compound.Values[components[2]] = append(compound.Values[components[2]].([]T3), v3)
	compound.Values[components[3]] = append(compound.Values[components[3]].([]T4), v4)
	compound.Values[components[4]] = append(compound.Values[components[4]].([]T5), v5)
	compound.Values[components[5]] = append(compound.Values[components[5]].([]T6), v6)
	compound.Values[components[6]] = append(compound.Values[components[6]].([]T7), v7)
	compound.Values[components[7]] = append(compound.Values[components[7]].([]T8), v8)
	compound.Values[components[8]] = append(compound.Values[components[8]].([]T9), v9)
	compound.Values[components[9]] = append(compound.Values[components[9]].([]T10), v10)
	compound.Values[components[10]] = append(compound.Values[components[10]].([]T11), v11)
	compound.Values[components[11]] = append(compound.Values[components[11]].([]T12), v12)
	compound.Values[components[12]] = append(compound.Values[components[12]].([]T13), v13)
}

func Set14[ID Int, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14 any](storage *Storage[ID], id ID, v1 T1, v2 T2, v3 T3, v4 T4, v5 T5, v6 T6, v7 T7, v8 T8, v9 T9, v10 T10, v11 T11, v12 T12, v13 T13, v14 T14) {
	components := []int{storage.componentEnsure(v1), storage.componentEnsure(v2), storage.componentEnsure(v3), storage.componentEnsure(v4), storage.componentEnsure(v5), storage.componentEnsure(v6), storage.componentEnsure(v7), storage.componentEnsure(v8), storage.componentEnsure(v9), storage.componentEnsure(v10), storage.componentEnsure(v11), storage.componentEnsure(v12), storage.componentEnsure(v13), storage.componentEnsure(v14)}
	hashes := []int{componentHash(v1), componentHash(v2), componentHash(v3), componentHash(v4), componentHash(v5), componentHash(v6), componentHash(v7), componentHash(v8), componentHash(v9), componentHash(v10), componentHash(v11), componentHash(v12), componentHash(v13), componentHash(v14)}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.IDs = append(compound.IDs, id)
	if compound.Values == nil {
		compound.Values = make([]any, slices.Max(components)+1)
		compound.Values[components[0]] = []T1{v1}
		compound.Values[components[1]] = []T2{v2}
		compound.Values[components[2]] = []T3{v3}
		compound.Values[components[3]] = []T4{v4}
		compound.Values[components[4]] = []T5{v5}
		compound.Values[components[5]] = []T6{v6}
		compound.Values[components[6]] = []T7{v7}
		compound.Values[components[7]] = []T8{v8}
		compound.Values[components[8]] = []T9{v9}
		compound.Values[components[9]] = []T10{v10}
		compound.Values[components[10]] = []T11{v11}
		compound.Values[components[11]] = []T12{v12}
		compound.Values[components[12]] = []T13{v13}
		compound.Values[components[13]] = []T14{v14}

		return
	}
	compound.Values[components[0]] = append(compound.Values[components[0]].([]T1), v1)
	compound.Values[components[1]] = append(compound.Values[components[1]].([]T2), v2)
	compound.Values[components[2]] = append(compound.Values[components[2]].([]T3), v3)
	compound.Values[components[3]] = append(compound.Values[components[3]].([]T4), v4)
	compound.Values[components[4]] = append(compound.Values[components[4]].([]T5), v5)
	compound.Values[components[5]] = append(compound.Values[components[5]].([]T6), v6)
	compound.Values[components[6]] = append(compound.Values[components[6]].([]T7), v7)
	compound.Values[components[7]] = append(compound.Values[components[7]].([]T8), v8)
	compound.Values[components[8]] = append(compound.Values[components[8]].([]T9), v9)
	compound.Values[components[9]] = append(compound.Values[components[9]].([]T10), v10)
	compound.Values[components[10]] = append(compound.Values[components[10]].([]T11), v11)
	compound.Values[components[11]] = append(compound.Values[components[11]].([]T12), v12)
	compound.Values[components[12]] = append(compound.Values[components[12]].([]T13), v13)
	compound.Values[components[13]] = append(compound.Values[components[13]].([]T14), v14)
}

func Set15[ID Int, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15 any](storage *Storage[ID], id ID, v1 T1, v2 T2, v3 T3, v4 T4, v5 T5, v6 T6, v7 T7, v8 T8, v9 T9, v10 T10, v11 T11, v12 T12, v13 T13, v14 T14, v15 T15) {
	components := []int{storage.componentEnsure(v1), storage.componentEnsure(v2), storage.componentEnsure(v3), storage.componentEnsure(v4), storage.componentEnsure(v5), storage.componentEnsure(v6), storage.componentEnsure(v7), storage.componentEnsure(v8), storage.componentEnsure(v9), storage.componentEnsure(v10), storage.componentEnsure(v11), storage.componentEnsure(v12), storage.componentEnsure(v13), storage.componentEnsure(v14), storage.componentEnsure(v15)}
	hashes := []int{componentHash(v1), componentHash(v2), componentHash(v3), componentHash(v4), componentHash(v5), componentHash(v6), componentHash(v7), componentHash(v8), componentHash(v9), componentHash(v10), componentHash(v11), componentHash(v12), componentHash(v13), componentHash(v14), componentHash(v15)}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.IDs = append(compound.IDs, id)
	if compound.Values == nil {
		compound.Values = make([]any, slices.Max(components)+1)
		compound.Values[components[0]] = []T1{v1}
		compound.Values[components[1]] = []T2{v2}
		compound.Values[components[2]] = []T3{v3}
		compound.Values[components[3]] = []T4{v4}
		compound.Values[components[4]] = []T5{v5}
		compound.Values[components[5]] = []T6{v6}
		compound.Values[components[6]] = []T7{v7}
		compound.Values[components[7]] = []T8{v8}
		compound.Values[components[8]] = []T9{v9}
		compound.Values[components[9]] = []T10{v10}
		compound.Values[components[10]] = []T11{v11}
		compound.Values[components[11]] = []T12{v12}
		compound.Values[components[12]] = []T13{v13}
		compound.Values[components[13]] = []T14{v14}
		compound.Values[components[14]] = []T15{v15}

		return
	}
	compound.Values[components[0]] = append(compound.Values[components[0]].([]T1), v1)
	compound.Values[components[1]] = append(compound.Values[components[1]].([]T2), v2)
	compound.Values[components[2]] = append(compound.Values[components[2]].([]T3), v3)
	compound.Values[components[3]] = append(compound.Values[components[3]].([]T4), v4)
	compound.Values[components[4]] = append(compound.Values[components[4]].([]T5), v5)
	compound.Values[components[5]] = append(compound.Values[components[5]].([]T6), v6)
	compound.Values[components[6]] = append(compound.Values[components[6]].([]T7), v7)
	compound.Values[components[7]] = append(compound.Values[components[7]].([]T8), v8)
	compound.Values[components[8]] = append(compound.Values[components[8]].([]T9), v9)
	compound.Values[components[9]] = append(compound.Values[components[9]].([]T10), v10)
	compound.Values[components[10]] = append(compound.Values[components[10]].([]T11), v11)
	compound.Values[components[11]] = append(compound.Values[components[11]].([]T12), v12)
	compound.Values[components[12]] = append(compound.Values[components[12]].([]T13), v13)
	compound.Values[components[13]] = append(compound.Values[components[13]].([]T14), v14)
	compound.Values[components[14]] = append(compound.Values[components[14]].([]T15), v15)
}

func Set16[ID Int, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16 any](storage *Storage[ID], id ID, v1 T1, v2 T2, v3 T3, v4 T4, v5 T5, v6 T6, v7 T7, v8 T8, v9 T9, v10 T10, v11 T11, v12 T12, v13 T13, v14 T14, v15 T15, v16 T16) {
	components := []int{storage.componentEnsure(v1), storage.componentEnsure(v2), storage.componentEnsure(v3), storage.componentEnsure(v4), storage.componentEnsure(v5), storage.componentEnsure(v6), storage.componentEnsure(v7), storage.componentEnsure(v8), storage.componentEnsure(v9), storage.componentEnsure(v10), storage.componentEnsure(v11), storage.componentEnsure(v12), storage.componentEnsure(v13), storage.componentEnsure(v14), storage.componentEnsure(v15), storage.componentEnsure(v16)}
	hashes := []int{componentHash(v1), componentHash(v2), componentHash(v3), componentHash(v4), componentHash(v5), componentHash(v6), componentHash(v7), componentHash(v8), componentHash(v9), componentHash(v10), componentHash(v11), componentHash(v12), componentHash(v13), componentHash(v14), componentHash(v15), componentHash(v16)}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.IDs = append(compound.IDs, id)
	if compound.Values == nil {
		compound.Values = make([]any, slices.Max(components)+1)
		compound.Values[components[0]] = []T1{v1}
		compound.Values[components[1]] = []T2{v2}
		compound.Values[components[2]] = []T3{v3}
		compound.Values[components[3]] = []T4{v4}
		compound.Values[components[4]] = []T5{v5}
		compound.Values[components[5]] = []T6{v6}
		compound.Values[components[6]] = []T7{v7}
		compound.Values[components[7]] = []T8{v8}
		compound.Values[components[8]] = []T9{v9}
		compound.Values[components[9]] = []T10{v10}
		compound.Values[components[10]] = []T11{v11}
		compound.Values[components[11]] = []T12{v12}
		compound.Values[components[12]] = []T13{v13}
		compound.Values[components[13]] = []T14{v14}
		compound.Values[components[14]] = []T15{v15}
		compound.Values[components[15]] = []T16{v16}

		return
	}
	compound.Values[components[0]] = append(compound.Values[components[0]].([]T1), v1)
	compound.Values[components[1]] = append(compound.Values[components[1]].([]T2), v2)
	compound.Values[components[2]] = append(compound.Values[components[2]].([]T3), v3)
	compound.Values[components[3]] = append(compound.Values[components[3]].([]T4), v4)
	compound.Values[components[4]] = append(compound.Values[components[4]].([]T5), v5)
	compound.Values[components[5]] = append(compound.Values[components[5]].([]T6), v6)
	compound.Values[components[6]] = append(compound.Values[components[6]].([]T7), v7)
	compound.Values[components[7]] = append(compound.Values[components[7]].([]T8), v8)
	compound.Values[components[8]] = append(compound.Values[components[8]].([]T9), v9)
	compound.Values[components[9]] = append(compound.Values[components[9]].([]T10), v10)
	compound.Values[components[10]] = append(compound.Values[components[10]].([]T11), v11)
	compound.Values[components[11]] = append(compound.Values[components[11]].([]T12), v12)
	compound.Values[components[12]] = append(compound.Values[components[12]].([]T13), v13)
	compound.Values[components[13]] = append(compound.Values[components[13]].([]T14), v14)
	compound.Values[components[14]] = append(compound.Values[components[14]].([]T15), v15)
	compound.Values[components[15]] = append(compound.Values[components[15]].([]T16), v16)
}

func Set17[ID Int, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17 any](storage *Storage[ID], id ID, v1 T1, v2 T2, v3 T3, v4 T4, v5 T5, v6 T6, v7 T7, v8 T8, v9 T9, v10 T10, v11 T11, v12 T12, v13 T13, v14 T14, v15 T15, v16 T16, v17 T17) {
	components := []int{storage.componentEnsure(v1), storage.componentEnsure(v2), storage.componentEnsure(v3), storage.componentEnsure(v4), storage.componentEnsure(v5), storage.componentEnsure(v6), storage.componentEnsure(v7), storage.componentEnsure(v8), storage.componentEnsure(v9), storage.componentEnsure(v10), storage.componentEnsure(v11), storage.componentEnsure(v12), storage.componentEnsure(v13), storage.componentEnsure(v14), storage.componentEnsure(v15), storage.componentEnsure(v16), storage.componentEnsure(v17)}
	hashes := []int{componentHash(v1), componentHash(v2), componentHash(v3), componentHash(v4), componentHash(v5), componentHash(v6), componentHash(v7), componentHash(v8), componentHash(v9), componentHash(v10), componentHash(v11), componentHash(v12), componentHash(v13), componentHash(v14), componentHash(v15), componentHash(v16), componentHash(v17)}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.IDs = append(compound.IDs, id)
	if compound.Values == nil {
		compound.Values = make([]any, slices.Max(components)+1)
		compound.Values[components[0]] = []T1{v1}
		compound.Values[components[1]] = []T2{v2}
		compound.Values[components[2]] = []T3{v3}
		compound.Values[components[3]] = []T4{v4}
		compound.Values[components[4]] = []T5{v5}
		compound.Values[components[5]] = []T6{v6}
		compound.Values[components[6]] = []T7{v7}
		compound.Values[components[7]] = []T8{v8}
		compound.Values[components[8]] = []T9{v9}
		compound.Values[components[9]] = []T10{v10}
		compound.Values[components[10]] = []T11{v11}
		compound.Values[components[11]] = []T12{v12}
		compound.Values[components[12]] = []T13{v13}
		compound.Values[components[13]] = []T14{v14}
		compound.Values[components[14]] = []T15{v15}
		compound.Values[components[15]] = []T16{v16}
		compound.Values[components[16]] = []T17{v17}

		return
	}
	compound.Values[components[0]] = append(compound.Values[components[0]].([]T1), v1)
	compound.Values[components[1]] = append(compound.Values[components[1]].([]T2), v2)
	compound.Values[components[2]] = append(compound.Values[components[2]].([]T3), v3)
	compound.Values[components[3]] = append(compound.Values[components[3]].([]T4), v4)
	compound.Values[components[4]] = append(compound.Values[components[4]].([]T5), v5)
	compound.Values[components[5]] = append(compound.Values[components[5]].([]T6), v6)
	compound.Values[components[6]] = append(compound.Values[components[6]].([]T7), v7)
	compound.Values[components[7]] = append(compound.Values[components[7]].([]T8), v8)
	compound.Values[components[8]] = append(compound.Values[components[8]].([]T9), v9)
	compound.Values[components[9]] = append(compound.Values[components[9]].([]T10), v10)
	compound.Values[components[10]] = append(compound.Values[components[10]].([]T11), v11)
	compound.Values[components[11]] = append(compound.Values[components[11]].([]T12), v12)
	compound.Values[components[12]] = append(compound.Values[components[12]].([]T13), v13)
	compound.Values[components[13]] = append(compound.Values[components[13]].([]T14), v14)
	compound.Values[components[14]] = append(compound.Values[components[14]].([]T15), v15)
	compound.Values[components[15]] = append(compound.Values[components[15]].([]T16), v16)
	compound.Values[components[16]] = append(compound.Values[components[16]].([]T17), v17)
}

func Set18[ID Int, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18 any](storage *Storage[ID], id ID, v1 T1, v2 T2, v3 T3, v4 T4, v5 T5, v6 T6, v7 T7, v8 T8, v9 T9, v10 T10, v11 T11, v12 T12, v13 T13, v14 T14, v15 T15, v16 T16, v17 T17, v18 T18) {
	components := []int{storage.componentEnsure(v1), storage.componentEnsure(v2), storage.componentEnsure(v3), storage.componentEnsure(v4), storage.componentEnsure(v5), storage.componentEnsure(v6), storage.componentEnsure(v7), storage.componentEnsure(v8), storage.componentEnsure(v9), storage.componentEnsure(v10), storage.componentEnsure(v11), storage.componentEnsure(v12), storage.componentEnsure(v13), storage.componentEnsure(v14), storage.componentEnsure(v15), storage.componentEnsure(v16), storage.componentEnsure(v17), storage.componentEnsure(v18)}
	hashes := []int{componentHash(v1), componentHash(v2), componentHash(v3), componentHash(v4), componentHash(v5), componentHash(v6), componentHash(v7), componentHash(v8), componentHash(v9), componentHash(v10), componentHash(v11), componentHash(v12), componentHash(v13), componentHash(v14), componentHash(v15), componentHash(v16), componentHash(v17), componentHash(v18)}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.IDs = append(compound.IDs, id)
	if compound.Values == nil {
		compound.Values = make([]any, slices.Max(components)+1)
		compound.Values[components[0]] = []T1{v1}
		compound.Values[components[1]] = []T2{v2}
		compound.Values[components[2]] = []T3{v3}
		compound.Values[components[3]] = []T4{v4}
		compound.Values[components[4]] = []T5{v5}
		compound.Values[components[5]] = []T6{v6}
		compound.Values[components[6]] = []T7{v7}
		compound.Values[components[7]] = []T8{v8}
		compound.Values[components[8]] = []T9{v9}
		compound.Values[components[9]] = []T10{v10}
		compound.Values[components[10]] = []T11{v11}
		compound.Values[components[11]] = []T12{v12}
		compound.Values[components[12]] = []T13{v13}
		compound.Values[components[13]] = []T14{v14}
		compound.Values[components[14]] = []T15{v15}
		compound.Values[components[15]] = []T16{v16}
		compound.Values[components[16]] = []T17{v17}
		compound.Values[components[17]] = []T18{v18}

		return
	}
	compound.Values[components[0]] = append(compound.Values[components[0]].([]T1), v1)
	compound.Values[components[1]] = append(compound.Values[components[1]].([]T2), v2)
	compound.Values[components[2]] = append(compound.Values[components[2]].([]T3), v3)
	compound.Values[components[3]] = append(compound.Values[components[3]].([]T4), v4)
	compound.Values[components[4]] = append(compound.Values[components[4]].([]T5), v5)
	compound.Values[components[5]] = append(compound.Values[components[5]].([]T6), v6)
	compound.Values[components[6]] = append(compound.Values[components[6]].([]T7), v7)
	compound.Values[components[7]] = append(compound.Values[components[7]].([]T8), v8)
	compound.Values[components[8]] = append(compound.Values[components[8]].([]T9), v9)
	compound.Values[components[9]] = append(compound.Values[components[9]].([]T10), v10)
	compound.Values[components[10]] = append(compound.Values[components[10]].([]T11), v11)
	compound.Values[components[11]] = append(compound.Values[components[11]].([]T12), v12)
	compound.Values[components[12]] = append(compound.Values[components[12]].([]T13), v13)
	compound.Values[components[13]] = append(compound.Values[components[13]].([]T14), v14)
	compound.Values[components[14]] = append(compound.Values[components[14]].([]T15), v15)
	compound.Values[components[15]] = append(compound.Values[components[15]].([]T16), v16)
	compound.Values[components[16]] = append(compound.Values[components[16]].([]T17), v17)
	compound.Values[components[17]] = append(compound.Values[components[17]].([]T18), v18)
}

func Set19[ID Int, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19 any](storage *Storage[ID], id ID, v1 T1, v2 T2, v3 T3, v4 T4, v5 T5, v6 T6, v7 T7, v8 T8, v9 T9, v10 T10, v11 T11, v12 T12, v13 T13, v14 T14, v15 T15, v16 T16, v17 T17, v18 T18, v19 T19) {
	components := []int{storage.componentEnsure(v1), storage.componentEnsure(v2), storage.componentEnsure(v3), storage.componentEnsure(v4), storage.componentEnsure(v5), storage.componentEnsure(v6), storage.componentEnsure(v7), storage.componentEnsure(v8), storage.componentEnsure(v9), storage.componentEnsure(v10), storage.componentEnsure(v11), storage.componentEnsure(v12), storage.componentEnsure(v13), storage.componentEnsure(v14), storage.componentEnsure(v15), storage.componentEnsure(v16), storage.componentEnsure(v17), storage.componentEnsure(v18), storage.componentEnsure(v19)}
	hashes := []int{componentHash(v1), componentHash(v2), componentHash(v3), componentHash(v4), componentHash(v5), componentHash(v6), componentHash(v7), componentHash(v8), componentHash(v9), componentHash(v10), componentHash(v11), componentHash(v12), componentHash(v13), componentHash(v14), componentHash(v15), componentHash(v16), componentHash(v17), componentHash(v18), componentHash(v19)}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.IDs = append(compound.IDs, id)
	if compound.Values == nil {
		compound.Values = make([]any, slices.Max(components)+1)
		compound.Values[components[0]] = []T1{v1}
		compound.Values[components[1]] = []T2{v2}
		compound.Values[components[2]] = []T3{v3}
		compound.Values[components[3]] = []T4{v4}
		compound.Values[components[4]] = []T5{v5}
		compound.Values[components[5]] = []T6{v6}
		compound.Values[components[6]] = []T7{v7}
		compound.Values[components[7]] = []T8{v8}
		compound.Values[components[8]] = []T9{v9}
		compound.Values[components[9]] = []T10{v10}
		compound.Values[components[10]] = []T11{v11}
		compound.Values[components[11]] = []T12{v12}
		compound.Values[components[12]] = []T13{v13}
		compound.Values[components[13]] = []T14{v14}
		compound.Values[components[14]] = []T15{v15}
		compound.Values[components[15]] = []T16{v16}
		compound.Values[components[16]] = []T17{v17}
		compound.Values[components[17]] = []T18{v18}
		compound.Values[components[18]] = []T19{v19}

		return
	}
	compound.Values[components[0]] = append(compound.Values[components[0]].([]T1), v1)
	compound.Values[components[1]] = append(compound.Values[components[1]].([]T2), v2)
	compound.Values[components[2]] = append(compound.Values[components[2]].([]T3), v3)
	compound.Values[components[3]] = append(compound.Values[components[3]].([]T4), v4)
	compound.Values[components[4]] = append(compound.Values[components[4]].([]T5), v5)
	compound.Values[components[5]] = append(compound.Values[components[5]].([]T6), v6)
	compound.Values[components[6]] = append(compound.Values[components[6]].([]T7), v7)
	compound.Values[components[7]] = append(compound.Values[components[7]].([]T8), v8)
	compound.Values[components[8]] = append(compound.Values[components[8]].([]T9), v9)
	compound.Values[components[9]] = append(compound.Values[components[9]].([]T10), v10)
	compound.Values[components[10]] = append(compound.Values[components[10]].([]T11), v11)
	compound.Values[components[11]] = append(compound.Values[components[11]].([]T12), v12)
	compound.Values[components[12]] = append(compound.Values[components[12]].([]T13), v13)
	compound.Values[components[13]] = append(compound.Values[components[13]].([]T14), v14)
	compound.Values[components[14]] = append(compound.Values[components[14]].([]T15), v15)
	compound.Values[components[15]] = append(compound.Values[components[15]].([]T16), v16)
	compound.Values[components[16]] = append(compound.Values[components[16]].([]T17), v17)
	compound.Values[components[17]] = append(compound.Values[components[17]].([]T18), v18)
	compound.Values[components[18]] = append(compound.Values[components[18]].([]T19), v19)
}

func Set20[ID Int, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20 any](storage *Storage[ID], id ID, v1 T1, v2 T2, v3 T3, v4 T4, v5 T5, v6 T6, v7 T7, v8 T8, v9 T9, v10 T10, v11 T11, v12 T12, v13 T13, v14 T14, v15 T15, v16 T16, v17 T17, v18 T18, v19 T19, v20 T20) {
	components := []int{storage.componentEnsure(v1), storage.componentEnsure(v2), storage.componentEnsure(v3), storage.componentEnsure(v4), storage.componentEnsure(v5), storage.componentEnsure(v6), storage.componentEnsure(v7), storage.componentEnsure(v8), storage.componentEnsure(v9), storage.componentEnsure(v10), storage.componentEnsure(v11), storage.componentEnsure(v12), storage.componentEnsure(v13), storage.componentEnsure(v14), storage.componentEnsure(v15), storage.componentEnsure(v16), storage.componentEnsure(v17), storage.componentEnsure(v18), storage.componentEnsure(v19), storage.componentEnsure(v20)}
	hashes := []int{componentHash(v1), componentHash(v2), componentHash(v3), componentHash(v4), componentHash(v5), componentHash(v6), componentHash(v7), componentHash(v8), componentHash(v9), componentHash(v10), componentHash(v11), componentHash(v12), componentHash(v13), componentHash(v14), componentHash(v15), componentHash(v16), componentHash(v17), componentHash(v18), componentHash(v19), componentHash(v20)}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.IDs = append(compound.IDs, id)
	if compound.Values == nil {
		compound.Values = make([]any, slices.Max(components)+1)
		compound.Values[components[0]] = []T1{v1}
		compound.Values[components[1]] = []T2{v2}
		compound.Values[components[2]] = []T3{v3}
		compound.Values[components[3]] = []T4{v4}
		compound.Values[components[4]] = []T5{v5}
		compound.Values[components[5]] = []T6{v6}
		compound.Values[components[6]] = []T7{v7}
		compound.Values[components[7]] = []T8{v8}
		compound.Values[components[8]] = []T9{v9}
		compound.Values[components[9]] = []T10{v10}
		compound.Values[components[10]] = []T11{v11}
		compound.Values[components[11]] = []T12{v12}
		compound.Values[components[12]] = []T13{v13}
		compound.Values[components[13]] = []T14{v14}
		compound.Values[components[14]] = []T15{v15}
		compound.Values[components[15]] = []T16{v16}
		compound.Values[components[16]] = []T17{v17}
		compound.Values[components[17]] = []T18{v18}
		compound.Values[components[18]] = []T19{v19}
		compound.Values[components[19]] = []T20{v20}

		return
	}
	compound.Values[components[0]] = append(compound.Values[components[0]].([]T1), v1)
	compound.Values[components[1]] = append(compound.Values[components[1]].([]T2), v2)
	compound.Values[components[2]] = append(compound.Values[components[2]].([]T3), v3)
	compound.Values[components[3]] = append(compound.Values[components[3]].([]T4), v4)
	compound.Values[components[4]] = append(compound.Values[components[4]].([]T5), v5)
	compound.Values[components[5]] = append(compound.Values[components[5]].([]T6), v6)
	compound.Values[components[6]] = append(compound.Values[components[6]].([]T7), v7)
	compound.Values[components[7]] = append(compound.Values[components[7]].([]T8), v8)
	compound.Values[components[8]] = append(compound.Values[components[8]].([]T9), v9)
	compound.Values[components[9]] = append(compound.Values[components[9]].([]T10), v10)
	compound.Values[components[10]] = append(compound.Values[components[10]].([]T11), v11)
	compound.Values[components[11]] = append(compound.Values[components[11]].([]T12), v12)
	compound.Values[components[12]] = append(compound.Values[components[12]].([]T13), v13)
	compound.Values[components[13]] = append(compound.Values[components[13]].([]T14), v14)
	compound.Values[components[14]] = append(compound.Values[components[14]].([]T15), v15)
	compound.Values[components[15]] = append(compound.Values[components[15]].([]T16), v16)
	compound.Values[components[16]] = append(compound.Values[components[16]].([]T17), v17)
	compound.Values[components[17]] = append(compound.Values[components[17]].([]T18), v18)
	compound.Values[components[18]] = append(compound.Values[components[18]].([]T19), v19)
	compound.Values[components[19]] = append(compound.Values[components[19]].([]T20), v20)
}

type Q1[ID Int, T1 any] struct {
	storage    *Storage[ID]
	Components [1]int
	Errors     []error
}
type Q1Option struct {
	Optional [1]bool
	Stop     *bool
	Hash     *ComponentHash
}
type Q2[ID Int, T1 any, T2 any] struct {
	storage    *Storage[ID]
	Components [2]int
	Errors     []error
}
type Q2Option struct {
	Optional [2]bool
	Stop     *bool
	Hash     *ComponentHash
}
type Q3[ID Int, T1 any, T2 any, T3 any] struct {
	storage    *Storage[ID]
	Components [3]int
	Errors     []error
}
type Q3Option struct {
	Optional [3]bool
	Stop     *bool
	Hash     *ComponentHash
}
type Q4[ID Int, T1 any, T2 any, T3 any, T4 any] struct {
	storage    *Storage[ID]
	Components [4]int
	Errors     []error
}
type Q4Option struct {
	Optional [4]bool
	Stop     *bool
	Hash     *ComponentHash
}
type Q5[ID Int, T1 any, T2 any, T3 any, T4 any, T5 any] struct {
	storage    *Storage[ID]
	Components [5]int
	Errors     []error
}
type Q5Option struct {
	Optional [5]bool
	Stop     *bool
	Hash     *ComponentHash
}
type Q6[ID Int, T1 any, T2 any, T3 any, T4 any, T5 any, T6 any] struct {
	storage    *Storage[ID]
	Components [6]int
	Errors     []error
}
type Q6Option struct {
	Optional [6]bool
	Stop     *bool
	Hash     *ComponentHash
}
type Q7[ID Int, T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any] struct {
	storage    *Storage[ID]
	Components [7]int
	Errors     []error
}
type Q7Option struct {
	Optional [7]bool
	Stop     *bool
	Hash     *ComponentHash
}
type Q8[ID Int, T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any] struct {
	storage    *Storage[ID]
	Components [8]int
	Errors     []error
}
type Q8Option struct {
	Optional [8]bool
	Stop     *bool
	Hash     *ComponentHash
}
type Q9[ID Int, T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any] struct {
	storage    *Storage[ID]
	Components [9]int
	Errors     []error
}
type Q9Option struct {
	Optional [9]bool
	Stop     *bool
	Hash     *ComponentHash
}
type Q10[ID Int, T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any] struct {
	storage    *Storage[ID]
	Components [10]int
	Errors     []error
}
type Q10Option struct {
	Optional [10]bool
	Stop     *bool
	Hash     *ComponentHash
}
type Q11[ID Int, T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any] struct {
	storage    *Storage[ID]
	Components [11]int
	Errors     []error
}
type Q11Option struct {
	Optional [11]bool
	Stop     *bool
	Hash     *ComponentHash
}
type Q12[ID Int, T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any] struct {
	storage    *Storage[ID]
	Components [12]int
	Errors     []error
}
type Q12Option struct {
	Optional [12]bool
	Stop     *bool
	Hash     *ComponentHash
}
type Q13[ID Int, T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any] struct {
	storage    *Storage[ID]
	Components [13]int
	Errors     []error
}
type Q13Option struct {
	Optional [13]bool
	Stop     *bool
	Hash     *ComponentHash
}
type Q14[ID Int, T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any] struct {
	storage    *Storage[ID]
	Components [14]int
	Errors     []error
}
type Q14Option struct {
	Optional [14]bool
	Stop     *bool
	Hash     *ComponentHash
}
type Q15[ID Int, T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, T15 any] struct {
	storage    *Storage[ID]
	Components [15]int
	Errors     []error
}
type Q15Option struct {
	Optional [15]bool
	Stop     *bool
	Hash     *ComponentHash
}
type Q16[ID Int, T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, T15 any, T16 any] struct {
	storage    *Storage[ID]
	Components [16]int
	Errors     []error
}
type Q16Option struct {
	Optional [16]bool
	Stop     *bool
	Hash     *ComponentHash
}
type Q17[ID Int, T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, T15 any, T16 any, T17 any] struct {
	storage    *Storage[ID]
	Components [17]int
	Errors     []error
}
type Q17Option struct {
	Optional [17]bool
	Stop     *bool
	Hash     *ComponentHash
}
type Q18[ID Int, T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, T15 any, T16 any, T17 any, T18 any] struct {
	storage    *Storage[ID]
	Components [18]int
	Errors     []error
}
type Q18Option struct {
	Optional [18]bool
	Stop     *bool
	Hash     *ComponentHash
}
type Q19[ID Int, T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, T15 any, T16 any, T17 any, T18 any, T19 any] struct {
	storage    *Storage[ID]
	Components [19]int
	Errors     []error
}
type Q19Option struct {
	Optional [19]bool
	Stop     *bool
	Hash     *ComponentHash
}
type Q20[ID Int, T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, T15 any, T16 any, T17 any, T18 any, T19 any, T20 any] struct {
	storage    *Storage[ID]
	Components [20]int
	Errors     []error
}
type Q20Option struct {
	Optional [20]bool
	Stop     *bool
	Hash     *ComponentHash
}

func Query1[T1 any, ID Int](storage *Storage[ID]) *Q1[ID, T1] {
	q := &Q1[ID, T1]{storage: storage}
	{
		name := typeName[T1]()
		id, ok := storage.getComponent(name)
		q.Components[0] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 1 \"%s\" does not exist", name))
		}
	}
	return q
}

func Query2[T1 any, T2 any, ID Int](storage *Storage[ID]) *Q2[ID, T1, T2] {
	q := &Q2[ID, T1, T2]{storage: storage}
	{
		name := typeName[T1]()
		id, ok := storage.getComponent(name)
		q.Components[0] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 1 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T2]()
		id, ok := storage.getComponent(name)
		q.Components[1] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 2 \"%s\" does not exist", name))
		}
	}
	return q
}

func Query3[T1 any, T2 any, T3 any, ID Int](storage *Storage[ID]) *Q3[ID, T1, T2, T3] {
	q := &Q3[ID, T1, T2, T3]{storage: storage}
	{
		name := typeName[T1]()
		id, ok := storage.getComponent(name)
		q.Components[0] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 1 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T2]()
		id, ok := storage.getComponent(name)
		q.Components[1] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 2 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T3]()
		id, ok := storage.getComponent(name)
		q.Components[2] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 3 \"%s\" does not exist", name))
		}
	}
	return q
}

func Query4[T1 any, T2 any, T3 any, T4 any, ID Int](storage *Storage[ID]) *Q4[ID, T1, T2, T3, T4] {
	q := &Q4[ID, T1, T2, T3, T4]{storage: storage}
	{
		name := typeName[T1]()
		id, ok := storage.getComponent(name)
		q.Components[0] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 1 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T2]()
		id, ok := storage.getComponent(name)
		q.Components[1] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 2 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T3]()
		id, ok := storage.getComponent(name)
		q.Components[2] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 3 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T4]()
		id, ok := storage.getComponent(name)
		q.Components[3] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 4 \"%s\" does not exist", name))
		}
	}
	return q
}

func Query5[T1 any, T2 any, T3 any, T4 any, T5 any, ID Int](storage *Storage[ID]) *Q5[ID, T1, T2, T3, T4, T5] {
	q := &Q5[ID, T1, T2, T3, T4, T5]{storage: storage}
	{
		name := typeName[T1]()
		id, ok := storage.getComponent(name)
		q.Components[0] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 1 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T2]()
		id, ok := storage.getComponent(name)
		q.Components[1] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 2 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T3]()
		id, ok := storage.getComponent(name)
		q.Components[2] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 3 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T4]()
		id, ok := storage.getComponent(name)
		q.Components[3] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 4 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T5]()
		id, ok := storage.getComponent(name)
		q.Components[4] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 5 \"%s\" does not exist", name))
		}
	}
	return q
}

func Query6[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, ID Int](storage *Storage[ID]) *Q6[ID, T1, T2, T3, T4, T5, T6] {
	q := &Q6[ID, T1, T2, T3, T4, T5, T6]{storage: storage}
	{
		name := typeName[T1]()
		id, ok := storage.getComponent(name)
		q.Components[0] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 1 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T2]()
		id, ok := storage.getComponent(name)
		q.Components[1] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 2 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T3]()
		id, ok := storage.getComponent(name)
		q.Components[2] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 3 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T4]()
		id, ok := storage.getComponent(name)
		q.Components[3] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 4 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T5]()
		id, ok := storage.getComponent(name)
		q.Components[4] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 5 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T6]()
		id, ok := storage.getComponent(name)
		q.Components[5] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 6 \"%s\" does not exist", name))
		}
	}
	return q
}

func Query7[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, ID Int](storage *Storage[ID]) *Q7[ID, T1, T2, T3, T4, T5, T6, T7] {
	q := &Q7[ID, T1, T2, T3, T4, T5, T6, T7]{storage: storage}
	{
		name := typeName[T1]()
		id, ok := storage.getComponent(name)
		q.Components[0] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 1 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T2]()
		id, ok := storage.getComponent(name)
		q.Components[1] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 2 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T3]()
		id, ok := storage.getComponent(name)
		q.Components[2] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 3 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T4]()
		id, ok := storage.getComponent(name)
		q.Components[3] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 4 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T5]()
		id, ok := storage.getComponent(name)
		q.Components[4] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 5 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T6]()
		id, ok := storage.getComponent(name)
		q.Components[5] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 6 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T7]()
		id, ok := storage.getComponent(name)
		q.Components[6] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 7 \"%s\" does not exist", name))
		}
	}
	return q
}

func Query8[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, ID Int](storage *Storage[ID]) *Q8[ID, T1, T2, T3, T4, T5, T6, T7, T8] {
	q := &Q8[ID, T1, T2, T3, T4, T5, T6, T7, T8]{storage: storage}
	{
		name := typeName[T1]()
		id, ok := storage.getComponent(name)
		q.Components[0] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 1 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T2]()
		id, ok := storage.getComponent(name)
		q.Components[1] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 2 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T3]()
		id, ok := storage.getComponent(name)
		q.Components[2] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 3 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T4]()
		id, ok := storage.getComponent(name)
		q.Components[3] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 4 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T5]()
		id, ok := storage.getComponent(name)
		q.Components[4] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 5 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T6]()
		id, ok := storage.getComponent(name)
		q.Components[5] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 6 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T7]()
		id, ok := storage.getComponent(name)
		q.Components[6] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 7 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T8]()
		id, ok := storage.getComponent(name)
		q.Components[7] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 8 \"%s\" does not exist", name))
		}
	}
	return q
}

func Query9[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, ID Int](storage *Storage[ID]) *Q9[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9] {
	q := &Q9[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9]{storage: storage}
	{
		name := typeName[T1]()
		id, ok := storage.getComponent(name)
		q.Components[0] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 1 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T2]()
		id, ok := storage.getComponent(name)
		q.Components[1] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 2 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T3]()
		id, ok := storage.getComponent(name)
		q.Components[2] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 3 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T4]()
		id, ok := storage.getComponent(name)
		q.Components[3] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 4 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T5]()
		id, ok := storage.getComponent(name)
		q.Components[4] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 5 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T6]()
		id, ok := storage.getComponent(name)
		q.Components[5] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 6 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T7]()
		id, ok := storage.getComponent(name)
		q.Components[6] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 7 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T8]()
		id, ok := storage.getComponent(name)
		q.Components[7] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 8 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T9]()
		id, ok := storage.getComponent(name)
		q.Components[8] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 9 \"%s\" does not exist", name))
		}
	}
	return q
}

func Query10[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, ID Int](storage *Storage[ID]) *Q10[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10] {
	q := &Q10[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]{storage: storage}
	{
		name := typeName[T1]()
		id, ok := storage.getComponent(name)
		q.Components[0] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 1 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T2]()
		id, ok := storage.getComponent(name)
		q.Components[1] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 2 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T3]()
		id, ok := storage.getComponent(name)
		q.Components[2] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 3 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T4]()
		id, ok := storage.getComponent(name)
		q.Components[3] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 4 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T5]()
		id, ok := storage.getComponent(name)
		q.Components[4] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 5 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T6]()
		id, ok := storage.getComponent(name)
		q.Components[5] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 6 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T7]()
		id, ok := storage.getComponent(name)
		q.Components[6] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 7 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T8]()
		id, ok := storage.getComponent(name)
		q.Components[7] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 8 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T9]()
		id, ok := storage.getComponent(name)
		q.Components[8] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 9 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T10]()
		id, ok := storage.getComponent(name)
		q.Components[9] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 10 \"%s\" does not exist", name))
		}
	}
	return q
}

func Query11[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, ID Int](storage *Storage[ID]) *Q11[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11] {
	q := &Q11[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11]{storage: storage}
	{
		name := typeName[T1]()
		id, ok := storage.getComponent(name)
		q.Components[0] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 1 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T2]()
		id, ok := storage.getComponent(name)
		q.Components[1] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 2 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T3]()
		id, ok := storage.getComponent(name)
		q.Components[2] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 3 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T4]()
		id, ok := storage.getComponent(name)
		q.Components[3] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 4 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T5]()
		id, ok := storage.getComponent(name)
		q.Components[4] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 5 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T6]()
		id, ok := storage.getComponent(name)
		q.Components[5] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 6 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T7]()
		id, ok := storage.getComponent(name)
		q.Components[6] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 7 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T8]()
		id, ok := storage.getComponent(name)
		q.Components[7] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 8 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T9]()
		id, ok := storage.getComponent(name)
		q.Components[8] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 9 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T10]()
		id, ok := storage.getComponent(name)
		q.Components[9] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 10 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T11]()
		id, ok := storage.getComponent(name)
		q.Components[10] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 11 \"%s\" does not exist", name))
		}
	}
	return q
}

func Query12[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, ID Int](storage *Storage[ID]) *Q12[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12] {
	q := &Q12[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12]{storage: storage}
	{
		name := typeName[T1]()
		id, ok := storage.getComponent(name)
		q.Components[0] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 1 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T2]()
		id, ok := storage.getComponent(name)
		q.Components[1] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 2 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T3]()
		id, ok := storage.getComponent(name)
		q.Components[2] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 3 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T4]()
		id, ok := storage.getComponent(name)
		q.Components[3] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 4 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T5]()
		id, ok := storage.getComponent(name)
		q.Components[4] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 5 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T6]()
		id, ok := storage.getComponent(name)
		q.Components[5] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 6 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T7]()
		id, ok := storage.getComponent(name)
		q.Components[6] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 7 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T8]()
		id, ok := storage.getComponent(name)
		q.Components[7] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 8 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T9]()
		id, ok := storage.getComponent(name)
		q.Components[8] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 9 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T10]()
		id, ok := storage.getComponent(name)
		q.Components[9] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 10 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T11]()
		id, ok := storage.getComponent(name)
		q.Components[10] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 11 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T12]()
		id, ok := storage.getComponent(name)
		q.Components[11] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 12 \"%s\" does not exist", name))
		}
	}
	return q
}

func Query13[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, ID Int](storage *Storage[ID]) *Q13[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13] {
	q := &Q13[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13]{storage: storage}
	{
		name := typeName[T1]()
		id, ok := storage.getComponent(name)
		q.Components[0] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 1 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T2]()
		id, ok := storage.getComponent(name)
		q.Components[1] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 2 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T3]()
		id, ok := storage.getComponent(name)
		q.Components[2] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 3 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T4]()
		id, ok := storage.getComponent(name)
		q.Components[3] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 4 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T5]()
		id, ok := storage.getComponent(name)
		q.Components[4] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 5 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T6]()
		id, ok := storage.getComponent(name)
		q.Components[5] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 6 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T7]()
		id, ok := storage.getComponent(name)
		q.Components[6] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 7 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T8]()
		id, ok := storage.getComponent(name)
		q.Components[7] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 8 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T9]()
		id, ok := storage.getComponent(name)
		q.Components[8] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 9 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T10]()
		id, ok := storage.getComponent(name)
		q.Components[9] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 10 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T11]()
		id, ok := storage.getComponent(name)
		q.Components[10] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 11 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T12]()
		id, ok := storage.getComponent(name)
		q.Components[11] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 12 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T13]()
		id, ok := storage.getComponent(name)
		q.Components[12] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 13 \"%s\" does not exist", name))
		}
	}
	return q
}

func Query14[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, ID Int](storage *Storage[ID]) *Q14[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14] {
	q := &Q14[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14]{storage: storage}
	{
		name := typeName[T1]()
		id, ok := storage.getComponent(name)
		q.Components[0] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 1 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T2]()
		id, ok := storage.getComponent(name)
		q.Components[1] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 2 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T3]()
		id, ok := storage.getComponent(name)
		q.Components[2] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 3 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T4]()
		id, ok := storage.getComponent(name)
		q.Components[3] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 4 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T5]()
		id, ok := storage.getComponent(name)
		q.Components[4] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 5 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T6]()
		id, ok := storage.getComponent(name)
		q.Components[5] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 6 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T7]()
		id, ok := storage.getComponent(name)
		q.Components[6] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 7 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T8]()
		id, ok := storage.getComponent(name)
		q.Components[7] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 8 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T9]()
		id, ok := storage.getComponent(name)
		q.Components[8] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 9 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T10]()
		id, ok := storage.getComponent(name)
		q.Components[9] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 10 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T11]()
		id, ok := storage.getComponent(name)
		q.Components[10] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 11 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T12]()
		id, ok := storage.getComponent(name)
		q.Components[11] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 12 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T13]()
		id, ok := storage.getComponent(name)
		q.Components[12] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 13 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T14]()
		id, ok := storage.getComponent(name)
		q.Components[13] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 14 \"%s\" does not exist", name))
		}
	}
	return q
}

func Query15[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, T15 any, ID Int](storage *Storage[ID]) *Q15[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15] {
	q := &Q15[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15]{storage: storage}
	{
		name := typeName[T1]()
		id, ok := storage.getComponent(name)
		q.Components[0] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 1 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T2]()
		id, ok := storage.getComponent(name)
		q.Components[1] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 2 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T3]()
		id, ok := storage.getComponent(name)
		q.Components[2] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 3 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T4]()
		id, ok := storage.getComponent(name)
		q.Components[3] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 4 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T5]()
		id, ok := storage.getComponent(name)
		q.Components[4] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 5 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T6]()
		id, ok := storage.getComponent(name)
		q.Components[5] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 6 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T7]()
		id, ok := storage.getComponent(name)
		q.Components[6] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 7 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T8]()
		id, ok := storage.getComponent(name)
		q.Components[7] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 8 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T9]()
		id, ok := storage.getComponent(name)
		q.Components[8] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 9 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T10]()
		id, ok := storage.getComponent(name)
		q.Components[9] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 10 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T11]()
		id, ok := storage.getComponent(name)
		q.Components[10] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 11 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T12]()
		id, ok := storage.getComponent(name)
		q.Components[11] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 12 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T13]()
		id, ok := storage.getComponent(name)
		q.Components[12] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 13 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T14]()
		id, ok := storage.getComponent(name)
		q.Components[13] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 14 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T15]()
		id, ok := storage.getComponent(name)
		q.Components[14] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 15 \"%s\" does not exist", name))
		}
	}
	return q
}

func Query16[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, T15 any, T16 any, ID Int](storage *Storage[ID]) *Q16[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16] {
	q := &Q16[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16]{storage: storage}
	{
		name := typeName[T1]()
		id, ok := storage.getComponent(name)
		q.Components[0] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 1 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T2]()
		id, ok := storage.getComponent(name)
		q.Components[1] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 2 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T3]()
		id, ok := storage.getComponent(name)
		q.Components[2] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 3 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T4]()
		id, ok := storage.getComponent(name)
		q.Components[3] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 4 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T5]()
		id, ok := storage.getComponent(name)
		q.Components[4] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 5 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T6]()
		id, ok := storage.getComponent(name)
		q.Components[5] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 6 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T7]()
		id, ok := storage.getComponent(name)
		q.Components[6] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 7 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T8]()
		id, ok := storage.getComponent(name)
		q.Components[7] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 8 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T9]()
		id, ok := storage.getComponent(name)
		q.Components[8] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 9 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T10]()
		id, ok := storage.getComponent(name)
		q.Components[9] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 10 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T11]()
		id, ok := storage.getComponent(name)
		q.Components[10] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 11 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T12]()
		id, ok := storage.getComponent(name)
		q.Components[11] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 12 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T13]()
		id, ok := storage.getComponent(name)
		q.Components[12] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 13 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T14]()
		id, ok := storage.getComponent(name)
		q.Components[13] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 14 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T15]()
		id, ok := storage.getComponent(name)
		q.Components[14] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 15 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T16]()
		id, ok := storage.getComponent(name)
		q.Components[15] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 16 \"%s\" does not exist", name))
		}
	}
	return q
}

func Query17[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, T15 any, T16 any, T17 any, ID Int](storage *Storage[ID]) *Q17[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17] {
	q := &Q17[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17]{storage: storage}
	{
		name := typeName[T1]()
		id, ok := storage.getComponent(name)
		q.Components[0] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 1 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T2]()
		id, ok := storage.getComponent(name)
		q.Components[1] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 2 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T3]()
		id, ok := storage.getComponent(name)
		q.Components[2] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 3 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T4]()
		id, ok := storage.getComponent(name)
		q.Components[3] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 4 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T5]()
		id, ok := storage.getComponent(name)
		q.Components[4] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 5 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T6]()
		id, ok := storage.getComponent(name)
		q.Components[5] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 6 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T7]()
		id, ok := storage.getComponent(name)
		q.Components[6] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 7 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T8]()
		id, ok := storage.getComponent(name)
		q.Components[7] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 8 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T9]()
		id, ok := storage.getComponent(name)
		q.Components[8] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 9 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T10]()
		id, ok := storage.getComponent(name)
		q.Components[9] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 10 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T11]()
		id, ok := storage.getComponent(name)
		q.Components[10] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 11 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T12]()
		id, ok := storage.getComponent(name)
		q.Components[11] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 12 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T13]()
		id, ok := storage.getComponent(name)
		q.Components[12] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 13 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T14]()
		id, ok := storage.getComponent(name)
		q.Components[13] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 14 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T15]()
		id, ok := storage.getComponent(name)
		q.Components[14] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 15 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T16]()
		id, ok := storage.getComponent(name)
		q.Components[15] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 16 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T17]()
		id, ok := storage.getComponent(name)
		q.Components[16] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 17 \"%s\" does not exist", name))
		}
	}
	return q
}

func Query18[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, T15 any, T16 any, T17 any, T18 any, ID Int](storage *Storage[ID]) *Q18[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18] {
	q := &Q18[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18]{storage: storage}
	{
		name := typeName[T1]()
		id, ok := storage.getComponent(name)
		q.Components[0] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 1 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T2]()
		id, ok := storage.getComponent(name)
		q.Components[1] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 2 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T3]()
		id, ok := storage.getComponent(name)
		q.Components[2] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 3 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T4]()
		id, ok := storage.getComponent(name)
		q.Components[3] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 4 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T5]()
		id, ok := storage.getComponent(name)
		q.Components[4] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 5 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T6]()
		id, ok := storage.getComponent(name)
		q.Components[5] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 6 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T7]()
		id, ok := storage.getComponent(name)
		q.Components[6] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 7 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T8]()
		id, ok := storage.getComponent(name)
		q.Components[7] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 8 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T9]()
		id, ok := storage.getComponent(name)
		q.Components[8] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 9 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T10]()
		id, ok := storage.getComponent(name)
		q.Components[9] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 10 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T11]()
		id, ok := storage.getComponent(name)
		q.Components[10] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 11 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T12]()
		id, ok := storage.getComponent(name)
		q.Components[11] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 12 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T13]()
		id, ok := storage.getComponent(name)
		q.Components[12] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 13 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T14]()
		id, ok := storage.getComponent(name)
		q.Components[13] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 14 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T15]()
		id, ok := storage.getComponent(name)
		q.Components[14] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 15 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T16]()
		id, ok := storage.getComponent(name)
		q.Components[15] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 16 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T17]()
		id, ok := storage.getComponent(name)
		q.Components[16] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 17 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T18]()
		id, ok := storage.getComponent(name)
		q.Components[17] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 18 \"%s\" does not exist", name))
		}
	}
	return q
}

func Query19[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, T15 any, T16 any, T17 any, T18 any, T19 any, ID Int](storage *Storage[ID]) *Q19[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19] {
	q := &Q19[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19]{storage: storage}
	{
		name := typeName[T1]()
		id, ok := storage.getComponent(name)
		q.Components[0] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 1 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T2]()
		id, ok := storage.getComponent(name)
		q.Components[1] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 2 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T3]()
		id, ok := storage.getComponent(name)
		q.Components[2] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 3 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T4]()
		id, ok := storage.getComponent(name)
		q.Components[3] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 4 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T5]()
		id, ok := storage.getComponent(name)
		q.Components[4] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 5 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T6]()
		id, ok := storage.getComponent(name)
		q.Components[5] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 6 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T7]()
		id, ok := storage.getComponent(name)
		q.Components[6] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 7 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T8]()
		id, ok := storage.getComponent(name)
		q.Components[7] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 8 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T9]()
		id, ok := storage.getComponent(name)
		q.Components[8] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 9 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T10]()
		id, ok := storage.getComponent(name)
		q.Components[9] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 10 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T11]()
		id, ok := storage.getComponent(name)
		q.Components[10] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 11 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T12]()
		id, ok := storage.getComponent(name)
		q.Components[11] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 12 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T13]()
		id, ok := storage.getComponent(name)
		q.Components[12] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 13 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T14]()
		id, ok := storage.getComponent(name)
		q.Components[13] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 14 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T15]()
		id, ok := storage.getComponent(name)
		q.Components[14] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 15 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T16]()
		id, ok := storage.getComponent(name)
		q.Components[15] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 16 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T17]()
		id, ok := storage.getComponent(name)
		q.Components[16] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 17 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T18]()
		id, ok := storage.getComponent(name)
		q.Components[17] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 18 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T19]()
		id, ok := storage.getComponent(name)
		q.Components[18] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 19 \"%s\" does not exist", name))
		}
	}
	return q
}

func Query20[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, T15 any, T16 any, T17 any, T18 any, T19 any, T20 any, ID Int](storage *Storage[ID]) *Q20[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20] {
	q := &Q20[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20]{storage: storage}
	{
		name := typeName[T1]()
		id, ok := storage.getComponent(name)
		q.Components[0] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 1 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T2]()
		id, ok := storage.getComponent(name)
		q.Components[1] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 2 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T3]()
		id, ok := storage.getComponent(name)
		q.Components[2] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 3 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T4]()
		id, ok := storage.getComponent(name)
		q.Components[3] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 4 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T5]()
		id, ok := storage.getComponent(name)
		q.Components[4] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 5 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T6]()
		id, ok := storage.getComponent(name)
		q.Components[5] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 6 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T7]()
		id, ok := storage.getComponent(name)
		q.Components[6] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 7 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T8]()
		id, ok := storage.getComponent(name)
		q.Components[7] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 8 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T9]()
		id, ok := storage.getComponent(name)
		q.Components[8] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 9 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T10]()
		id, ok := storage.getComponent(name)
		q.Components[9] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 10 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T11]()
		id, ok := storage.getComponent(name)
		q.Components[10] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 11 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T12]()
		id, ok := storage.getComponent(name)
		q.Components[11] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 12 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T13]()
		id, ok := storage.getComponent(name)
		q.Components[12] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 13 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T14]()
		id, ok := storage.getComponent(name)
		q.Components[13] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 14 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T15]()
		id, ok := storage.getComponent(name)
		q.Components[14] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 15 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T16]()
		id, ok := storage.getComponent(name)
		q.Components[15] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 16 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T17]()
		id, ok := storage.getComponent(name)
		q.Components[16] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 17 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T18]()
		id, ok := storage.getComponent(name)
		q.Components[17] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 18 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T19]()
		id, ok := storage.getComponent(name)
		q.Components[18] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 19 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T20]()
		id, ok := storage.getComponent(name)
		q.Components[19] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 20 \"%s\" does not exist", name))
		}
	}
	return q
}

func (q *Q1[ID, T1]) Each(fn func(ID, *T1), queryOptions ...Q1Option) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q1Option
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
	for compoundIdx, compound := range q.storage.Compounds {
		if options.Hash != nil {
			if i, ok := sliceFind(compound.Components, options.Hash.ID); ok {
				if compound.Hashes[i] != options.Hash.Hash {
					continue
				}
			} else {
				continue
			}
		}
		componentMax := len(compound.Values) - 1
		var v1s []T1
		if q.Components[0] > componentMax || compound.Values[q.Components[0]] == nil {
			if !options.Optional[0] {
				continue
			}
		} else {
			v1s = compound.Values[q.Components[0]].([]T1)
		}
		// If it has removed items, also flush them
		if compound.Removed != nil {
			count := len(compound.Removed)
			if len(compound.IDs) == count { // Compound is empty, throw away
				q.storage.Compounds = sliceRemove(q.storage.Compounds, compoundIdx)
				continue
			}
			idxRemove := make([]int, count)
			skip, skipped := compound.Removed[0], 0
			for idx, id := range compound.IDs {
				if id == skip {
					idxRemove[skipped] = idx
					if skipped < count-1 {
						skipped++
						skip = compound.Removed[skipped]
					}
					continue
				}

				fn(id, getOptional(v1s, idx))
				if *options.Stop {
					return
				}
			}
			// Remove items and flush
			for i := len(idxRemove) - 1; i >= 0; i-- {
				compound.IDs = sliceRemove(compound.IDs, idxRemove[i])
				v1s = sliceRemove(v1s, idxRemove[i])
			}
			compound.Values[q.Components[0]] = v1s

			compound.Removed = nil
			continue
		}
		// Normal loop
		for idx, id := range compound.IDs {
			fn(id, getOptional(v1s, idx))
			if *options.Stop {
				return
			}
		}
	}
}

func (q *Q2[ID, T1, T2]) Each(fn func(ID, *T1, *T2), queryOptions ...Q2Option) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q2Option
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
	for compoundIdx, compound := range q.storage.Compounds {
		if options.Hash != nil {
			if i, ok := sliceFind(compound.Components, options.Hash.ID); ok {
				if compound.Hashes[i] != options.Hash.Hash {
					continue
				}
			} else {
				continue
			}
		}
		componentMax := len(compound.Values) - 1
		var v1s []T1
		if q.Components[0] > componentMax || compound.Values[q.Components[0]] == nil {
			if !options.Optional[0] {
				continue
			}
		} else {
			v1s = compound.Values[q.Components[0]].([]T1)
		}
		var v2s []T2
		if q.Components[1] > componentMax || compound.Values[q.Components[1]] == nil {
			if !options.Optional[1] {
				continue
			}
		} else {
			v2s = compound.Values[q.Components[1]].([]T2)
		}
		// If it has removed items, also flush them
		if compound.Removed != nil {
			count := len(compound.Removed)
			if len(compound.IDs) == count { // Compound is empty, throw away
				q.storage.Compounds = sliceRemove(q.storage.Compounds, compoundIdx)
				continue
			}
			idxRemove := make([]int, count)
			skip, skipped := compound.Removed[0], 0
			for idx, id := range compound.IDs {
				if id == skip {
					idxRemove[skipped] = idx
					if skipped < count-1 {
						skipped++
						skip = compound.Removed[skipped]
					}
					continue
				}

				fn(id, getOptional(v1s, idx), getOptional(v2s, idx))
				if *options.Stop {
					return
				}
			}
			// Remove items and flush
			for i := len(idxRemove) - 1; i >= 0; i-- {
				compound.IDs = sliceRemove(compound.IDs, idxRemove[i])
				v1s = sliceRemove(v1s, idxRemove[i])
				v2s = sliceRemove(v2s, idxRemove[i])
			}
			compound.Values[q.Components[0]] = v1s
			compound.Values[q.Components[1]] = v2s

			compound.Removed = nil
			continue
		}
		// Normal loop
		for idx, id := range compound.IDs {
			fn(id, getOptional(v1s, idx), getOptional(v2s, idx))
			if *options.Stop {
				return
			}
		}
	}
}

func (q *Q3[ID, T1, T2, T3]) Each(fn func(ID, *T1, *T2, *T3), queryOptions ...Q3Option) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q3Option
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
	for compoundIdx, compound := range q.storage.Compounds {
		if options.Hash != nil {
			if i, ok := sliceFind(compound.Components, options.Hash.ID); ok {
				if compound.Hashes[i] != options.Hash.Hash {
					continue
				}
			} else {
				continue
			}
		}
		componentMax := len(compound.Values) - 1
		var v1s []T1
		if q.Components[0] > componentMax || compound.Values[q.Components[0]] == nil {
			if !options.Optional[0] {
				continue
			}
		} else {
			v1s = compound.Values[q.Components[0]].([]T1)
		}
		var v2s []T2
		if q.Components[1] > componentMax || compound.Values[q.Components[1]] == nil {
			if !options.Optional[1] {
				continue
			}
		} else {
			v2s = compound.Values[q.Components[1]].([]T2)
		}
		var v3s []T3
		if q.Components[2] > componentMax || compound.Values[q.Components[2]] == nil {
			if !options.Optional[2] {
				continue
			}
		} else {
			v3s = compound.Values[q.Components[2]].([]T3)
		}
		// If it has removed items, also flush them
		if compound.Removed != nil {
			count := len(compound.Removed)
			if len(compound.IDs) == count { // Compound is empty, throw away
				q.storage.Compounds = sliceRemove(q.storage.Compounds, compoundIdx)
				continue
			}
			idxRemove := make([]int, count)
			skip, skipped := compound.Removed[0], 0
			for idx, id := range compound.IDs {
				if id == skip {
					idxRemove[skipped] = idx
					if skipped < count-1 {
						skipped++
						skip = compound.Removed[skipped]
					}
					continue
				}

				fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx))
				if *options.Stop {
					return
				}
			}
			// Remove items and flush
			for i := len(idxRemove) - 1; i >= 0; i-- {
				compound.IDs = sliceRemove(compound.IDs, idxRemove[i])
				v1s = sliceRemove(v1s, idxRemove[i])
				v2s = sliceRemove(v2s, idxRemove[i])
				v3s = sliceRemove(v3s, idxRemove[i])
			}
			compound.Values[q.Components[0]] = v1s
			compound.Values[q.Components[1]] = v2s
			compound.Values[q.Components[2]] = v3s

			compound.Removed = nil
			continue
		}
		// Normal loop
		for idx, id := range compound.IDs {
			fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx))
			if *options.Stop {
				return
			}
		}
	}
}

func (q *Q4[ID, T1, T2, T3, T4]) Each(fn func(ID, *T1, *T2, *T3, *T4), queryOptions ...Q4Option) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q4Option
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
	for compoundIdx, compound := range q.storage.Compounds {
		if options.Hash != nil {
			if i, ok := sliceFind(compound.Components, options.Hash.ID); ok {
				if compound.Hashes[i] != options.Hash.Hash {
					continue
				}
			} else {
				continue
			}
		}
		componentMax := len(compound.Values) - 1
		var v1s []T1
		if q.Components[0] > componentMax || compound.Values[q.Components[0]] == nil {
			if !options.Optional[0] {
				continue
			}
		} else {
			v1s = compound.Values[q.Components[0]].([]T1)
		}
		var v2s []T2
		if q.Components[1] > componentMax || compound.Values[q.Components[1]] == nil {
			if !options.Optional[1] {
				continue
			}
		} else {
			v2s = compound.Values[q.Components[1]].([]T2)
		}
		var v3s []T3
		if q.Components[2] > componentMax || compound.Values[q.Components[2]] == nil {
			if !options.Optional[2] {
				continue
			}
		} else {
			v3s = compound.Values[q.Components[2]].([]T3)
		}
		var v4s []T4
		if q.Components[3] > componentMax || compound.Values[q.Components[3]] == nil {
			if !options.Optional[3] {
				continue
			}
		} else {
			v4s = compound.Values[q.Components[3]].([]T4)
		}
		// If it has removed items, also flush them
		if compound.Removed != nil {
			count := len(compound.Removed)
			if len(compound.IDs) == count { // Compound is empty, throw away
				q.storage.Compounds = sliceRemove(q.storage.Compounds, compoundIdx)
				continue
			}
			idxRemove := make([]int, count)
			skip, skipped := compound.Removed[0], 0
			for idx, id := range compound.IDs {
				if id == skip {
					idxRemove[skipped] = idx
					if skipped < count-1 {
						skipped++
						skip = compound.Removed[skipped]
					}
					continue
				}

				fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx))
				if *options.Stop {
					return
				}
			}
			// Remove items and flush
			for i := len(idxRemove) - 1; i >= 0; i-- {
				compound.IDs = sliceRemove(compound.IDs, idxRemove[i])
				v1s = sliceRemove(v1s, idxRemove[i])
				v2s = sliceRemove(v2s, idxRemove[i])
				v3s = sliceRemove(v3s, idxRemove[i])
				v4s = sliceRemove(v4s, idxRemove[i])
			}
			compound.Values[q.Components[0]] = v1s
			compound.Values[q.Components[1]] = v2s
			compound.Values[q.Components[2]] = v3s
			compound.Values[q.Components[3]] = v4s

			compound.Removed = nil
			continue
		}
		// Normal loop
		for idx, id := range compound.IDs {
			fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx))
			if *options.Stop {
				return
			}
		}
	}
}

func (q *Q5[ID, T1, T2, T3, T4, T5]) Each(fn func(ID, *T1, *T2, *T3, *T4, *T5), queryOptions ...Q5Option) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q5Option
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
	for compoundIdx, compound := range q.storage.Compounds {
		if options.Hash != nil {
			if i, ok := sliceFind(compound.Components, options.Hash.ID); ok {
				if compound.Hashes[i] != options.Hash.Hash {
					continue
				}
			} else {
				continue
			}
		}
		componentMax := len(compound.Values) - 1
		var v1s []T1
		if q.Components[0] > componentMax || compound.Values[q.Components[0]] == nil {
			if !options.Optional[0] {
				continue
			}
		} else {
			v1s = compound.Values[q.Components[0]].([]T1)
		}
		var v2s []T2
		if q.Components[1] > componentMax || compound.Values[q.Components[1]] == nil {
			if !options.Optional[1] {
				continue
			}
		} else {
			v2s = compound.Values[q.Components[1]].([]T2)
		}
		var v3s []T3
		if q.Components[2] > componentMax || compound.Values[q.Components[2]] == nil {
			if !options.Optional[2] {
				continue
			}
		} else {
			v3s = compound.Values[q.Components[2]].([]T3)
		}
		var v4s []T4
		if q.Components[3] > componentMax || compound.Values[q.Components[3]] == nil {
			if !options.Optional[3] {
				continue
			}
		} else {
			v4s = compound.Values[q.Components[3]].([]T4)
		}
		var v5s []T5
		if q.Components[4] > componentMax || compound.Values[q.Components[4]] == nil {
			if !options.Optional[4] {
				continue
			}
		} else {
			v5s = compound.Values[q.Components[4]].([]T5)
		}
		// If it has removed items, also flush them
		if compound.Removed != nil {
			count := len(compound.Removed)
			if len(compound.IDs) == count { // Compound is empty, throw away
				q.storage.Compounds = sliceRemove(q.storage.Compounds, compoundIdx)
				continue
			}
			idxRemove := make([]int, count)
			skip, skipped := compound.Removed[0], 0
			for idx, id := range compound.IDs {
				if id == skip {
					idxRemove[skipped] = idx
					if skipped < count-1 {
						skipped++
						skip = compound.Removed[skipped]
					}
					continue
				}

				fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx))
				if *options.Stop {
					return
				}
			}
			// Remove items and flush
			for i := len(idxRemove) - 1; i >= 0; i-- {
				compound.IDs = sliceRemove(compound.IDs, idxRemove[i])
				v1s = sliceRemove(v1s, idxRemove[i])
				v2s = sliceRemove(v2s, idxRemove[i])
				v3s = sliceRemove(v3s, idxRemove[i])
				v4s = sliceRemove(v4s, idxRemove[i])
				v5s = sliceRemove(v5s, idxRemove[i])
			}
			compound.Values[q.Components[0]] = v1s
			compound.Values[q.Components[1]] = v2s
			compound.Values[q.Components[2]] = v3s
			compound.Values[q.Components[3]] = v4s
			compound.Values[q.Components[4]] = v5s

			compound.Removed = nil
			continue
		}
		// Normal loop
		for idx, id := range compound.IDs {
			fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx))
			if *options.Stop {
				return
			}
		}
	}
}

func (q *Q6[ID, T1, T2, T3, T4, T5, T6]) Each(fn func(ID, *T1, *T2, *T3, *T4, *T5, *T6), queryOptions ...Q6Option) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q6Option
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
	for compoundIdx, compound := range q.storage.Compounds {
		if options.Hash != nil {
			if i, ok := sliceFind(compound.Components, options.Hash.ID); ok {
				if compound.Hashes[i] != options.Hash.Hash {
					continue
				}
			} else {
				continue
			}
		}
		componentMax := len(compound.Values) - 1
		var v1s []T1
		if q.Components[0] > componentMax || compound.Values[q.Components[0]] == nil {
			if !options.Optional[0] {
				continue
			}
		} else {
			v1s = compound.Values[q.Components[0]].([]T1)
		}
		var v2s []T2
		if q.Components[1] > componentMax || compound.Values[q.Components[1]] == nil {
			if !options.Optional[1] {
				continue
			}
		} else {
			v2s = compound.Values[q.Components[1]].([]T2)
		}
		var v3s []T3
		if q.Components[2] > componentMax || compound.Values[q.Components[2]] == nil {
			if !options.Optional[2] {
				continue
			}
		} else {
			v3s = compound.Values[q.Components[2]].([]T3)
		}
		var v4s []T4
		if q.Components[3] > componentMax || compound.Values[q.Components[3]] == nil {
			if !options.Optional[3] {
				continue
			}
		} else {
			v4s = compound.Values[q.Components[3]].([]T4)
		}
		var v5s []T5
		if q.Components[4] > componentMax || compound.Values[q.Components[4]] == nil {
			if !options.Optional[4] {
				continue
			}
		} else {
			v5s = compound.Values[q.Components[4]].([]T5)
		}
		var v6s []T6
		if q.Components[5] > componentMax || compound.Values[q.Components[5]] == nil {
			if !options.Optional[5] {
				continue
			}
		} else {
			v6s = compound.Values[q.Components[5]].([]T6)
		}
		// If it has removed items, also flush them
		if compound.Removed != nil {
			count := len(compound.Removed)
			if len(compound.IDs) == count { // Compound is empty, throw away
				q.storage.Compounds = sliceRemove(q.storage.Compounds, compoundIdx)
				continue
			}
			idxRemove := make([]int, count)
			skip, skipped := compound.Removed[0], 0
			for idx, id := range compound.IDs {
				if id == skip {
					idxRemove[skipped] = idx
					if skipped < count-1 {
						skipped++
						skip = compound.Removed[skipped]
					}
					continue
				}

				fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx))
				if *options.Stop {
					return
				}
			}
			// Remove items and flush
			for i := len(idxRemove) - 1; i >= 0; i-- {
				compound.IDs = sliceRemove(compound.IDs, idxRemove[i])
				v1s = sliceRemove(v1s, idxRemove[i])
				v2s = sliceRemove(v2s, idxRemove[i])
				v3s = sliceRemove(v3s, idxRemove[i])
				v4s = sliceRemove(v4s, idxRemove[i])
				v5s = sliceRemove(v5s, idxRemove[i])
				v6s = sliceRemove(v6s, idxRemove[i])
			}
			compound.Values[q.Components[0]] = v1s
			compound.Values[q.Components[1]] = v2s
			compound.Values[q.Components[2]] = v3s
			compound.Values[q.Components[3]] = v4s
			compound.Values[q.Components[4]] = v5s
			compound.Values[q.Components[5]] = v6s

			compound.Removed = nil
			continue
		}
		// Normal loop
		for idx, id := range compound.IDs {
			fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx))
			if *options.Stop {
				return
			}
		}
	}
}

func (q *Q7[ID, T1, T2, T3, T4, T5, T6, T7]) Each(fn func(ID, *T1, *T2, *T3, *T4, *T5, *T6, *T7), queryOptions ...Q7Option) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q7Option
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
	for compoundIdx, compound := range q.storage.Compounds {
		if options.Hash != nil {
			if i, ok := sliceFind(compound.Components, options.Hash.ID); ok {
				if compound.Hashes[i] != options.Hash.Hash {
					continue
				}
			} else {
				continue
			}
		}
		componentMax := len(compound.Values) - 1
		var v1s []T1
		if q.Components[0] > componentMax || compound.Values[q.Components[0]] == nil {
			if !options.Optional[0] {
				continue
			}
		} else {
			v1s = compound.Values[q.Components[0]].([]T1)
		}
		var v2s []T2
		if q.Components[1] > componentMax || compound.Values[q.Components[1]] == nil {
			if !options.Optional[1] {
				continue
			}
		} else {
			v2s = compound.Values[q.Components[1]].([]T2)
		}
		var v3s []T3
		if q.Components[2] > componentMax || compound.Values[q.Components[2]] == nil {
			if !options.Optional[2] {
				continue
			}
		} else {
			v3s = compound.Values[q.Components[2]].([]T3)
		}
		var v4s []T4
		if q.Components[3] > componentMax || compound.Values[q.Components[3]] == nil {
			if !options.Optional[3] {
				continue
			}
		} else {
			v4s = compound.Values[q.Components[3]].([]T4)
		}
		var v5s []T5
		if q.Components[4] > componentMax || compound.Values[q.Components[4]] == nil {
			if !options.Optional[4] {
				continue
			}
		} else {
			v5s = compound.Values[q.Components[4]].([]T5)
		}
		var v6s []T6
		if q.Components[5] > componentMax || compound.Values[q.Components[5]] == nil {
			if !options.Optional[5] {
				continue
			}
		} else {
			v6s = compound.Values[q.Components[5]].([]T6)
		}
		var v7s []T7
		if q.Components[6] > componentMax || compound.Values[q.Components[6]] == nil {
			if !options.Optional[6] {
				continue
			}
		} else {
			v7s = compound.Values[q.Components[6]].([]T7)
		}
		// If it has removed items, also flush them
		if compound.Removed != nil {
			count := len(compound.Removed)
			if len(compound.IDs) == count { // Compound is empty, throw away
				q.storage.Compounds = sliceRemove(q.storage.Compounds, compoundIdx)
				continue
			}
			idxRemove := make([]int, count)
			skip, skipped := compound.Removed[0], 0
			for idx, id := range compound.IDs {
				if id == skip {
					idxRemove[skipped] = idx
					if skipped < count-1 {
						skipped++
						skip = compound.Removed[skipped]
					}
					continue
				}

				fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx))
				if *options.Stop {
					return
				}
			}
			// Remove items and flush
			for i := len(idxRemove) - 1; i >= 0; i-- {
				compound.IDs = sliceRemove(compound.IDs, idxRemove[i])
				v1s = sliceRemove(v1s, idxRemove[i])
				v2s = sliceRemove(v2s, idxRemove[i])
				v3s = sliceRemove(v3s, idxRemove[i])
				v4s = sliceRemove(v4s, idxRemove[i])
				v5s = sliceRemove(v5s, idxRemove[i])
				v6s = sliceRemove(v6s, idxRemove[i])
				v7s = sliceRemove(v7s, idxRemove[i])
			}
			compound.Values[q.Components[0]] = v1s
			compound.Values[q.Components[1]] = v2s
			compound.Values[q.Components[2]] = v3s
			compound.Values[q.Components[3]] = v4s
			compound.Values[q.Components[4]] = v5s
			compound.Values[q.Components[5]] = v6s
			compound.Values[q.Components[6]] = v7s

			compound.Removed = nil
			continue
		}
		// Normal loop
		for idx, id := range compound.IDs {
			fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx))
			if *options.Stop {
				return
			}
		}
	}
}

func (q *Q8[ID, T1, T2, T3, T4, T5, T6, T7, T8]) Each(fn func(ID, *T1, *T2, *T3, *T4, *T5, *T6, *T7, *T8), queryOptions ...Q8Option) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q8Option
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
	for compoundIdx, compound := range q.storage.Compounds {
		if options.Hash != nil {
			if i, ok := sliceFind(compound.Components, options.Hash.ID); ok {
				if compound.Hashes[i] != options.Hash.Hash {
					continue
				}
			} else {
				continue
			}
		}
		componentMax := len(compound.Values) - 1
		var v1s []T1
		if q.Components[0] > componentMax || compound.Values[q.Components[0]] == nil {
			if !options.Optional[0] {
				continue
			}
		} else {
			v1s = compound.Values[q.Components[0]].([]T1)
		}
		var v2s []T2
		if q.Components[1] > componentMax || compound.Values[q.Components[1]] == nil {
			if !options.Optional[1] {
				continue
			}
		} else {
			v2s = compound.Values[q.Components[1]].([]T2)
		}
		var v3s []T3
		if q.Components[2] > componentMax || compound.Values[q.Components[2]] == nil {
			if !options.Optional[2] {
				continue
			}
		} else {
			v3s = compound.Values[q.Components[2]].([]T3)
		}
		var v4s []T4
		if q.Components[3] > componentMax || compound.Values[q.Components[3]] == nil {
			if !options.Optional[3] {
				continue
			}
		} else {
			v4s = compound.Values[q.Components[3]].([]T4)
		}
		var v5s []T5
		if q.Components[4] > componentMax || compound.Values[q.Components[4]] == nil {
			if !options.Optional[4] {
				continue
			}
		} else {
			v5s = compound.Values[q.Components[4]].([]T5)
		}
		var v6s []T6
		if q.Components[5] > componentMax || compound.Values[q.Components[5]] == nil {
			if !options.Optional[5] {
				continue
			}
		} else {
			v6s = compound.Values[q.Components[5]].([]T6)
		}
		var v7s []T7
		if q.Components[6] > componentMax || compound.Values[q.Components[6]] == nil {
			if !options.Optional[6] {
				continue
			}
		} else {
			v7s = compound.Values[q.Components[6]].([]T7)
		}
		var v8s []T8
		if q.Components[7] > componentMax || compound.Values[q.Components[7]] == nil {
			if !options.Optional[7] {
				continue
			}
		} else {
			v8s = compound.Values[q.Components[7]].([]T8)
		}
		// If it has removed items, also flush them
		if compound.Removed != nil {
			count := len(compound.Removed)
			if len(compound.IDs) == count { // Compound is empty, throw away
				q.storage.Compounds = sliceRemove(q.storage.Compounds, compoundIdx)
				continue
			}
			idxRemove := make([]int, count)
			skip, skipped := compound.Removed[0], 0
			for idx, id := range compound.IDs {
				if id == skip {
					idxRemove[skipped] = idx
					if skipped < count-1 {
						skipped++
						skip = compound.Removed[skipped]
					}
					continue
				}

				fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx))
				if *options.Stop {
					return
				}
			}
			// Remove items and flush
			for i := len(idxRemove) - 1; i >= 0; i-- {
				compound.IDs = sliceRemove(compound.IDs, idxRemove[i])
				v1s = sliceRemove(v1s, idxRemove[i])
				v2s = sliceRemove(v2s, idxRemove[i])
				v3s = sliceRemove(v3s, idxRemove[i])
				v4s = sliceRemove(v4s, idxRemove[i])
				v5s = sliceRemove(v5s, idxRemove[i])
				v6s = sliceRemove(v6s, idxRemove[i])
				v7s = sliceRemove(v7s, idxRemove[i])
				v8s = sliceRemove(v8s, idxRemove[i])
			}
			compound.Values[q.Components[0]] = v1s
			compound.Values[q.Components[1]] = v2s
			compound.Values[q.Components[2]] = v3s
			compound.Values[q.Components[3]] = v4s
			compound.Values[q.Components[4]] = v5s
			compound.Values[q.Components[5]] = v6s
			compound.Values[q.Components[6]] = v7s
			compound.Values[q.Components[7]] = v8s

			compound.Removed = nil
			continue
		}
		// Normal loop
		for idx, id := range compound.IDs {
			fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx))
			if *options.Stop {
				return
			}
		}
	}
}

func (q *Q9[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9]) Each(fn func(ID, *T1, *T2, *T3, *T4, *T5, *T6, *T7, *T8, *T9), queryOptions ...Q9Option) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q9Option
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
	for compoundIdx, compound := range q.storage.Compounds {
		if options.Hash != nil {
			if i, ok := sliceFind(compound.Components, options.Hash.ID); ok {
				if compound.Hashes[i] != options.Hash.Hash {
					continue
				}
			} else {
				continue
			}
		}
		componentMax := len(compound.Values) - 1
		var v1s []T1
		if q.Components[0] > componentMax || compound.Values[q.Components[0]] == nil {
			if !options.Optional[0] {
				continue
			}
		} else {
			v1s = compound.Values[q.Components[0]].([]T1)
		}
		var v2s []T2
		if q.Components[1] > componentMax || compound.Values[q.Components[1]] == nil {
			if !options.Optional[1] {
				continue
			}
		} else {
			v2s = compound.Values[q.Components[1]].([]T2)
		}
		var v3s []T3
		if q.Components[2] > componentMax || compound.Values[q.Components[2]] == nil {
			if !options.Optional[2] {
				continue
			}
		} else {
			v3s = compound.Values[q.Components[2]].([]T3)
		}
		var v4s []T4
		if q.Components[3] > componentMax || compound.Values[q.Components[3]] == nil {
			if !options.Optional[3] {
				continue
			}
		} else {
			v4s = compound.Values[q.Components[3]].([]T4)
		}
		var v5s []T5
		if q.Components[4] > componentMax || compound.Values[q.Components[4]] == nil {
			if !options.Optional[4] {
				continue
			}
		} else {
			v5s = compound.Values[q.Components[4]].([]T5)
		}
		var v6s []T6
		if q.Components[5] > componentMax || compound.Values[q.Components[5]] == nil {
			if !options.Optional[5] {
				continue
			}
		} else {
			v6s = compound.Values[q.Components[5]].([]T6)
		}
		var v7s []T7
		if q.Components[6] > componentMax || compound.Values[q.Components[6]] == nil {
			if !options.Optional[6] {
				continue
			}
		} else {
			v7s = compound.Values[q.Components[6]].([]T7)
		}
		var v8s []T8
		if q.Components[7] > componentMax || compound.Values[q.Components[7]] == nil {
			if !options.Optional[7] {
				continue
			}
		} else {
			v8s = compound.Values[q.Components[7]].([]T8)
		}
		var v9s []T9
		if q.Components[8] > componentMax || compound.Values[q.Components[8]] == nil {
			if !options.Optional[8] {
				continue
			}
		} else {
			v9s = compound.Values[q.Components[8]].([]T9)
		}
		// If it has removed items, also flush them
		if compound.Removed != nil {
			count := len(compound.Removed)
			if len(compound.IDs) == count { // Compound is empty, throw away
				q.storage.Compounds = sliceRemove(q.storage.Compounds, compoundIdx)
				continue
			}
			idxRemove := make([]int, count)
			skip, skipped := compound.Removed[0], 0
			for idx, id := range compound.IDs {
				if id == skip {
					idxRemove[skipped] = idx
					if skipped < count-1 {
						skipped++
						skip = compound.Removed[skipped]
					}
					continue
				}

				fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx))
				if *options.Stop {
					return
				}
			}
			// Remove items and flush
			for i := len(idxRemove) - 1; i >= 0; i-- {
				compound.IDs = sliceRemove(compound.IDs, idxRemove[i])
				v1s = sliceRemove(v1s, idxRemove[i])
				v2s = sliceRemove(v2s, idxRemove[i])
				v3s = sliceRemove(v3s, idxRemove[i])
				v4s = sliceRemove(v4s, idxRemove[i])
				v5s = sliceRemove(v5s, idxRemove[i])
				v6s = sliceRemove(v6s, idxRemove[i])
				v7s = sliceRemove(v7s, idxRemove[i])
				v8s = sliceRemove(v8s, idxRemove[i])
				v9s = sliceRemove(v9s, idxRemove[i])
			}
			compound.Values[q.Components[0]] = v1s
			compound.Values[q.Components[1]] = v2s
			compound.Values[q.Components[2]] = v3s
			compound.Values[q.Components[3]] = v4s
			compound.Values[q.Components[4]] = v5s
			compound.Values[q.Components[5]] = v6s
			compound.Values[q.Components[6]] = v7s
			compound.Values[q.Components[7]] = v8s
			compound.Values[q.Components[8]] = v9s

			compound.Removed = nil
			continue
		}
		// Normal loop
		for idx, id := range compound.IDs {
			fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx))
			if *options.Stop {
				return
			}
		}
	}
}

func (q *Q10[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]) Each(fn func(ID, *T1, *T2, *T3, *T4, *T5, *T6, *T7, *T8, *T9, *T10), queryOptions ...Q10Option) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q10Option
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
	for compoundIdx, compound := range q.storage.Compounds {
		if options.Hash != nil {
			if i, ok := sliceFind(compound.Components, options.Hash.ID); ok {
				if compound.Hashes[i] != options.Hash.Hash {
					continue
				}
			} else {
				continue
			}
		}
		componentMax := len(compound.Values) - 1
		var v1s []T1
		if q.Components[0] > componentMax || compound.Values[q.Components[0]] == nil {
			if !options.Optional[0] {
				continue
			}
		} else {
			v1s = compound.Values[q.Components[0]].([]T1)
		}
		var v2s []T2
		if q.Components[1] > componentMax || compound.Values[q.Components[1]] == nil {
			if !options.Optional[1] {
				continue
			}
		} else {
			v2s = compound.Values[q.Components[1]].([]T2)
		}
		var v3s []T3
		if q.Components[2] > componentMax || compound.Values[q.Components[2]] == nil {
			if !options.Optional[2] {
				continue
			}
		} else {
			v3s = compound.Values[q.Components[2]].([]T3)
		}
		var v4s []T4
		if q.Components[3] > componentMax || compound.Values[q.Components[3]] == nil {
			if !options.Optional[3] {
				continue
			}
		} else {
			v4s = compound.Values[q.Components[3]].([]T4)
		}
		var v5s []T5
		if q.Components[4] > componentMax || compound.Values[q.Components[4]] == nil {
			if !options.Optional[4] {
				continue
			}
		} else {
			v5s = compound.Values[q.Components[4]].([]T5)
		}
		var v6s []T6
		if q.Components[5] > componentMax || compound.Values[q.Components[5]] == nil {
			if !options.Optional[5] {
				continue
			}
		} else {
			v6s = compound.Values[q.Components[5]].([]T6)
		}
		var v7s []T7
		if q.Components[6] > componentMax || compound.Values[q.Components[6]] == nil {
			if !options.Optional[6] {
				continue
			}
		} else {
			v7s = compound.Values[q.Components[6]].([]T7)
		}
		var v8s []T8
		if q.Components[7] > componentMax || compound.Values[q.Components[7]] == nil {
			if !options.Optional[7] {
				continue
			}
		} else {
			v8s = compound.Values[q.Components[7]].([]T8)
		}
		var v9s []T9
		if q.Components[8] > componentMax || compound.Values[q.Components[8]] == nil {
			if !options.Optional[8] {
				continue
			}
		} else {
			v9s = compound.Values[q.Components[8]].([]T9)
		}
		var v10s []T10
		if q.Components[9] > componentMax || compound.Values[q.Components[9]] == nil {
			if !options.Optional[9] {
				continue
			}
		} else {
			v10s = compound.Values[q.Components[9]].([]T10)
		}
		// If it has removed items, also flush them
		if compound.Removed != nil {
			count := len(compound.Removed)
			if len(compound.IDs) == count { // Compound is empty, throw away
				q.storage.Compounds = sliceRemove(q.storage.Compounds, compoundIdx)
				continue
			}
			idxRemove := make([]int, count)
			skip, skipped := compound.Removed[0], 0
			for idx, id := range compound.IDs {
				if id == skip {
					idxRemove[skipped] = idx
					if skipped < count-1 {
						skipped++
						skip = compound.Removed[skipped]
					}
					continue
				}

				fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx))
				if *options.Stop {
					return
				}
			}
			// Remove items and flush
			for i := len(idxRemove) - 1; i >= 0; i-- {
				compound.IDs = sliceRemove(compound.IDs, idxRemove[i])
				v1s = sliceRemove(v1s, idxRemove[i])
				v2s = sliceRemove(v2s, idxRemove[i])
				v3s = sliceRemove(v3s, idxRemove[i])
				v4s = sliceRemove(v4s, idxRemove[i])
				v5s = sliceRemove(v5s, idxRemove[i])
				v6s = sliceRemove(v6s, idxRemove[i])
				v7s = sliceRemove(v7s, idxRemove[i])
				v8s = sliceRemove(v8s, idxRemove[i])
				v9s = sliceRemove(v9s, idxRemove[i])
				v10s = sliceRemove(v10s, idxRemove[i])
			}
			compound.Values[q.Components[0]] = v1s
			compound.Values[q.Components[1]] = v2s
			compound.Values[q.Components[2]] = v3s
			compound.Values[q.Components[3]] = v4s
			compound.Values[q.Components[4]] = v5s
			compound.Values[q.Components[5]] = v6s
			compound.Values[q.Components[6]] = v7s
			compound.Values[q.Components[7]] = v8s
			compound.Values[q.Components[8]] = v9s
			compound.Values[q.Components[9]] = v10s

			compound.Removed = nil
			continue
		}
		// Normal loop
		for idx, id := range compound.IDs {
			fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx))
			if *options.Stop {
				return
			}
		}
	}
}

func (q *Q11[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11]) Each(fn func(ID, *T1, *T2, *T3, *T4, *T5, *T6, *T7, *T8, *T9, *T10, *T11), queryOptions ...Q11Option) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q11Option
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
	for compoundIdx, compound := range q.storage.Compounds {
		if options.Hash != nil {
			if i, ok := sliceFind(compound.Components, options.Hash.ID); ok {
				if compound.Hashes[i] != options.Hash.Hash {
					continue
				}
			} else {
				continue
			}
		}
		componentMax := len(compound.Values) - 1
		var v1s []T1
		if q.Components[0] > componentMax || compound.Values[q.Components[0]] == nil {
			if !options.Optional[0] {
				continue
			}
		} else {
			v1s = compound.Values[q.Components[0]].([]T1)
		}
		var v2s []T2
		if q.Components[1] > componentMax || compound.Values[q.Components[1]] == nil {
			if !options.Optional[1] {
				continue
			}
		} else {
			v2s = compound.Values[q.Components[1]].([]T2)
		}
		var v3s []T3
		if q.Components[2] > componentMax || compound.Values[q.Components[2]] == nil {
			if !options.Optional[2] {
				continue
			}
		} else {
			v3s = compound.Values[q.Components[2]].([]T3)
		}
		var v4s []T4
		if q.Components[3] > componentMax || compound.Values[q.Components[3]] == nil {
			if !options.Optional[3] {
				continue
			}
		} else {
			v4s = compound.Values[q.Components[3]].([]T4)
		}
		var v5s []T5
		if q.Components[4] > componentMax || compound.Values[q.Components[4]] == nil {
			if !options.Optional[4] {
				continue
			}
		} else {
			v5s = compound.Values[q.Components[4]].([]T5)
		}
		var v6s []T6
		if q.Components[5] > componentMax || compound.Values[q.Components[5]] == nil {
			if !options.Optional[5] {
				continue
			}
		} else {
			v6s = compound.Values[q.Components[5]].([]T6)
		}
		var v7s []T7
		if q.Components[6] > componentMax || compound.Values[q.Components[6]] == nil {
			if !options.Optional[6] {
				continue
			}
		} else {
			v7s = compound.Values[q.Components[6]].([]T7)
		}
		var v8s []T8
		if q.Components[7] > componentMax || compound.Values[q.Components[7]] == nil {
			if !options.Optional[7] {
				continue
			}
		} else {
			v8s = compound.Values[q.Components[7]].([]T8)
		}
		var v9s []T9
		if q.Components[8] > componentMax || compound.Values[q.Components[8]] == nil {
			if !options.Optional[8] {
				continue
			}
		} else {
			v9s = compound.Values[q.Components[8]].([]T9)
		}
		var v10s []T10
		if q.Components[9] > componentMax || compound.Values[q.Components[9]] == nil {
			if !options.Optional[9] {
				continue
			}
		} else {
			v10s = compound.Values[q.Components[9]].([]T10)
		}
		var v11s []T11
		if q.Components[10] > componentMax || compound.Values[q.Components[10]] == nil {
			if !options.Optional[10] {
				continue
			}
		} else {
			v11s = compound.Values[q.Components[10]].([]T11)
		}
		// If it has removed items, also flush them
		if compound.Removed != nil {
			count := len(compound.Removed)
			if len(compound.IDs) == count { // Compound is empty, throw away
				q.storage.Compounds = sliceRemove(q.storage.Compounds, compoundIdx)
				continue
			}
			idxRemove := make([]int, count)
			skip, skipped := compound.Removed[0], 0
			for idx, id := range compound.IDs {
				if id == skip {
					idxRemove[skipped] = idx
					if skipped < count-1 {
						skipped++
						skip = compound.Removed[skipped]
					}
					continue
				}

				fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx))
				if *options.Stop {
					return
				}
			}
			// Remove items and flush
			for i := len(idxRemove) - 1; i >= 0; i-- {
				compound.IDs = sliceRemove(compound.IDs, idxRemove[i])
				v1s = sliceRemove(v1s, idxRemove[i])
				v2s = sliceRemove(v2s, idxRemove[i])
				v3s = sliceRemove(v3s, idxRemove[i])
				v4s = sliceRemove(v4s, idxRemove[i])
				v5s = sliceRemove(v5s, idxRemove[i])
				v6s = sliceRemove(v6s, idxRemove[i])
				v7s = sliceRemove(v7s, idxRemove[i])
				v8s = sliceRemove(v8s, idxRemove[i])
				v9s = sliceRemove(v9s, idxRemove[i])
				v10s = sliceRemove(v10s, idxRemove[i])
				v11s = sliceRemove(v11s, idxRemove[i])
			}
			compound.Values[q.Components[0]] = v1s
			compound.Values[q.Components[1]] = v2s
			compound.Values[q.Components[2]] = v3s
			compound.Values[q.Components[3]] = v4s
			compound.Values[q.Components[4]] = v5s
			compound.Values[q.Components[5]] = v6s
			compound.Values[q.Components[6]] = v7s
			compound.Values[q.Components[7]] = v8s
			compound.Values[q.Components[8]] = v9s
			compound.Values[q.Components[9]] = v10s
			compound.Values[q.Components[10]] = v11s

			compound.Removed = nil
			continue
		}
		// Normal loop
		for idx, id := range compound.IDs {
			fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx))
			if *options.Stop {
				return
			}
		}
	}
}

func (q *Q12[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12]) Each(fn func(ID, *T1, *T2, *T3, *T4, *T5, *T6, *T7, *T8, *T9, *T10, *T11, *T12), queryOptions ...Q12Option) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q12Option
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
	for compoundIdx, compound := range q.storage.Compounds {
		if options.Hash != nil {
			if i, ok := sliceFind(compound.Components, options.Hash.ID); ok {
				if compound.Hashes[i] != options.Hash.Hash {
					continue
				}
			} else {
				continue
			}
		}
		componentMax := len(compound.Values) - 1
		var v1s []T1
		if q.Components[0] > componentMax || compound.Values[q.Components[0]] == nil {
			if !options.Optional[0] {
				continue
			}
		} else {
			v1s = compound.Values[q.Components[0]].([]T1)
		}
		var v2s []T2
		if q.Components[1] > componentMax || compound.Values[q.Components[1]] == nil {
			if !options.Optional[1] {
				continue
			}
		} else {
			v2s = compound.Values[q.Components[1]].([]T2)
		}
		var v3s []T3
		if q.Components[2] > componentMax || compound.Values[q.Components[2]] == nil {
			if !options.Optional[2] {
				continue
			}
		} else {
			v3s = compound.Values[q.Components[2]].([]T3)
		}
		var v4s []T4
		if q.Components[3] > componentMax || compound.Values[q.Components[3]] == nil {
			if !options.Optional[3] {
				continue
			}
		} else {
			v4s = compound.Values[q.Components[3]].([]T4)
		}
		var v5s []T5
		if q.Components[4] > componentMax || compound.Values[q.Components[4]] == nil {
			if !options.Optional[4] {
				continue
			}
		} else {
			v5s = compound.Values[q.Components[4]].([]T5)
		}
		var v6s []T6
		if q.Components[5] > componentMax || compound.Values[q.Components[5]] == nil {
			if !options.Optional[5] {
				continue
			}
		} else {
			v6s = compound.Values[q.Components[5]].([]T6)
		}
		var v7s []T7
		if q.Components[6] > componentMax || compound.Values[q.Components[6]] == nil {
			if !options.Optional[6] {
				continue
			}
		} else {
			v7s = compound.Values[q.Components[6]].([]T7)
		}
		var v8s []T8
		if q.Components[7] > componentMax || compound.Values[q.Components[7]] == nil {
			if !options.Optional[7] {
				continue
			}
		} else {
			v8s = compound.Values[q.Components[7]].([]T8)
		}
		var v9s []T9
		if q.Components[8] > componentMax || compound.Values[q.Components[8]] == nil {
			if !options.Optional[8] {
				continue
			}
		} else {
			v9s = compound.Values[q.Components[8]].([]T9)
		}
		var v10s []T10
		if q.Components[9] > componentMax || compound.Values[q.Components[9]] == nil {
			if !options.Optional[9] {
				continue
			}
		} else {
			v10s = compound.Values[q.Components[9]].([]T10)
		}
		var v11s []T11
		if q.Components[10] > componentMax || compound.Values[q.Components[10]] == nil {
			if !options.Optional[10] {
				continue
			}
		} else {
			v11s = compound.Values[q.Components[10]].([]T11)
		}
		var v12s []T12
		if q.Components[11] > componentMax || compound.Values[q.Components[11]] == nil {
			if !options.Optional[11] {
				continue
			}
		} else {
			v12s = compound.Values[q.Components[11]].([]T12)
		}
		// If it has removed items, also flush them
		if compound.Removed != nil {
			count := len(compound.Removed)
			if len(compound.IDs) == count { // Compound is empty, throw away
				q.storage.Compounds = sliceRemove(q.storage.Compounds, compoundIdx)
				continue
			}
			idxRemove := make([]int, count)
			skip, skipped := compound.Removed[0], 0
			for idx, id := range compound.IDs {
				if id == skip {
					idxRemove[skipped] = idx
					if skipped < count-1 {
						skipped++
						skip = compound.Removed[skipped]
					}
					continue
				}

				fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx))
				if *options.Stop {
					return
				}
			}
			// Remove items and flush
			for i := len(idxRemove) - 1; i >= 0; i-- {
				compound.IDs = sliceRemove(compound.IDs, idxRemove[i])
				v1s = sliceRemove(v1s, idxRemove[i])
				v2s = sliceRemove(v2s, idxRemove[i])
				v3s = sliceRemove(v3s, idxRemove[i])
				v4s = sliceRemove(v4s, idxRemove[i])
				v5s = sliceRemove(v5s, idxRemove[i])
				v6s = sliceRemove(v6s, idxRemove[i])
				v7s = sliceRemove(v7s, idxRemove[i])
				v8s = sliceRemove(v8s, idxRemove[i])
				v9s = sliceRemove(v9s, idxRemove[i])
				v10s = sliceRemove(v10s, idxRemove[i])
				v11s = sliceRemove(v11s, idxRemove[i])
				v12s = sliceRemove(v12s, idxRemove[i])
			}
			compound.Values[q.Components[0]] = v1s
			compound.Values[q.Components[1]] = v2s
			compound.Values[q.Components[2]] = v3s
			compound.Values[q.Components[3]] = v4s
			compound.Values[q.Components[4]] = v5s
			compound.Values[q.Components[5]] = v6s
			compound.Values[q.Components[6]] = v7s
			compound.Values[q.Components[7]] = v8s
			compound.Values[q.Components[8]] = v9s
			compound.Values[q.Components[9]] = v10s
			compound.Values[q.Components[10]] = v11s
			compound.Values[q.Components[11]] = v12s

			compound.Removed = nil
			continue
		}
		// Normal loop
		for idx, id := range compound.IDs {
			fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx))
			if *options.Stop {
				return
			}
		}
	}
}

func (q *Q13[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13]) Each(fn func(ID, *T1, *T2, *T3, *T4, *T5, *T6, *T7, *T8, *T9, *T10, *T11, *T12, *T13), queryOptions ...Q13Option) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q13Option
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
	for compoundIdx, compound := range q.storage.Compounds {
		if options.Hash != nil {
			if i, ok := sliceFind(compound.Components, options.Hash.ID); ok {
				if compound.Hashes[i] != options.Hash.Hash {
					continue
				}
			} else {
				continue
			}
		}
		componentMax := len(compound.Values) - 1
		var v1s []T1
		if q.Components[0] > componentMax || compound.Values[q.Components[0]] == nil {
			if !options.Optional[0] {
				continue
			}
		} else {
			v1s = compound.Values[q.Components[0]].([]T1)
		}
		var v2s []T2
		if q.Components[1] > componentMax || compound.Values[q.Components[1]] == nil {
			if !options.Optional[1] {
				continue
			}
		} else {
			v2s = compound.Values[q.Components[1]].([]T2)
		}
		var v3s []T3
		if q.Components[2] > componentMax || compound.Values[q.Components[2]] == nil {
			if !options.Optional[2] {
				continue
			}
		} else {
			v3s = compound.Values[q.Components[2]].([]T3)
		}
		var v4s []T4
		if q.Components[3] > componentMax || compound.Values[q.Components[3]] == nil {
			if !options.Optional[3] {
				continue
			}
		} else {
			v4s = compound.Values[q.Components[3]].([]T4)
		}
		var v5s []T5
		if q.Components[4] > componentMax || compound.Values[q.Components[4]] == nil {
			if !options.Optional[4] {
				continue
			}
		} else {
			v5s = compound.Values[q.Components[4]].([]T5)
		}
		var v6s []T6
		if q.Components[5] > componentMax || compound.Values[q.Components[5]] == nil {
			if !options.Optional[5] {
				continue
			}
		} else {
			v6s = compound.Values[q.Components[5]].([]T6)
		}
		var v7s []T7
		if q.Components[6] > componentMax || compound.Values[q.Components[6]] == nil {
			if !options.Optional[6] {
				continue
			}
		} else {
			v7s = compound.Values[q.Components[6]].([]T7)
		}
		var v8s []T8
		if q.Components[7] > componentMax || compound.Values[q.Components[7]] == nil {
			if !options.Optional[7] {
				continue
			}
		} else {
			v8s = compound.Values[q.Components[7]].([]T8)
		}
		var v9s []T9
		if q.Components[8] > componentMax || compound.Values[q.Components[8]] == nil {
			if !options.Optional[8] {
				continue
			}
		} else {
			v9s = compound.Values[q.Components[8]].([]T9)
		}
		var v10s []T10
		if q.Components[9] > componentMax || compound.Values[q.Components[9]] == nil {
			if !options.Optional[9] {
				continue
			}
		} else {
			v10s = compound.Values[q.Components[9]].([]T10)
		}
		var v11s []T11
		if q.Components[10] > componentMax || compound.Values[q.Components[10]] == nil {
			if !options.Optional[10] {
				continue
			}
		} else {
			v11s = compound.Values[q.Components[10]].([]T11)
		}
		var v12s []T12
		if q.Components[11] > componentMax || compound.Values[q.Components[11]] == nil {
			if !options.Optional[11] {
				continue
			}
		} else {
			v12s = compound.Values[q.Components[11]].([]T12)
		}
		var v13s []T13
		if q.Components[12] > componentMax || compound.Values[q.Components[12]] == nil {
			if !options.Optional[12] {
				continue
			}
		} else {
			v13s = compound.Values[q.Components[12]].([]T13)
		}
		// If it has removed items, also flush them
		if compound.Removed != nil {
			count := len(compound.Removed)
			if len(compound.IDs) == count { // Compound is empty, throw away
				q.storage.Compounds = sliceRemove(q.storage.Compounds, compoundIdx)
				continue
			}
			idxRemove := make([]int, count)
			skip, skipped := compound.Removed[0], 0
			for idx, id := range compound.IDs {
				if id == skip {
					idxRemove[skipped] = idx
					if skipped < count-1 {
						skipped++
						skip = compound.Removed[skipped]
					}
					continue
				}

				fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx), getOptional(v13s, idx))
				if *options.Stop {
					return
				}
			}
			// Remove items and flush
			for i := len(idxRemove) - 1; i >= 0; i-- {
				compound.IDs = sliceRemove(compound.IDs, idxRemove[i])
				v1s = sliceRemove(v1s, idxRemove[i])
				v2s = sliceRemove(v2s, idxRemove[i])
				v3s = sliceRemove(v3s, idxRemove[i])
				v4s = sliceRemove(v4s, idxRemove[i])
				v5s = sliceRemove(v5s, idxRemove[i])
				v6s = sliceRemove(v6s, idxRemove[i])
				v7s = sliceRemove(v7s, idxRemove[i])
				v8s = sliceRemove(v8s, idxRemove[i])
				v9s = sliceRemove(v9s, idxRemove[i])
				v10s = sliceRemove(v10s, idxRemove[i])
				v11s = sliceRemove(v11s, idxRemove[i])
				v12s = sliceRemove(v12s, idxRemove[i])
				v13s = sliceRemove(v13s, idxRemove[i])
			}
			compound.Values[q.Components[0]] = v1s
			compound.Values[q.Components[1]] = v2s
			compound.Values[q.Components[2]] = v3s
			compound.Values[q.Components[3]] = v4s
			compound.Values[q.Components[4]] = v5s
			compound.Values[q.Components[5]] = v6s
			compound.Values[q.Components[6]] = v7s
			compound.Values[q.Components[7]] = v8s
			compound.Values[q.Components[8]] = v9s
			compound.Values[q.Components[9]] = v10s
			compound.Values[q.Components[10]] = v11s
			compound.Values[q.Components[11]] = v12s
			compound.Values[q.Components[12]] = v13s

			compound.Removed = nil
			continue
		}
		// Normal loop
		for idx, id := range compound.IDs {
			fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx), getOptional(v13s, idx))
			if *options.Stop {
				return
			}
		}
	}
}

func (q *Q14[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14]) Each(fn func(ID, *T1, *T2, *T3, *T4, *T5, *T6, *T7, *T8, *T9, *T10, *T11, *T12, *T13, *T14), queryOptions ...Q14Option) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q14Option
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
	for compoundIdx, compound := range q.storage.Compounds {
		if options.Hash != nil {
			if i, ok := sliceFind(compound.Components, options.Hash.ID); ok {
				if compound.Hashes[i] != options.Hash.Hash {
					continue
				}
			} else {
				continue
			}
		}
		componentMax := len(compound.Values) - 1
		var v1s []T1
		if q.Components[0] > componentMax || compound.Values[q.Components[0]] == nil {
			if !options.Optional[0] {
				continue
			}
		} else {
			v1s = compound.Values[q.Components[0]].([]T1)
		}
		var v2s []T2
		if q.Components[1] > componentMax || compound.Values[q.Components[1]] == nil {
			if !options.Optional[1] {
				continue
			}
		} else {
			v2s = compound.Values[q.Components[1]].([]T2)
		}
		var v3s []T3
		if q.Components[2] > componentMax || compound.Values[q.Components[2]] == nil {
			if !options.Optional[2] {
				continue
			}
		} else {
			v3s = compound.Values[q.Components[2]].([]T3)
		}
		var v4s []T4
		if q.Components[3] > componentMax || compound.Values[q.Components[3]] == nil {
			if !options.Optional[3] {
				continue
			}
		} else {
			v4s = compound.Values[q.Components[3]].([]T4)
		}
		var v5s []T5
		if q.Components[4] > componentMax || compound.Values[q.Components[4]] == nil {
			if !options.Optional[4] {
				continue
			}
		} else {
			v5s = compound.Values[q.Components[4]].([]T5)
		}
		var v6s []T6
		if q.Components[5] > componentMax || compound.Values[q.Components[5]] == nil {
			if !options.Optional[5] {
				continue
			}
		} else {
			v6s = compound.Values[q.Components[5]].([]T6)
		}
		var v7s []T7
		if q.Components[6] > componentMax || compound.Values[q.Components[6]] == nil {
			if !options.Optional[6] {
				continue
			}
		} else {
			v7s = compound.Values[q.Components[6]].([]T7)
		}
		var v8s []T8
		if q.Components[7] > componentMax || compound.Values[q.Components[7]] == nil {
			if !options.Optional[7] {
				continue
			}
		} else {
			v8s = compound.Values[q.Components[7]].([]T8)
		}
		var v9s []T9
		if q.Components[8] > componentMax || compound.Values[q.Components[8]] == nil {
			if !options.Optional[8] {
				continue
			}
		} else {
			v9s = compound.Values[q.Components[8]].([]T9)
		}
		var v10s []T10
		if q.Components[9] > componentMax || compound.Values[q.Components[9]] == nil {
			if !options.Optional[9] {
				continue
			}
		} else {
			v10s = compound.Values[q.Components[9]].([]T10)
		}
		var v11s []T11
		if q.Components[10] > componentMax || compound.Values[q.Components[10]] == nil {
			if !options.Optional[10] {
				continue
			}
		} else {
			v11s = compound.Values[q.Components[10]].([]T11)
		}
		var v12s []T12
		if q.Components[11] > componentMax || compound.Values[q.Components[11]] == nil {
			if !options.Optional[11] {
				continue
			}
		} else {
			v12s = compound.Values[q.Components[11]].([]T12)
		}
		var v13s []T13
		if q.Components[12] > componentMax || compound.Values[q.Components[12]] == nil {
			if !options.Optional[12] {
				continue
			}
		} else {
			v13s = compound.Values[q.Components[12]].([]T13)
		}
		var v14s []T14
		if q.Components[13] > componentMax || compound.Values[q.Components[13]] == nil {
			if !options.Optional[13] {
				continue
			}
		} else {
			v14s = compound.Values[q.Components[13]].([]T14)
		}
		// If it has removed items, also flush them
		if compound.Removed != nil {
			count := len(compound.Removed)
			if len(compound.IDs) == count { // Compound is empty, throw away
				q.storage.Compounds = sliceRemove(q.storage.Compounds, compoundIdx)
				continue
			}
			idxRemove := make([]int, count)
			skip, skipped := compound.Removed[0], 0
			for idx, id := range compound.IDs {
				if id == skip {
					idxRemove[skipped] = idx
					if skipped < count-1 {
						skipped++
						skip = compound.Removed[skipped]
					}
					continue
				}

				fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx), getOptional(v13s, idx), getOptional(v14s, idx))
				if *options.Stop {
					return
				}
			}
			// Remove items and flush
			for i := len(idxRemove) - 1; i >= 0; i-- {
				compound.IDs = sliceRemove(compound.IDs, idxRemove[i])
				v1s = sliceRemove(v1s, idxRemove[i])
				v2s = sliceRemove(v2s, idxRemove[i])
				v3s = sliceRemove(v3s, idxRemove[i])
				v4s = sliceRemove(v4s, idxRemove[i])
				v5s = sliceRemove(v5s, idxRemove[i])
				v6s = sliceRemove(v6s, idxRemove[i])
				v7s = sliceRemove(v7s, idxRemove[i])
				v8s = sliceRemove(v8s, idxRemove[i])
				v9s = sliceRemove(v9s, idxRemove[i])
				v10s = sliceRemove(v10s, idxRemove[i])
				v11s = sliceRemove(v11s, idxRemove[i])
				v12s = sliceRemove(v12s, idxRemove[i])
				v13s = sliceRemove(v13s, idxRemove[i])
				v14s = sliceRemove(v14s, idxRemove[i])
			}
			compound.Values[q.Components[0]] = v1s
			compound.Values[q.Components[1]] = v2s
			compound.Values[q.Components[2]] = v3s
			compound.Values[q.Components[3]] = v4s
			compound.Values[q.Components[4]] = v5s
			compound.Values[q.Components[5]] = v6s
			compound.Values[q.Components[6]] = v7s
			compound.Values[q.Components[7]] = v8s
			compound.Values[q.Components[8]] = v9s
			compound.Values[q.Components[9]] = v10s
			compound.Values[q.Components[10]] = v11s
			compound.Values[q.Components[11]] = v12s
			compound.Values[q.Components[12]] = v13s
			compound.Values[q.Components[13]] = v14s

			compound.Removed = nil
			continue
		}
		// Normal loop
		for idx, id := range compound.IDs {
			fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx), getOptional(v13s, idx), getOptional(v14s, idx))
			if *options.Stop {
				return
			}
		}
	}
}

func (q *Q15[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15]) Each(fn func(ID, *T1, *T2, *T3, *T4, *T5, *T6, *T7, *T8, *T9, *T10, *T11, *T12, *T13, *T14, *T15), queryOptions ...Q15Option) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q15Option
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
	for compoundIdx, compound := range q.storage.Compounds {
		if options.Hash != nil {
			if i, ok := sliceFind(compound.Components, options.Hash.ID); ok {
				if compound.Hashes[i] != options.Hash.Hash {
					continue
				}
			} else {
				continue
			}
		}
		componentMax := len(compound.Values) - 1
		var v1s []T1
		if q.Components[0] > componentMax || compound.Values[q.Components[0]] == nil {
			if !options.Optional[0] {
				continue
			}
		} else {
			v1s = compound.Values[q.Components[0]].([]T1)
		}
		var v2s []T2
		if q.Components[1] > componentMax || compound.Values[q.Components[1]] == nil {
			if !options.Optional[1] {
				continue
			}
		} else {
			v2s = compound.Values[q.Components[1]].([]T2)
		}
		var v3s []T3
		if q.Components[2] > componentMax || compound.Values[q.Components[2]] == nil {
			if !options.Optional[2] {
				continue
			}
		} else {
			v3s = compound.Values[q.Components[2]].([]T3)
		}
		var v4s []T4
		if q.Components[3] > componentMax || compound.Values[q.Components[3]] == nil {
			if !options.Optional[3] {
				continue
			}
		} else {
			v4s = compound.Values[q.Components[3]].([]T4)
		}
		var v5s []T5
		if q.Components[4] > componentMax || compound.Values[q.Components[4]] == nil {
			if !options.Optional[4] {
				continue
			}
		} else {
			v5s = compound.Values[q.Components[4]].([]T5)
		}
		var v6s []T6
		if q.Components[5] > componentMax || compound.Values[q.Components[5]] == nil {
			if !options.Optional[5] {
				continue
			}
		} else {
			v6s = compound.Values[q.Components[5]].([]T6)
		}
		var v7s []T7
		if q.Components[6] > componentMax || compound.Values[q.Components[6]] == nil {
			if !options.Optional[6] {
				continue
			}
		} else {
			v7s = compound.Values[q.Components[6]].([]T7)
		}
		var v8s []T8
		if q.Components[7] > componentMax || compound.Values[q.Components[7]] == nil {
			if !options.Optional[7] {
				continue
			}
		} else {
			v8s = compound.Values[q.Components[7]].([]T8)
		}
		var v9s []T9
		if q.Components[8] > componentMax || compound.Values[q.Components[8]] == nil {
			if !options.Optional[8] {
				continue
			}
		} else {
			v9s = compound.Values[q.Components[8]].([]T9)
		}
		var v10s []T10
		if q.Components[9] > componentMax || compound.Values[q.Components[9]] == nil {
			if !options.Optional[9] {
				continue
			}
		} else {
			v10s = compound.Values[q.Components[9]].([]T10)
		}
		var v11s []T11
		if q.Components[10] > componentMax || compound.Values[q.Components[10]] == nil {
			if !options.Optional[10] {
				continue
			}
		} else {
			v11s = compound.Values[q.Components[10]].([]T11)
		}
		var v12s []T12
		if q.Components[11] > componentMax || compound.Values[q.Components[11]] == nil {
			if !options.Optional[11] {
				continue
			}
		} else {
			v12s = compound.Values[q.Components[11]].([]T12)
		}
		var v13s []T13
		if q.Components[12] > componentMax || compound.Values[q.Components[12]] == nil {
			if !options.Optional[12] {
				continue
			}
		} else {
			v13s = compound.Values[q.Components[12]].([]T13)
		}
		var v14s []T14
		if q.Components[13] > componentMax || compound.Values[q.Components[13]] == nil {
			if !options.Optional[13] {
				continue
			}
		} else {
			v14s = compound.Values[q.Components[13]].([]T14)
		}
		var v15s []T15
		if q.Components[14] > componentMax || compound.Values[q.Components[14]] == nil {
			if !options.Optional[14] {
				continue
			}
		} else {
			v15s = compound.Values[q.Components[14]].([]T15)
		}
		// If it has removed items, also flush them
		if compound.Removed != nil {
			count := len(compound.Removed)
			if len(compound.IDs) == count { // Compound is empty, throw away
				q.storage.Compounds = sliceRemove(q.storage.Compounds, compoundIdx)
				continue
			}
			idxRemove := make([]int, count)
			skip, skipped := compound.Removed[0], 0
			for idx, id := range compound.IDs {
				if id == skip {
					idxRemove[skipped] = idx
					if skipped < count-1 {
						skipped++
						skip = compound.Removed[skipped]
					}
					continue
				}

				fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx), getOptional(v13s, idx), getOptional(v14s, idx), getOptional(v15s, idx))
				if *options.Stop {
					return
				}
			}
			// Remove items and flush
			for i := len(idxRemove) - 1; i >= 0; i-- {
				compound.IDs = sliceRemove(compound.IDs, idxRemove[i])
				v1s = sliceRemove(v1s, idxRemove[i])
				v2s = sliceRemove(v2s, idxRemove[i])
				v3s = sliceRemove(v3s, idxRemove[i])
				v4s = sliceRemove(v4s, idxRemove[i])
				v5s = sliceRemove(v5s, idxRemove[i])
				v6s = sliceRemove(v6s, idxRemove[i])
				v7s = sliceRemove(v7s, idxRemove[i])
				v8s = sliceRemove(v8s, idxRemove[i])
				v9s = sliceRemove(v9s, idxRemove[i])
				v10s = sliceRemove(v10s, idxRemove[i])
				v11s = sliceRemove(v11s, idxRemove[i])
				v12s = sliceRemove(v12s, idxRemove[i])
				v13s = sliceRemove(v13s, idxRemove[i])
				v14s = sliceRemove(v14s, idxRemove[i])
				v15s = sliceRemove(v15s, idxRemove[i])
			}
			compound.Values[q.Components[0]] = v1s
			compound.Values[q.Components[1]] = v2s
			compound.Values[q.Components[2]] = v3s
			compound.Values[q.Components[3]] = v4s
			compound.Values[q.Components[4]] = v5s
			compound.Values[q.Components[5]] = v6s
			compound.Values[q.Components[6]] = v7s
			compound.Values[q.Components[7]] = v8s
			compound.Values[q.Components[8]] = v9s
			compound.Values[q.Components[9]] = v10s
			compound.Values[q.Components[10]] = v11s
			compound.Values[q.Components[11]] = v12s
			compound.Values[q.Components[12]] = v13s
			compound.Values[q.Components[13]] = v14s
			compound.Values[q.Components[14]] = v15s

			compound.Removed = nil
			continue
		}
		// Normal loop
		for idx, id := range compound.IDs {
			fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx), getOptional(v13s, idx), getOptional(v14s, idx), getOptional(v15s, idx))
			if *options.Stop {
				return
			}
		}
	}
}

func (q *Q16[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16]) Each(fn func(ID, *T1, *T2, *T3, *T4, *T5, *T6, *T7, *T8, *T9, *T10, *T11, *T12, *T13, *T14, *T15, *T16), queryOptions ...Q16Option) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q16Option
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
	for compoundIdx, compound := range q.storage.Compounds {
		if options.Hash != nil {
			if i, ok := sliceFind(compound.Components, options.Hash.ID); ok {
				if compound.Hashes[i] != options.Hash.Hash {
					continue
				}
			} else {
				continue
			}
		}
		componentMax := len(compound.Values) - 1
		var v1s []T1
		if q.Components[0] > componentMax || compound.Values[q.Components[0]] == nil {
			if !options.Optional[0] {
				continue
			}
		} else {
			v1s = compound.Values[q.Components[0]].([]T1)
		}
		var v2s []T2
		if q.Components[1] > componentMax || compound.Values[q.Components[1]] == nil {
			if !options.Optional[1] {
				continue
			}
		} else {
			v2s = compound.Values[q.Components[1]].([]T2)
		}
		var v3s []T3
		if q.Components[2] > componentMax || compound.Values[q.Components[2]] == nil {
			if !options.Optional[2] {
				continue
			}
		} else {
			v3s = compound.Values[q.Components[2]].([]T3)
		}
		var v4s []T4
		if q.Components[3] > componentMax || compound.Values[q.Components[3]] == nil {
			if !options.Optional[3] {
				continue
			}
		} else {
			v4s = compound.Values[q.Components[3]].([]T4)
		}
		var v5s []T5
		if q.Components[4] > componentMax || compound.Values[q.Components[4]] == nil {
			if !options.Optional[4] {
				continue
			}
		} else {
			v5s = compound.Values[q.Components[4]].([]T5)
		}
		var v6s []T6
		if q.Components[5] > componentMax || compound.Values[q.Components[5]] == nil {
			if !options.Optional[5] {
				continue
			}
		} else {
			v6s = compound.Values[q.Components[5]].([]T6)
		}
		var v7s []T7
		if q.Components[6] > componentMax || compound.Values[q.Components[6]] == nil {
			if !options.Optional[6] {
				continue
			}
		} else {
			v7s = compound.Values[q.Components[6]].([]T7)
		}
		var v8s []T8
		if q.Components[7] > componentMax || compound.Values[q.Components[7]] == nil {
			if !options.Optional[7] {
				continue
			}
		} else {
			v8s = compound.Values[q.Components[7]].([]T8)
		}
		var v9s []T9
		if q.Components[8] > componentMax || compound.Values[q.Components[8]] == nil {
			if !options.Optional[8] {
				continue
			}
		} else {
			v9s = compound.Values[q.Components[8]].([]T9)
		}
		var v10s []T10
		if q.Components[9] > componentMax || compound.Values[q.Components[9]] == nil {
			if !options.Optional[9] {
				continue
			}
		} else {
			v10s = compound.Values[q.Components[9]].([]T10)
		}
		var v11s []T11
		if q.Components[10] > componentMax || compound.Values[q.Components[10]] == nil {
			if !options.Optional[10] {
				continue
			}
		} else {
			v11s = compound.Values[q.Components[10]].([]T11)
		}
		var v12s []T12
		if q.Components[11] > componentMax || compound.Values[q.Components[11]] == nil {
			if !options.Optional[11] {
				continue
			}
		} else {
			v12s = compound.Values[q.Components[11]].([]T12)
		}
		var v13s []T13
		if q.Components[12] > componentMax || compound.Values[q.Components[12]] == nil {
			if !options.Optional[12] {
				continue
			}
		} else {
			v13s = compound.Values[q.Components[12]].([]T13)
		}
		var v14s []T14
		if q.Components[13] > componentMax || compound.Values[q.Components[13]] == nil {
			if !options.Optional[13] {
				continue
			}
		} else {
			v14s = compound.Values[q.Components[13]].([]T14)
		}
		var v15s []T15
		if q.Components[14] > componentMax || compound.Values[q.Components[14]] == nil {
			if !options.Optional[14] {
				continue
			}
		} else {
			v15s = compound.Values[q.Components[14]].([]T15)
		}
		var v16s []T16
		if q.Components[15] > componentMax || compound.Values[q.Components[15]] == nil {
			if !options.Optional[15] {
				continue
			}
		} else {
			v16s = compound.Values[q.Components[15]].([]T16)
		}
		// If it has removed items, also flush them
		if compound.Removed != nil {
			count := len(compound.Removed)
			if len(compound.IDs) == count { // Compound is empty, throw away
				q.storage.Compounds = sliceRemove(q.storage.Compounds, compoundIdx)
				continue
			}
			idxRemove := make([]int, count)
			skip, skipped := compound.Removed[0], 0
			for idx, id := range compound.IDs {
				if id == skip {
					idxRemove[skipped] = idx
					if skipped < count-1 {
						skipped++
						skip = compound.Removed[skipped]
					}
					continue
				}

				fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx), getOptional(v13s, idx), getOptional(v14s, idx), getOptional(v15s, idx), getOptional(v16s, idx))
				if *options.Stop {
					return
				}
			}
			// Remove items and flush
			for i := len(idxRemove) - 1; i >= 0; i-- {
				compound.IDs = sliceRemove(compound.IDs, idxRemove[i])
				v1s = sliceRemove(v1s, idxRemove[i])
				v2s = sliceRemove(v2s, idxRemove[i])
				v3s = sliceRemove(v3s, idxRemove[i])
				v4s = sliceRemove(v4s, idxRemove[i])
				v5s = sliceRemove(v5s, idxRemove[i])
				v6s = sliceRemove(v6s, idxRemove[i])
				v7s = sliceRemove(v7s, idxRemove[i])
				v8s = sliceRemove(v8s, idxRemove[i])
				v9s = sliceRemove(v9s, idxRemove[i])
				v10s = sliceRemove(v10s, idxRemove[i])
				v11s = sliceRemove(v11s, idxRemove[i])
				v12s = sliceRemove(v12s, idxRemove[i])
				v13s = sliceRemove(v13s, idxRemove[i])
				v14s = sliceRemove(v14s, idxRemove[i])
				v15s = sliceRemove(v15s, idxRemove[i])
				v16s = sliceRemove(v16s, idxRemove[i])
			}
			compound.Values[q.Components[0]] = v1s
			compound.Values[q.Components[1]] = v2s
			compound.Values[q.Components[2]] = v3s
			compound.Values[q.Components[3]] = v4s
			compound.Values[q.Components[4]] = v5s
			compound.Values[q.Components[5]] = v6s
			compound.Values[q.Components[6]] = v7s
			compound.Values[q.Components[7]] = v8s
			compound.Values[q.Components[8]] = v9s
			compound.Values[q.Components[9]] = v10s
			compound.Values[q.Components[10]] = v11s
			compound.Values[q.Components[11]] = v12s
			compound.Values[q.Components[12]] = v13s
			compound.Values[q.Components[13]] = v14s
			compound.Values[q.Components[14]] = v15s
			compound.Values[q.Components[15]] = v16s

			compound.Removed = nil
			continue
		}
		// Normal loop
		for idx, id := range compound.IDs {
			fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx), getOptional(v13s, idx), getOptional(v14s, idx), getOptional(v15s, idx), getOptional(v16s, idx))
			if *options.Stop {
				return
			}
		}
	}
}

func (q *Q17[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17]) Each(fn func(ID, *T1, *T2, *T3, *T4, *T5, *T6, *T7, *T8, *T9, *T10, *T11, *T12, *T13, *T14, *T15, *T16, *T17), queryOptions ...Q17Option) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q17Option
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
	for compoundIdx, compound := range q.storage.Compounds {
		if options.Hash != nil {
			if i, ok := sliceFind(compound.Components, options.Hash.ID); ok {
				if compound.Hashes[i] != options.Hash.Hash {
					continue
				}
			} else {
				continue
			}
		}
		componentMax := len(compound.Values) - 1
		var v1s []T1
		if q.Components[0] > componentMax || compound.Values[q.Components[0]] == nil {
			if !options.Optional[0] {
				continue
			}
		} else {
			v1s = compound.Values[q.Components[0]].([]T1)
		}
		var v2s []T2
		if q.Components[1] > componentMax || compound.Values[q.Components[1]] == nil {
			if !options.Optional[1] {
				continue
			}
		} else {
			v2s = compound.Values[q.Components[1]].([]T2)
		}
		var v3s []T3
		if q.Components[2] > componentMax || compound.Values[q.Components[2]] == nil {
			if !options.Optional[2] {
				continue
			}
		} else {
			v3s = compound.Values[q.Components[2]].([]T3)
		}
		var v4s []T4
		if q.Components[3] > componentMax || compound.Values[q.Components[3]] == nil {
			if !options.Optional[3] {
				continue
			}
		} else {
			v4s = compound.Values[q.Components[3]].([]T4)
		}
		var v5s []T5
		if q.Components[4] > componentMax || compound.Values[q.Components[4]] == nil {
			if !options.Optional[4] {
				continue
			}
		} else {
			v5s = compound.Values[q.Components[4]].([]T5)
		}
		var v6s []T6
		if q.Components[5] > componentMax || compound.Values[q.Components[5]] == nil {
			if !options.Optional[5] {
				continue
			}
		} else {
			v6s = compound.Values[q.Components[5]].([]T6)
		}
		var v7s []T7
		if q.Components[6] > componentMax || compound.Values[q.Components[6]] == nil {
			if !options.Optional[6] {
				continue
			}
		} else {
			v7s = compound.Values[q.Components[6]].([]T7)
		}
		var v8s []T8
		if q.Components[7] > componentMax || compound.Values[q.Components[7]] == nil {
			if !options.Optional[7] {
				continue
			}
		} else {
			v8s = compound.Values[q.Components[7]].([]T8)
		}
		var v9s []T9
		if q.Components[8] > componentMax || compound.Values[q.Components[8]] == nil {
			if !options.Optional[8] {
				continue
			}
		} else {
			v9s = compound.Values[q.Components[8]].([]T9)
		}
		var v10s []T10
		if q.Components[9] > componentMax || compound.Values[q.Components[9]] == nil {
			if !options.Optional[9] {
				continue
			}
		} else {
			v10s = compound.Values[q.Components[9]].([]T10)
		}
		var v11s []T11
		if q.Components[10] > componentMax || compound.Values[q.Components[10]] == nil {
			if !options.Optional[10] {
				continue
			}
		} else {
			v11s = compound.Values[q.Components[10]].([]T11)
		}
		var v12s []T12
		if q.Components[11] > componentMax || compound.Values[q.Components[11]] == nil {
			if !options.Optional[11] {
				continue
			}
		} else {
			v12s = compound.Values[q.Components[11]].([]T12)
		}
		var v13s []T13
		if q.Components[12] > componentMax || compound.Values[q.Components[12]] == nil {
			if !options.Optional[12] {
				continue
			}
		} else {
			v13s = compound.Values[q.Components[12]].([]T13)
		}
		var v14s []T14
		if q.Components[13] > componentMax || compound.Values[q.Components[13]] == nil {
			if !options.Optional[13] {
				continue
			}
		} else {
			v14s = compound.Values[q.Components[13]].([]T14)
		}
		var v15s []T15
		if q.Components[14] > componentMax || compound.Values[q.Components[14]] == nil {
			if !options.Optional[14] {
				continue
			}
		} else {
			v15s = compound.Values[q.Components[14]].([]T15)
		}
		var v16s []T16
		if q.Components[15] > componentMax || compound.Values[q.Components[15]] == nil {
			if !options.Optional[15] {
				continue
			}
		} else {
			v16s = compound.Values[q.Components[15]].([]T16)
		}
		var v17s []T17
		if q.Components[16] > componentMax || compound.Values[q.Components[16]] == nil {
			if !options.Optional[16] {
				continue
			}
		} else {
			v17s = compound.Values[q.Components[16]].([]T17)
		}
		// If it has removed items, also flush them
		if compound.Removed != nil {
			count := len(compound.Removed)
			if len(compound.IDs) == count { // Compound is empty, throw away
				q.storage.Compounds = sliceRemove(q.storage.Compounds, compoundIdx)
				continue
			}
			idxRemove := make([]int, count)
			skip, skipped := compound.Removed[0], 0
			for idx, id := range compound.IDs {
				if id == skip {
					idxRemove[skipped] = idx
					if skipped < count-1 {
						skipped++
						skip = compound.Removed[skipped]
					}
					continue
				}

				fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx), getOptional(v13s, idx), getOptional(v14s, idx), getOptional(v15s, idx), getOptional(v16s, idx), getOptional(v17s, idx))
				if *options.Stop {
					return
				}
			}
			// Remove items and flush
			for i := len(idxRemove) - 1; i >= 0; i-- {
				compound.IDs = sliceRemove(compound.IDs, idxRemove[i])
				v1s = sliceRemove(v1s, idxRemove[i])
				v2s = sliceRemove(v2s, idxRemove[i])
				v3s = sliceRemove(v3s, idxRemove[i])
				v4s = sliceRemove(v4s, idxRemove[i])
				v5s = sliceRemove(v5s, idxRemove[i])
				v6s = sliceRemove(v6s, idxRemove[i])
				v7s = sliceRemove(v7s, idxRemove[i])
				v8s = sliceRemove(v8s, idxRemove[i])
				v9s = sliceRemove(v9s, idxRemove[i])
				v10s = sliceRemove(v10s, idxRemove[i])
				v11s = sliceRemove(v11s, idxRemove[i])
				v12s = sliceRemove(v12s, idxRemove[i])
				v13s = sliceRemove(v13s, idxRemove[i])
				v14s = sliceRemove(v14s, idxRemove[i])
				v15s = sliceRemove(v15s, idxRemove[i])
				v16s = sliceRemove(v16s, idxRemove[i])
				v17s = sliceRemove(v17s, idxRemove[i])
			}
			compound.Values[q.Components[0]] = v1s
			compound.Values[q.Components[1]] = v2s
			compound.Values[q.Components[2]] = v3s
			compound.Values[q.Components[3]] = v4s
			compound.Values[q.Components[4]] = v5s
			compound.Values[q.Components[5]] = v6s
			compound.Values[q.Components[6]] = v7s
			compound.Values[q.Components[7]] = v8s
			compound.Values[q.Components[8]] = v9s
			compound.Values[q.Components[9]] = v10s
			compound.Values[q.Components[10]] = v11s
			compound.Values[q.Components[11]] = v12s
			compound.Values[q.Components[12]] = v13s
			compound.Values[q.Components[13]] = v14s
			compound.Values[q.Components[14]] = v15s
			compound.Values[q.Components[15]] = v16s
			compound.Values[q.Components[16]] = v17s

			compound.Removed = nil
			continue
		}
		// Normal loop
		for idx, id := range compound.IDs {
			fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx), getOptional(v13s, idx), getOptional(v14s, idx), getOptional(v15s, idx), getOptional(v16s, idx), getOptional(v17s, idx))
			if *options.Stop {
				return
			}
		}
	}
}

func (q *Q18[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18]) Each(fn func(ID, *T1, *T2, *T3, *T4, *T5, *T6, *T7, *T8, *T9, *T10, *T11, *T12, *T13, *T14, *T15, *T16, *T17, *T18), queryOptions ...Q18Option) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q18Option
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
	for compoundIdx, compound := range q.storage.Compounds {
		if options.Hash != nil {
			if i, ok := sliceFind(compound.Components, options.Hash.ID); ok {
				if compound.Hashes[i] != options.Hash.Hash {
					continue
				}
			} else {
				continue
			}
		}
		componentMax := len(compound.Values) - 1
		var v1s []T1
		if q.Components[0] > componentMax || compound.Values[q.Components[0]] == nil {
			if !options.Optional[0] {
				continue
			}
		} else {
			v1s = compound.Values[q.Components[0]].([]T1)
		}
		var v2s []T2
		if q.Components[1] > componentMax || compound.Values[q.Components[1]] == nil {
			if !options.Optional[1] {
				continue
			}
		} else {
			v2s = compound.Values[q.Components[1]].([]T2)
		}
		var v3s []T3
		if q.Components[2] > componentMax || compound.Values[q.Components[2]] == nil {
			if !options.Optional[2] {
				continue
			}
		} else {
			v3s = compound.Values[q.Components[2]].([]T3)
		}
		var v4s []T4
		if q.Components[3] > componentMax || compound.Values[q.Components[3]] == nil {
			if !options.Optional[3] {
				continue
			}
		} else {
			v4s = compound.Values[q.Components[3]].([]T4)
		}
		var v5s []T5
		if q.Components[4] > componentMax || compound.Values[q.Components[4]] == nil {
			if !options.Optional[4] {
				continue
			}
		} else {
			v5s = compound.Values[q.Components[4]].([]T5)
		}
		var v6s []T6
		if q.Components[5] > componentMax || compound.Values[q.Components[5]] == nil {
			if !options.Optional[5] {
				continue
			}
		} else {
			v6s = compound.Values[q.Components[5]].([]T6)
		}
		var v7s []T7
		if q.Components[6] > componentMax || compound.Values[q.Components[6]] == nil {
			if !options.Optional[6] {
				continue
			}
		} else {
			v7s = compound.Values[q.Components[6]].([]T7)
		}
		var v8s []T8
		if q.Components[7] > componentMax || compound.Values[q.Components[7]] == nil {
			if !options.Optional[7] {
				continue
			}
		} else {
			v8s = compound.Values[q.Components[7]].([]T8)
		}
		var v9s []T9
		if q.Components[8] > componentMax || compound.Values[q.Components[8]] == nil {
			if !options.Optional[8] {
				continue
			}
		} else {
			v9s = compound.Values[q.Components[8]].([]T9)
		}
		var v10s []T10
		if q.Components[9] > componentMax || compound.Values[q.Components[9]] == nil {
			if !options.Optional[9] {
				continue
			}
		} else {
			v10s = compound.Values[q.Components[9]].([]T10)
		}
		var v11s []T11
		if q.Components[10] > componentMax || compound.Values[q.Components[10]] == nil {
			if !options.Optional[10] {
				continue
			}
		} else {
			v11s = compound.Values[q.Components[10]].([]T11)
		}
		var v12s []T12
		if q.Components[11] > componentMax || compound.Values[q.Components[11]] == nil {
			if !options.Optional[11] {
				continue
			}
		} else {
			v12s = compound.Values[q.Components[11]].([]T12)
		}
		var v13s []T13
		if q.Components[12] > componentMax || compound.Values[q.Components[12]] == nil {
			if !options.Optional[12] {
				continue
			}
		} else {
			v13s = compound.Values[q.Components[12]].([]T13)
		}
		var v14s []T14
		if q.Components[13] > componentMax || compound.Values[q.Components[13]] == nil {
			if !options.Optional[13] {
				continue
			}
		} else {
			v14s = compound.Values[q.Components[13]].([]T14)
		}
		var v15s []T15
		if q.Components[14] > componentMax || compound.Values[q.Components[14]] == nil {
			if !options.Optional[14] {
				continue
			}
		} else {
			v15s = compound.Values[q.Components[14]].([]T15)
		}
		var v16s []T16
		if q.Components[15] > componentMax || compound.Values[q.Components[15]] == nil {
			if !options.Optional[15] {
				continue
			}
		} else {
			v16s = compound.Values[q.Components[15]].([]T16)
		}
		var v17s []T17
		if q.Components[16] > componentMax || compound.Values[q.Components[16]] == nil {
			if !options.Optional[16] {
				continue
			}
		} else {
			v17s = compound.Values[q.Components[16]].([]T17)
		}
		var v18s []T18
		if q.Components[17] > componentMax || compound.Values[q.Components[17]] == nil {
			if !options.Optional[17] {
				continue
			}
		} else {
			v18s = compound.Values[q.Components[17]].([]T18)
		}
		// If it has removed items, also flush them
		if compound.Removed != nil {
			count := len(compound.Removed)
			if len(compound.IDs) == count { // Compound is empty, throw away
				q.storage.Compounds = sliceRemove(q.storage.Compounds, compoundIdx)
				continue
			}
			idxRemove := make([]int, count)
			skip, skipped := compound.Removed[0], 0
			for idx, id := range compound.IDs {
				if id == skip {
					idxRemove[skipped] = idx
					if skipped < count-1 {
						skipped++
						skip = compound.Removed[skipped]
					}
					continue
				}

				fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx), getOptional(v13s, idx), getOptional(v14s, idx), getOptional(v15s, idx), getOptional(v16s, idx), getOptional(v17s, idx), getOptional(v18s, idx))
				if *options.Stop {
					return
				}
			}
			// Remove items and flush
			for i := len(idxRemove) - 1; i >= 0; i-- {
				compound.IDs = sliceRemove(compound.IDs, idxRemove[i])
				v1s = sliceRemove(v1s, idxRemove[i])
				v2s = sliceRemove(v2s, idxRemove[i])
				v3s = sliceRemove(v3s, idxRemove[i])
				v4s = sliceRemove(v4s, idxRemove[i])
				v5s = sliceRemove(v5s, idxRemove[i])
				v6s = sliceRemove(v6s, idxRemove[i])
				v7s = sliceRemove(v7s, idxRemove[i])
				v8s = sliceRemove(v8s, idxRemove[i])
				v9s = sliceRemove(v9s, idxRemove[i])
				v10s = sliceRemove(v10s, idxRemove[i])
				v11s = sliceRemove(v11s, idxRemove[i])
				v12s = sliceRemove(v12s, idxRemove[i])
				v13s = sliceRemove(v13s, idxRemove[i])
				v14s = sliceRemove(v14s, idxRemove[i])
				v15s = sliceRemove(v15s, idxRemove[i])
				v16s = sliceRemove(v16s, idxRemove[i])
				v17s = sliceRemove(v17s, idxRemove[i])
				v18s = sliceRemove(v18s, idxRemove[i])
			}
			compound.Values[q.Components[0]] = v1s
			compound.Values[q.Components[1]] = v2s
			compound.Values[q.Components[2]] = v3s
			compound.Values[q.Components[3]] = v4s
			compound.Values[q.Components[4]] = v5s
			compound.Values[q.Components[5]] = v6s
			compound.Values[q.Components[6]] = v7s
			compound.Values[q.Components[7]] = v8s
			compound.Values[q.Components[8]] = v9s
			compound.Values[q.Components[9]] = v10s
			compound.Values[q.Components[10]] = v11s
			compound.Values[q.Components[11]] = v12s
			compound.Values[q.Components[12]] = v13s
			compound.Values[q.Components[13]] = v14s
			compound.Values[q.Components[14]] = v15s
			compound.Values[q.Components[15]] = v16s
			compound.Values[q.Components[16]] = v17s
			compound.Values[q.Components[17]] = v18s

			compound.Removed = nil
			continue
		}
		// Normal loop
		for idx, id := range compound.IDs {
			fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx), getOptional(v13s, idx), getOptional(v14s, idx), getOptional(v15s, idx), getOptional(v16s, idx), getOptional(v17s, idx), getOptional(v18s, idx))
			if *options.Stop {
				return
			}
		}
	}
}

func (q *Q19[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19]) Each(fn func(ID, *T1, *T2, *T3, *T4, *T5, *T6, *T7, *T8, *T9, *T10, *T11, *T12, *T13, *T14, *T15, *T16, *T17, *T18, *T19), queryOptions ...Q19Option) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q19Option
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
	for compoundIdx, compound := range q.storage.Compounds {
		if options.Hash != nil {
			if i, ok := sliceFind(compound.Components, options.Hash.ID); ok {
				if compound.Hashes[i] != options.Hash.Hash {
					continue
				}
			} else {
				continue
			}
		}
		componentMax := len(compound.Values) - 1
		var v1s []T1
		if q.Components[0] > componentMax || compound.Values[q.Components[0]] == nil {
			if !options.Optional[0] {
				continue
			}
		} else {
			v1s = compound.Values[q.Components[0]].([]T1)
		}
		var v2s []T2
		if q.Components[1] > componentMax || compound.Values[q.Components[1]] == nil {
			if !options.Optional[1] {
				continue
			}
		} else {
			v2s = compound.Values[q.Components[1]].([]T2)
		}
		var v3s []T3
		if q.Components[2] > componentMax || compound.Values[q.Components[2]] == nil {
			if !options.Optional[2] {
				continue
			}
		} else {
			v3s = compound.Values[q.Components[2]].([]T3)
		}
		var v4s []T4
		if q.Components[3] > componentMax || compound.Values[q.Components[3]] == nil {
			if !options.Optional[3] {
				continue
			}
		} else {
			v4s = compound.Values[q.Components[3]].([]T4)
		}
		var v5s []T5
		if q.Components[4] > componentMax || compound.Values[q.Components[4]] == nil {
			if !options.Optional[4] {
				continue
			}
		} else {
			v5s = compound.Values[q.Components[4]].([]T5)
		}
		var v6s []T6
		if q.Components[5] > componentMax || compound.Values[q.Components[5]] == nil {
			if !options.Optional[5] {
				continue
			}
		} else {
			v6s = compound.Values[q.Components[5]].([]T6)
		}
		var v7s []T7
		if q.Components[6] > componentMax || compound.Values[q.Components[6]] == nil {
			if !options.Optional[6] {
				continue
			}
		} else {
			v7s = compound.Values[q.Components[6]].([]T7)
		}
		var v8s []T8
		if q.Components[7] > componentMax || compound.Values[q.Components[7]] == nil {
			if !options.Optional[7] {
				continue
			}
		} else {
			v8s = compound.Values[q.Components[7]].([]T8)
		}
		var v9s []T9
		if q.Components[8] > componentMax || compound.Values[q.Components[8]] == nil {
			if !options.Optional[8] {
				continue
			}
		} else {
			v9s = compound.Values[q.Components[8]].([]T9)
		}
		var v10s []T10
		if q.Components[9] > componentMax || compound.Values[q.Components[9]] == nil {
			if !options.Optional[9] {
				continue
			}
		} else {
			v10s = compound.Values[q.Components[9]].([]T10)
		}
		var v11s []T11
		if q.Components[10] > componentMax || compound.Values[q.Components[10]] == nil {
			if !options.Optional[10] {
				continue
			}
		} else {
			v11s = compound.Values[q.Components[10]].([]T11)
		}
		var v12s []T12
		if q.Components[11] > componentMax || compound.Values[q.Components[11]] == nil {
			if !options.Optional[11] {
				continue
			}
		} else {
			v12s = compound.Values[q.Components[11]].([]T12)
		}
		var v13s []T13
		if q.Components[12] > componentMax || compound.Values[q.Components[12]] == nil {
			if !options.Optional[12] {
				continue
			}
		} else {
			v13s = compound.Values[q.Components[12]].([]T13)
		}
		var v14s []T14
		if q.Components[13] > componentMax || compound.Values[q.Components[13]] == nil {
			if !options.Optional[13] {
				continue
			}
		} else {
			v14s = compound.Values[q.Components[13]].([]T14)
		}
		var v15s []T15
		if q.Components[14] > componentMax || compound.Values[q.Components[14]] == nil {
			if !options.Optional[14] {
				continue
			}
		} else {
			v15s = compound.Values[q.Components[14]].([]T15)
		}
		var v16s []T16
		if q.Components[15] > componentMax || compound.Values[q.Components[15]] == nil {
			if !options.Optional[15] {
				continue
			}
		} else {
			v16s = compound.Values[q.Components[15]].([]T16)
		}
		var v17s []T17
		if q.Components[16] > componentMax || compound.Values[q.Components[16]] == nil {
			if !options.Optional[16] {
				continue
			}
		} else {
			v17s = compound.Values[q.Components[16]].([]T17)
		}
		var v18s []T18
		if q.Components[17] > componentMax || compound.Values[q.Components[17]] == nil {
			if !options.Optional[17] {
				continue
			}
		} else {
			v18s = compound.Values[q.Components[17]].([]T18)
		}
		var v19s []T19
		if q.Components[18] > componentMax || compound.Values[q.Components[18]] == nil {
			if !options.Optional[18] {
				continue
			}
		} else {
			v19s = compound.Values[q.Components[18]].([]T19)
		}
		// If it has removed items, also flush them
		if compound.Removed != nil {
			count := len(compound.Removed)
			if len(compound.IDs) == count { // Compound is empty, throw away
				q.storage.Compounds = sliceRemove(q.storage.Compounds, compoundIdx)
				continue
			}
			idxRemove := make([]int, count)
			skip, skipped := compound.Removed[0], 0
			for idx, id := range compound.IDs {
				if id == skip {
					idxRemove[skipped] = idx
					if skipped < count-1 {
						skipped++
						skip = compound.Removed[skipped]
					}
					continue
				}

				fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx), getOptional(v13s, idx), getOptional(v14s, idx), getOptional(v15s, idx), getOptional(v16s, idx), getOptional(v17s, idx), getOptional(v18s, idx), getOptional(v19s, idx))
				if *options.Stop {
					return
				}
			}
			// Remove items and flush
			for i := len(idxRemove) - 1; i >= 0; i-- {
				compound.IDs = sliceRemove(compound.IDs, idxRemove[i])
				v1s = sliceRemove(v1s, idxRemove[i])
				v2s = sliceRemove(v2s, idxRemove[i])
				v3s = sliceRemove(v3s, idxRemove[i])
				v4s = sliceRemove(v4s, idxRemove[i])
				v5s = sliceRemove(v5s, idxRemove[i])
				v6s = sliceRemove(v6s, idxRemove[i])
				v7s = sliceRemove(v7s, idxRemove[i])
				v8s = sliceRemove(v8s, idxRemove[i])
				v9s = sliceRemove(v9s, idxRemove[i])
				v10s = sliceRemove(v10s, idxRemove[i])
				v11s = sliceRemove(v11s, idxRemove[i])
				v12s = sliceRemove(v12s, idxRemove[i])
				v13s = sliceRemove(v13s, idxRemove[i])
				v14s = sliceRemove(v14s, idxRemove[i])
				v15s = sliceRemove(v15s, idxRemove[i])
				v16s = sliceRemove(v16s, idxRemove[i])
				v17s = sliceRemove(v17s, idxRemove[i])
				v18s = sliceRemove(v18s, idxRemove[i])
				v19s = sliceRemove(v19s, idxRemove[i])
			}
			compound.Values[q.Components[0]] = v1s
			compound.Values[q.Components[1]] = v2s
			compound.Values[q.Components[2]] = v3s
			compound.Values[q.Components[3]] = v4s
			compound.Values[q.Components[4]] = v5s
			compound.Values[q.Components[5]] = v6s
			compound.Values[q.Components[6]] = v7s
			compound.Values[q.Components[7]] = v8s
			compound.Values[q.Components[8]] = v9s
			compound.Values[q.Components[9]] = v10s
			compound.Values[q.Components[10]] = v11s
			compound.Values[q.Components[11]] = v12s
			compound.Values[q.Components[12]] = v13s
			compound.Values[q.Components[13]] = v14s
			compound.Values[q.Components[14]] = v15s
			compound.Values[q.Components[15]] = v16s
			compound.Values[q.Components[16]] = v17s
			compound.Values[q.Components[17]] = v18s
			compound.Values[q.Components[18]] = v19s

			compound.Removed = nil
			continue
		}
		// Normal loop
		for idx, id := range compound.IDs {
			fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx), getOptional(v13s, idx), getOptional(v14s, idx), getOptional(v15s, idx), getOptional(v16s, idx), getOptional(v17s, idx), getOptional(v18s, idx), getOptional(v19s, idx))
			if *options.Stop {
				return
			}
		}
	}
}

func (q *Q20[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20]) Each(fn func(ID, *T1, *T2, *T3, *T4, *T5, *T6, *T7, *T8, *T9, *T10, *T11, *T12, *T13, *T14, *T15, *T16, *T17, *T18, *T19, *T20), queryOptions ...Q20Option) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q20Option
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
	for compoundIdx, compound := range q.storage.Compounds {
		if options.Hash != nil {
			if i, ok := sliceFind(compound.Components, options.Hash.ID); ok {
				if compound.Hashes[i] != options.Hash.Hash {
					continue
				}
			} else {
				continue
			}
		}
		componentMax := len(compound.Values) - 1
		var v1s []T1
		if q.Components[0] > componentMax || compound.Values[q.Components[0]] == nil {
			if !options.Optional[0] {
				continue
			}
		} else {
			v1s = compound.Values[q.Components[0]].([]T1)
		}
		var v2s []T2
		if q.Components[1] > componentMax || compound.Values[q.Components[1]] == nil {
			if !options.Optional[1] {
				continue
			}
		} else {
			v2s = compound.Values[q.Components[1]].([]T2)
		}
		var v3s []T3
		if q.Components[2] > componentMax || compound.Values[q.Components[2]] == nil {
			if !options.Optional[2] {
				continue
			}
		} else {
			v3s = compound.Values[q.Components[2]].([]T3)
		}
		var v4s []T4
		if q.Components[3] > componentMax || compound.Values[q.Components[3]] == nil {
			if !options.Optional[3] {
				continue
			}
		} else {
			v4s = compound.Values[q.Components[3]].([]T4)
		}
		var v5s []T5
		if q.Components[4] > componentMax || compound.Values[q.Components[4]] == nil {
			if !options.Optional[4] {
				continue
			}
		} else {
			v5s = compound.Values[q.Components[4]].([]T5)
		}
		var v6s []T6
		if q.Components[5] > componentMax || compound.Values[q.Components[5]] == nil {
			if !options.Optional[5] {
				continue
			}
		} else {
			v6s = compound.Values[q.Components[5]].([]T6)
		}
		var v7s []T7
		if q.Components[6] > componentMax || compound.Values[q.Components[6]] == nil {
			if !options.Optional[6] {
				continue
			}
		} else {
			v7s = compound.Values[q.Components[6]].([]T7)
		}
		var v8s []T8
		if q.Components[7] > componentMax || compound.Values[q.Components[7]] == nil {
			if !options.Optional[7] {
				continue
			}
		} else {
			v8s = compound.Values[q.Components[7]].([]T8)
		}
		var v9s []T9
		if q.Components[8] > componentMax || compound.Values[q.Components[8]] == nil {
			if !options.Optional[8] {
				continue
			}
		} else {
			v9s = compound.Values[q.Components[8]].([]T9)
		}
		var v10s []T10
		if q.Components[9] > componentMax || compound.Values[q.Components[9]] == nil {
			if !options.Optional[9] {
				continue
			}
		} else {
			v10s = compound.Values[q.Components[9]].([]T10)
		}
		var v11s []T11
		if q.Components[10] > componentMax || compound.Values[q.Components[10]] == nil {
			if !options.Optional[10] {
				continue
			}
		} else {
			v11s = compound.Values[q.Components[10]].([]T11)
		}
		var v12s []T12
		if q.Components[11] > componentMax || compound.Values[q.Components[11]] == nil {
			if !options.Optional[11] {
				continue
			}
		} else {
			v12s = compound.Values[q.Components[11]].([]T12)
		}
		var v13s []T13
		if q.Components[12] > componentMax || compound.Values[q.Components[12]] == nil {
			if !options.Optional[12] {
				continue
			}
		} else {
			v13s = compound.Values[q.Components[12]].([]T13)
		}
		var v14s []T14
		if q.Components[13] > componentMax || compound.Values[q.Components[13]] == nil {
			if !options.Optional[13] {
				continue
			}
		} else {
			v14s = compound.Values[q.Components[13]].([]T14)
		}
		var v15s []T15
		if q.Components[14] > componentMax || compound.Values[q.Components[14]] == nil {
			if !options.Optional[14] {
				continue
			}
		} else {
			v15s = compound.Values[q.Components[14]].([]T15)
		}
		var v16s []T16
		if q.Components[15] > componentMax || compound.Values[q.Components[15]] == nil {
			if !options.Optional[15] {
				continue
			}
		} else {
			v16s = compound.Values[q.Components[15]].([]T16)
		}
		var v17s []T17
		if q.Components[16] > componentMax || compound.Values[q.Components[16]] == nil {
			if !options.Optional[16] {
				continue
			}
		} else {
			v17s = compound.Values[q.Components[16]].([]T17)
		}
		var v18s []T18
		if q.Components[17] > componentMax || compound.Values[q.Components[17]] == nil {
			if !options.Optional[17] {
				continue
			}
		} else {
			v18s = compound.Values[q.Components[17]].([]T18)
		}
		var v19s []T19
		if q.Components[18] > componentMax || compound.Values[q.Components[18]] == nil {
			if !options.Optional[18] {
				continue
			}
		} else {
			v19s = compound.Values[q.Components[18]].([]T19)
		}
		var v20s []T20
		if q.Components[19] > componentMax || compound.Values[q.Components[19]] == nil {
			if !options.Optional[19] {
				continue
			}
		} else {
			v20s = compound.Values[q.Components[19]].([]T20)
		}
		// If it has removed items, also flush them
		if compound.Removed != nil {
			count := len(compound.Removed)
			if len(compound.IDs) == count { // Compound is empty, throw away
				q.storage.Compounds = sliceRemove(q.storage.Compounds, compoundIdx)
				continue
			}
			idxRemove := make([]int, count)
			skip, skipped := compound.Removed[0], 0
			for idx, id := range compound.IDs {
				if id == skip {
					idxRemove[skipped] = idx
					if skipped < count-1 {
						skipped++
						skip = compound.Removed[skipped]
					}
					continue
				}

				fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx), getOptional(v13s, idx), getOptional(v14s, idx), getOptional(v15s, idx), getOptional(v16s, idx), getOptional(v17s, idx), getOptional(v18s, idx), getOptional(v19s, idx), getOptional(v20s, idx))
				if *options.Stop {
					return
				}
			}
			// Remove items and flush
			for i := len(idxRemove) - 1; i >= 0; i-- {
				compound.IDs = sliceRemove(compound.IDs, idxRemove[i])
				v1s = sliceRemove(v1s, idxRemove[i])
				v2s = sliceRemove(v2s, idxRemove[i])
				v3s = sliceRemove(v3s, idxRemove[i])
				v4s = sliceRemove(v4s, idxRemove[i])
				v5s = sliceRemove(v5s, idxRemove[i])
				v6s = sliceRemove(v6s, idxRemove[i])
				v7s = sliceRemove(v7s, idxRemove[i])
				v8s = sliceRemove(v8s, idxRemove[i])
				v9s = sliceRemove(v9s, idxRemove[i])
				v10s = sliceRemove(v10s, idxRemove[i])
				v11s = sliceRemove(v11s, idxRemove[i])
				v12s = sliceRemove(v12s, idxRemove[i])
				v13s = sliceRemove(v13s, idxRemove[i])
				v14s = sliceRemove(v14s, idxRemove[i])
				v15s = sliceRemove(v15s, idxRemove[i])
				v16s = sliceRemove(v16s, idxRemove[i])
				v17s = sliceRemove(v17s, idxRemove[i])
				v18s = sliceRemove(v18s, idxRemove[i])
				v19s = sliceRemove(v19s, idxRemove[i])
				v20s = sliceRemove(v20s, idxRemove[i])
			}
			compound.Values[q.Components[0]] = v1s
			compound.Values[q.Components[1]] = v2s
			compound.Values[q.Components[2]] = v3s
			compound.Values[q.Components[3]] = v4s
			compound.Values[q.Components[4]] = v5s
			compound.Values[q.Components[5]] = v6s
			compound.Values[q.Components[6]] = v7s
			compound.Values[q.Components[7]] = v8s
			compound.Values[q.Components[8]] = v9s
			compound.Values[q.Components[9]] = v10s
			compound.Values[q.Components[10]] = v11s
			compound.Values[q.Components[11]] = v12s
			compound.Values[q.Components[12]] = v13s
			compound.Values[q.Components[13]] = v14s
			compound.Values[q.Components[14]] = v15s
			compound.Values[q.Components[15]] = v16s
			compound.Values[q.Components[16]] = v17s
			compound.Values[q.Components[17]] = v18s
			compound.Values[q.Components[18]] = v19s
			compound.Values[q.Components[19]] = v20s

			compound.Removed = nil
			continue
		}
		// Normal loop
		for idx, id := range compound.IDs {
			fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx), getOptional(v13s, idx), getOptional(v14s, idx), getOptional(v15s, idx), getOptional(v16s, idx), getOptional(v17s, idx), getOptional(v18s, idx), getOptional(v19s, idx), getOptional(v20s, idx))
			if *options.Stop {
				return
			}
		}
	}
}
