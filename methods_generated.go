// Code generated by generate command. DO NOT EDIT.
package ecs

import (
	"fmt"
)

func Set1[ID Int, T1 any](storage *Storage[ID], id ID, v1 T1) {
	components := []int{storage.componentEnsure(v1)}
	hashes := []int{componentHash(v1)}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.Entitys = append(compound.Entitys, id)
	if compound.Components[0].Data == nil {
		compound.Components[0].Data = &slice[T1]{Data: []T1{v1}}

		return
	}
	compound.Components[0].Data.(*slice[T1]).append(v1)

}

func Set2[ID Int, T1, T2 any](storage *Storage[ID], id ID, v1 T1, v2 T2) {
	components := []int{storage.componentEnsure(v1), storage.componentEnsure(v2)}
	hashes := []int{componentHash(v1), componentHash(v2)}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.Entitys = append(compound.Entitys, id)
	if compound.Components[0].Data == nil {
		compound.Components[0].Data = &slice[T1]{Data: []T1{v1}}
		compound.Components[1].Data = &slice[T2]{Data: []T2{v2}}

		return
	}
	compound.Components[0].Data.(*slice[T1]).append(v1)
	compound.Components[1].Data.(*slice[T2]).append(v2)

}

func Set3[ID Int, T1, T2, T3 any](storage *Storage[ID], id ID, v1 T1, v2 T2, v3 T3) {
	components := []int{storage.componentEnsure(v1), storage.componentEnsure(v2), storage.componentEnsure(v3)}
	hashes := []int{componentHash(v1), componentHash(v2), componentHash(v3)}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.Entitys = append(compound.Entitys, id)
	if compound.Components[0].Data == nil {
		compound.Components[0].Data = &slice[T1]{Data: []T1{v1}}
		compound.Components[1].Data = &slice[T2]{Data: []T2{v2}}
		compound.Components[2].Data = &slice[T3]{Data: []T3{v3}}

		return
	}
	compound.Components[0].Data.(*slice[T1]).append(v1)
	compound.Components[1].Data.(*slice[T2]).append(v2)
	compound.Components[2].Data.(*slice[T3]).append(v3)

}

func Set4[ID Int, T1, T2, T3, T4 any](storage *Storage[ID], id ID, v1 T1, v2 T2, v3 T3, v4 T4) {
	components := []int{storage.componentEnsure(v1), storage.componentEnsure(v2), storage.componentEnsure(v3), storage.componentEnsure(v4)}
	hashes := []int{componentHash(v1), componentHash(v2), componentHash(v3), componentHash(v4)}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.Entitys = append(compound.Entitys, id)
	if compound.Components[0].Data == nil {
		compound.Components[0].Data = &slice[T1]{Data: []T1{v1}}
		compound.Components[1].Data = &slice[T2]{Data: []T2{v2}}
		compound.Components[2].Data = &slice[T3]{Data: []T3{v3}}
		compound.Components[3].Data = &slice[T4]{Data: []T4{v4}}

		return
	}
	compound.Components[0].Data.(*slice[T1]).append(v1)
	compound.Components[1].Data.(*slice[T2]).append(v2)
	compound.Components[2].Data.(*slice[T3]).append(v3)
	compound.Components[3].Data.(*slice[T4]).append(v4)

}

func Set5[ID Int, T1, T2, T3, T4, T5 any](storage *Storage[ID], id ID, v1 T1, v2 T2, v3 T3, v4 T4, v5 T5) {
	components := []int{storage.componentEnsure(v1), storage.componentEnsure(v2), storage.componentEnsure(v3), storage.componentEnsure(v4), storage.componentEnsure(v5)}
	hashes := []int{componentHash(v1), componentHash(v2), componentHash(v3), componentHash(v4), componentHash(v5)}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.Entitys = append(compound.Entitys, id)
	if compound.Components[0].Data == nil {
		compound.Components[0].Data = &slice[T1]{Data: []T1{v1}}
		compound.Components[1].Data = &slice[T2]{Data: []T2{v2}}
		compound.Components[2].Data = &slice[T3]{Data: []T3{v3}}
		compound.Components[3].Data = &slice[T4]{Data: []T4{v4}}
		compound.Components[4].Data = &slice[T5]{Data: []T5{v5}}

		return
	}
	compound.Components[0].Data.(*slice[T1]).append(v1)
	compound.Components[1].Data.(*slice[T2]).append(v2)
	compound.Components[2].Data.(*slice[T3]).append(v3)
	compound.Components[3].Data.(*slice[T4]).append(v4)
	compound.Components[4].Data.(*slice[T5]).append(v5)

}

func Set6[ID Int, T1, T2, T3, T4, T5, T6 any](storage *Storage[ID], id ID, v1 T1, v2 T2, v3 T3, v4 T4, v5 T5, v6 T6) {
	components := []int{storage.componentEnsure(v1), storage.componentEnsure(v2), storage.componentEnsure(v3), storage.componentEnsure(v4), storage.componentEnsure(v5), storage.componentEnsure(v6)}
	hashes := []int{componentHash(v1), componentHash(v2), componentHash(v3), componentHash(v4), componentHash(v5), componentHash(v6)}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.Entitys = append(compound.Entitys, id)
	if compound.Components[0].Data == nil {
		compound.Components[0].Data = &slice[T1]{Data: []T1{v1}}
		compound.Components[1].Data = &slice[T2]{Data: []T2{v2}}
		compound.Components[2].Data = &slice[T3]{Data: []T3{v3}}
		compound.Components[3].Data = &slice[T4]{Data: []T4{v4}}
		compound.Components[4].Data = &slice[T5]{Data: []T5{v5}}
		compound.Components[5].Data = &slice[T6]{Data: []T6{v6}}

		return
	}
	compound.Components[0].Data.(*slice[T1]).append(v1)
	compound.Components[1].Data.(*slice[T2]).append(v2)
	compound.Components[2].Data.(*slice[T3]).append(v3)
	compound.Components[3].Data.(*slice[T4]).append(v4)
	compound.Components[4].Data.(*slice[T5]).append(v5)
	compound.Components[5].Data.(*slice[T6]).append(v6)

}

func Set7[ID Int, T1, T2, T3, T4, T5, T6, T7 any](storage *Storage[ID], id ID, v1 T1, v2 T2, v3 T3, v4 T4, v5 T5, v6 T6, v7 T7) {
	components := []int{storage.componentEnsure(v1), storage.componentEnsure(v2), storage.componentEnsure(v3), storage.componentEnsure(v4), storage.componentEnsure(v5), storage.componentEnsure(v6), storage.componentEnsure(v7)}
	hashes := []int{componentHash(v1), componentHash(v2), componentHash(v3), componentHash(v4), componentHash(v5), componentHash(v6), componentHash(v7)}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.Entitys = append(compound.Entitys, id)
	if compound.Components[0].Data == nil {
		compound.Components[0].Data = &slice[T1]{Data: []T1{v1}}
		compound.Components[1].Data = &slice[T2]{Data: []T2{v2}}
		compound.Components[2].Data = &slice[T3]{Data: []T3{v3}}
		compound.Components[3].Data = &slice[T4]{Data: []T4{v4}}
		compound.Components[4].Data = &slice[T5]{Data: []T5{v5}}
		compound.Components[5].Data = &slice[T6]{Data: []T6{v6}}
		compound.Components[6].Data = &slice[T7]{Data: []T7{v7}}

		return
	}
	compound.Components[0].Data.(*slice[T1]).append(v1)
	compound.Components[1].Data.(*slice[T2]).append(v2)
	compound.Components[2].Data.(*slice[T3]).append(v3)
	compound.Components[3].Data.(*slice[T4]).append(v4)
	compound.Components[4].Data.(*slice[T5]).append(v5)
	compound.Components[5].Data.(*slice[T6]).append(v6)
	compound.Components[6].Data.(*slice[T7]).append(v7)

}

func Set8[ID Int, T1, T2, T3, T4, T5, T6, T7, T8 any](storage *Storage[ID], id ID, v1 T1, v2 T2, v3 T3, v4 T4, v5 T5, v6 T6, v7 T7, v8 T8) {
	components := []int{storage.componentEnsure(v1), storage.componentEnsure(v2), storage.componentEnsure(v3), storage.componentEnsure(v4), storage.componentEnsure(v5), storage.componentEnsure(v6), storage.componentEnsure(v7), storage.componentEnsure(v8)}
	hashes := []int{componentHash(v1), componentHash(v2), componentHash(v3), componentHash(v4), componentHash(v5), componentHash(v6), componentHash(v7), componentHash(v8)}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.Entitys = append(compound.Entitys, id)
	if compound.Components[0].Data == nil {
		compound.Components[0].Data = &slice[T1]{Data: []T1{v1}}
		compound.Components[1].Data = &slice[T2]{Data: []T2{v2}}
		compound.Components[2].Data = &slice[T3]{Data: []T3{v3}}
		compound.Components[3].Data = &slice[T4]{Data: []T4{v4}}
		compound.Components[4].Data = &slice[T5]{Data: []T5{v5}}
		compound.Components[5].Data = &slice[T6]{Data: []T6{v6}}
		compound.Components[6].Data = &slice[T7]{Data: []T7{v7}}
		compound.Components[7].Data = &slice[T8]{Data: []T8{v8}}

		return
	}
	compound.Components[0].Data.(*slice[T1]).append(v1)
	compound.Components[1].Data.(*slice[T2]).append(v2)
	compound.Components[2].Data.(*slice[T3]).append(v3)
	compound.Components[3].Data.(*slice[T4]).append(v4)
	compound.Components[4].Data.(*slice[T5]).append(v5)
	compound.Components[5].Data.(*slice[T6]).append(v6)
	compound.Components[6].Data.(*slice[T7]).append(v7)
	compound.Components[7].Data.(*slice[T8]).append(v8)

}

func Set9[ID Int, T1, T2, T3, T4, T5, T6, T7, T8, T9 any](storage *Storage[ID], id ID, v1 T1, v2 T2, v3 T3, v4 T4, v5 T5, v6 T6, v7 T7, v8 T8, v9 T9) {
	components := []int{storage.componentEnsure(v1), storage.componentEnsure(v2), storage.componentEnsure(v3), storage.componentEnsure(v4), storage.componentEnsure(v5), storage.componentEnsure(v6), storage.componentEnsure(v7), storage.componentEnsure(v8), storage.componentEnsure(v9)}
	hashes := []int{componentHash(v1), componentHash(v2), componentHash(v3), componentHash(v4), componentHash(v5), componentHash(v6), componentHash(v7), componentHash(v8), componentHash(v9)}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.Entitys = append(compound.Entitys, id)
	if compound.Components[0].Data == nil {
		compound.Components[0].Data = &slice[T1]{Data: []T1{v1}}
		compound.Components[1].Data = &slice[T2]{Data: []T2{v2}}
		compound.Components[2].Data = &slice[T3]{Data: []T3{v3}}
		compound.Components[3].Data = &slice[T4]{Data: []T4{v4}}
		compound.Components[4].Data = &slice[T5]{Data: []T5{v5}}
		compound.Components[5].Data = &slice[T6]{Data: []T6{v6}}
		compound.Components[6].Data = &slice[T7]{Data: []T7{v7}}
		compound.Components[7].Data = &slice[T8]{Data: []T8{v8}}
		compound.Components[8].Data = &slice[T9]{Data: []T9{v9}}

		return
	}
	compound.Components[0].Data.(*slice[T1]).append(v1)
	compound.Components[1].Data.(*slice[T2]).append(v2)
	compound.Components[2].Data.(*slice[T3]).append(v3)
	compound.Components[3].Data.(*slice[T4]).append(v4)
	compound.Components[4].Data.(*slice[T5]).append(v5)
	compound.Components[5].Data.(*slice[T6]).append(v6)
	compound.Components[6].Data.(*slice[T7]).append(v7)
	compound.Components[7].Data.(*slice[T8]).append(v8)
	compound.Components[8].Data.(*slice[T9]).append(v9)

}

func Set10[ID Int, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10 any](storage *Storage[ID], id ID, v1 T1, v2 T2, v3 T3, v4 T4, v5 T5, v6 T6, v7 T7, v8 T8, v9 T9, v10 T10) {
	components := []int{storage.componentEnsure(v1), storage.componentEnsure(v2), storage.componentEnsure(v3), storage.componentEnsure(v4), storage.componentEnsure(v5), storage.componentEnsure(v6), storage.componentEnsure(v7), storage.componentEnsure(v8), storage.componentEnsure(v9), storage.componentEnsure(v10)}
	hashes := []int{componentHash(v1), componentHash(v2), componentHash(v3), componentHash(v4), componentHash(v5), componentHash(v6), componentHash(v7), componentHash(v8), componentHash(v9), componentHash(v10)}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.Entitys = append(compound.Entitys, id)
	if compound.Components[0].Data == nil {
		compound.Components[0].Data = &slice[T1]{Data: []T1{v1}}
		compound.Components[1].Data = &slice[T2]{Data: []T2{v2}}
		compound.Components[2].Data = &slice[T3]{Data: []T3{v3}}
		compound.Components[3].Data = &slice[T4]{Data: []T4{v4}}
		compound.Components[4].Data = &slice[T5]{Data: []T5{v5}}
		compound.Components[5].Data = &slice[T6]{Data: []T6{v6}}
		compound.Components[6].Data = &slice[T7]{Data: []T7{v7}}
		compound.Components[7].Data = &slice[T8]{Data: []T8{v8}}
		compound.Components[8].Data = &slice[T9]{Data: []T9{v9}}
		compound.Components[9].Data = &slice[T10]{Data: []T10{v10}}

		return
	}
	compound.Components[0].Data.(*slice[T1]).append(v1)
	compound.Components[1].Data.(*slice[T2]).append(v2)
	compound.Components[2].Data.(*slice[T3]).append(v3)
	compound.Components[3].Data.(*slice[T4]).append(v4)
	compound.Components[4].Data.(*slice[T5]).append(v5)
	compound.Components[5].Data.(*slice[T6]).append(v6)
	compound.Components[6].Data.(*slice[T7]).append(v7)
	compound.Components[7].Data.(*slice[T8]).append(v8)
	compound.Components[8].Data.(*slice[T9]).append(v9)
	compound.Components[9].Data.(*slice[T10]).append(v10)

}

func Set11[ID Int, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11 any](storage *Storage[ID], id ID, v1 T1, v2 T2, v3 T3, v4 T4, v5 T5, v6 T6, v7 T7, v8 T8, v9 T9, v10 T10, v11 T11) {
	components := []int{storage.componentEnsure(v1), storage.componentEnsure(v2), storage.componentEnsure(v3), storage.componentEnsure(v4), storage.componentEnsure(v5), storage.componentEnsure(v6), storage.componentEnsure(v7), storage.componentEnsure(v8), storage.componentEnsure(v9), storage.componentEnsure(v10), storage.componentEnsure(v11)}
	hashes := []int{componentHash(v1), componentHash(v2), componentHash(v3), componentHash(v4), componentHash(v5), componentHash(v6), componentHash(v7), componentHash(v8), componentHash(v9), componentHash(v10), componentHash(v11)}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.Entitys = append(compound.Entitys, id)
	if compound.Components[0].Data == nil {
		compound.Components[0].Data = &slice[T1]{Data: []T1{v1}}
		compound.Components[1].Data = &slice[T2]{Data: []T2{v2}}
		compound.Components[2].Data = &slice[T3]{Data: []T3{v3}}
		compound.Components[3].Data = &slice[T4]{Data: []T4{v4}}
		compound.Components[4].Data = &slice[T5]{Data: []T5{v5}}
		compound.Components[5].Data = &slice[T6]{Data: []T6{v6}}
		compound.Components[6].Data = &slice[T7]{Data: []T7{v7}}
		compound.Components[7].Data = &slice[T8]{Data: []T8{v8}}
		compound.Components[8].Data = &slice[T9]{Data: []T9{v9}}
		compound.Components[9].Data = &slice[T10]{Data: []T10{v10}}
		compound.Components[10].Data = &slice[T11]{Data: []T11{v11}}

		return
	}
	compound.Components[0].Data.(*slice[T1]).append(v1)
	compound.Components[1].Data.(*slice[T2]).append(v2)
	compound.Components[2].Data.(*slice[T3]).append(v3)
	compound.Components[3].Data.(*slice[T4]).append(v4)
	compound.Components[4].Data.(*slice[T5]).append(v5)
	compound.Components[5].Data.(*slice[T6]).append(v6)
	compound.Components[6].Data.(*slice[T7]).append(v7)
	compound.Components[7].Data.(*slice[T8]).append(v8)
	compound.Components[8].Data.(*slice[T9]).append(v9)
	compound.Components[9].Data.(*slice[T10]).append(v10)
	compound.Components[10].Data.(*slice[T11]).append(v11)

}

func Set12[ID Int, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12 any](storage *Storage[ID], id ID, v1 T1, v2 T2, v3 T3, v4 T4, v5 T5, v6 T6, v7 T7, v8 T8, v9 T9, v10 T10, v11 T11, v12 T12) {
	components := []int{storage.componentEnsure(v1), storage.componentEnsure(v2), storage.componentEnsure(v3), storage.componentEnsure(v4), storage.componentEnsure(v5), storage.componentEnsure(v6), storage.componentEnsure(v7), storage.componentEnsure(v8), storage.componentEnsure(v9), storage.componentEnsure(v10), storage.componentEnsure(v11), storage.componentEnsure(v12)}
	hashes := []int{componentHash(v1), componentHash(v2), componentHash(v3), componentHash(v4), componentHash(v5), componentHash(v6), componentHash(v7), componentHash(v8), componentHash(v9), componentHash(v10), componentHash(v11), componentHash(v12)}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.Entitys = append(compound.Entitys, id)
	if compound.Components[0].Data == nil {
		compound.Components[0].Data = &slice[T1]{Data: []T1{v1}}
		compound.Components[1].Data = &slice[T2]{Data: []T2{v2}}
		compound.Components[2].Data = &slice[T3]{Data: []T3{v3}}
		compound.Components[3].Data = &slice[T4]{Data: []T4{v4}}
		compound.Components[4].Data = &slice[T5]{Data: []T5{v5}}
		compound.Components[5].Data = &slice[T6]{Data: []T6{v6}}
		compound.Components[6].Data = &slice[T7]{Data: []T7{v7}}
		compound.Components[7].Data = &slice[T8]{Data: []T8{v8}}
		compound.Components[8].Data = &slice[T9]{Data: []T9{v9}}
		compound.Components[9].Data = &slice[T10]{Data: []T10{v10}}
		compound.Components[10].Data = &slice[T11]{Data: []T11{v11}}
		compound.Components[11].Data = &slice[T12]{Data: []T12{v12}}

		return
	}
	compound.Components[0].Data.(*slice[T1]).append(v1)
	compound.Components[1].Data.(*slice[T2]).append(v2)
	compound.Components[2].Data.(*slice[T3]).append(v3)
	compound.Components[3].Data.(*slice[T4]).append(v4)
	compound.Components[4].Data.(*slice[T5]).append(v5)
	compound.Components[5].Data.(*slice[T6]).append(v6)
	compound.Components[6].Data.(*slice[T7]).append(v7)
	compound.Components[7].Data.(*slice[T8]).append(v8)
	compound.Components[8].Data.(*slice[T9]).append(v9)
	compound.Components[9].Data.(*slice[T10]).append(v10)
	compound.Components[10].Data.(*slice[T11]).append(v11)
	compound.Components[11].Data.(*slice[T12]).append(v12)

}

func Set13[ID Int, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13 any](storage *Storage[ID], id ID, v1 T1, v2 T2, v3 T3, v4 T4, v5 T5, v6 T6, v7 T7, v8 T8, v9 T9, v10 T10, v11 T11, v12 T12, v13 T13) {
	components := []int{storage.componentEnsure(v1), storage.componentEnsure(v2), storage.componentEnsure(v3), storage.componentEnsure(v4), storage.componentEnsure(v5), storage.componentEnsure(v6), storage.componentEnsure(v7), storage.componentEnsure(v8), storage.componentEnsure(v9), storage.componentEnsure(v10), storage.componentEnsure(v11), storage.componentEnsure(v12), storage.componentEnsure(v13)}
	hashes := []int{componentHash(v1), componentHash(v2), componentHash(v3), componentHash(v4), componentHash(v5), componentHash(v6), componentHash(v7), componentHash(v8), componentHash(v9), componentHash(v10), componentHash(v11), componentHash(v12), componentHash(v13)}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.Entitys = append(compound.Entitys, id)
	if compound.Components[0].Data == nil {
		compound.Components[0].Data = &slice[T1]{Data: []T1{v1}}
		compound.Components[1].Data = &slice[T2]{Data: []T2{v2}}
		compound.Components[2].Data = &slice[T3]{Data: []T3{v3}}
		compound.Components[3].Data = &slice[T4]{Data: []T4{v4}}
		compound.Components[4].Data = &slice[T5]{Data: []T5{v5}}
		compound.Components[5].Data = &slice[T6]{Data: []T6{v6}}
		compound.Components[6].Data = &slice[T7]{Data: []T7{v7}}
		compound.Components[7].Data = &slice[T8]{Data: []T8{v8}}
		compound.Components[8].Data = &slice[T9]{Data: []T9{v9}}
		compound.Components[9].Data = &slice[T10]{Data: []T10{v10}}
		compound.Components[10].Data = &slice[T11]{Data: []T11{v11}}
		compound.Components[11].Data = &slice[T12]{Data: []T12{v12}}
		compound.Components[12].Data = &slice[T13]{Data: []T13{v13}}

		return
	}
	compound.Components[0].Data.(*slice[T1]).append(v1)
	compound.Components[1].Data.(*slice[T2]).append(v2)
	compound.Components[2].Data.(*slice[T3]).append(v3)
	compound.Components[3].Data.(*slice[T4]).append(v4)
	compound.Components[4].Data.(*slice[T5]).append(v5)
	compound.Components[5].Data.(*slice[T6]).append(v6)
	compound.Components[6].Data.(*slice[T7]).append(v7)
	compound.Components[7].Data.(*slice[T8]).append(v8)
	compound.Components[8].Data.(*slice[T9]).append(v9)
	compound.Components[9].Data.(*slice[T10]).append(v10)
	compound.Components[10].Data.(*slice[T11]).append(v11)
	compound.Components[11].Data.(*slice[T12]).append(v12)
	compound.Components[12].Data.(*slice[T13]).append(v13)

}

func Set14[ID Int, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14 any](storage *Storage[ID], id ID, v1 T1, v2 T2, v3 T3, v4 T4, v5 T5, v6 T6, v7 T7, v8 T8, v9 T9, v10 T10, v11 T11, v12 T12, v13 T13, v14 T14) {
	components := []int{storage.componentEnsure(v1), storage.componentEnsure(v2), storage.componentEnsure(v3), storage.componentEnsure(v4), storage.componentEnsure(v5), storage.componentEnsure(v6), storage.componentEnsure(v7), storage.componentEnsure(v8), storage.componentEnsure(v9), storage.componentEnsure(v10), storage.componentEnsure(v11), storage.componentEnsure(v12), storage.componentEnsure(v13), storage.componentEnsure(v14)}
	hashes := []int{componentHash(v1), componentHash(v2), componentHash(v3), componentHash(v4), componentHash(v5), componentHash(v6), componentHash(v7), componentHash(v8), componentHash(v9), componentHash(v10), componentHash(v11), componentHash(v12), componentHash(v13), componentHash(v14)}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.Entitys = append(compound.Entitys, id)
	if compound.Components[0].Data == nil {
		compound.Components[0].Data = &slice[T1]{Data: []T1{v1}}
		compound.Components[1].Data = &slice[T2]{Data: []T2{v2}}
		compound.Components[2].Data = &slice[T3]{Data: []T3{v3}}
		compound.Components[3].Data = &slice[T4]{Data: []T4{v4}}
		compound.Components[4].Data = &slice[T5]{Data: []T5{v5}}
		compound.Components[5].Data = &slice[T6]{Data: []T6{v6}}
		compound.Components[6].Data = &slice[T7]{Data: []T7{v7}}
		compound.Components[7].Data = &slice[T8]{Data: []T8{v8}}
		compound.Components[8].Data = &slice[T9]{Data: []T9{v9}}
		compound.Components[9].Data = &slice[T10]{Data: []T10{v10}}
		compound.Components[10].Data = &slice[T11]{Data: []T11{v11}}
		compound.Components[11].Data = &slice[T12]{Data: []T12{v12}}
		compound.Components[12].Data = &slice[T13]{Data: []T13{v13}}
		compound.Components[13].Data = &slice[T14]{Data: []T14{v14}}

		return
	}
	compound.Components[0].Data.(*slice[T1]).append(v1)
	compound.Components[1].Data.(*slice[T2]).append(v2)
	compound.Components[2].Data.(*slice[T3]).append(v3)
	compound.Components[3].Data.(*slice[T4]).append(v4)
	compound.Components[4].Data.(*slice[T5]).append(v5)
	compound.Components[5].Data.(*slice[T6]).append(v6)
	compound.Components[6].Data.(*slice[T7]).append(v7)
	compound.Components[7].Data.(*slice[T8]).append(v8)
	compound.Components[8].Data.(*slice[T9]).append(v9)
	compound.Components[9].Data.(*slice[T10]).append(v10)
	compound.Components[10].Data.(*slice[T11]).append(v11)
	compound.Components[11].Data.(*slice[T12]).append(v12)
	compound.Components[12].Data.(*slice[T13]).append(v13)
	compound.Components[13].Data.(*slice[T14]).append(v14)

}

func Set15[ID Int, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15 any](storage *Storage[ID], id ID, v1 T1, v2 T2, v3 T3, v4 T4, v5 T5, v6 T6, v7 T7, v8 T8, v9 T9, v10 T10, v11 T11, v12 T12, v13 T13, v14 T14, v15 T15) {
	components := []int{storage.componentEnsure(v1), storage.componentEnsure(v2), storage.componentEnsure(v3), storage.componentEnsure(v4), storage.componentEnsure(v5), storage.componentEnsure(v6), storage.componentEnsure(v7), storage.componentEnsure(v8), storage.componentEnsure(v9), storage.componentEnsure(v10), storage.componentEnsure(v11), storage.componentEnsure(v12), storage.componentEnsure(v13), storage.componentEnsure(v14), storage.componentEnsure(v15)}
	hashes := []int{componentHash(v1), componentHash(v2), componentHash(v3), componentHash(v4), componentHash(v5), componentHash(v6), componentHash(v7), componentHash(v8), componentHash(v9), componentHash(v10), componentHash(v11), componentHash(v12), componentHash(v13), componentHash(v14), componentHash(v15)}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.Entitys = append(compound.Entitys, id)
	if compound.Components[0].Data == nil {
		compound.Components[0].Data = &slice[T1]{Data: []T1{v1}}
		compound.Components[1].Data = &slice[T2]{Data: []T2{v2}}
		compound.Components[2].Data = &slice[T3]{Data: []T3{v3}}
		compound.Components[3].Data = &slice[T4]{Data: []T4{v4}}
		compound.Components[4].Data = &slice[T5]{Data: []T5{v5}}
		compound.Components[5].Data = &slice[T6]{Data: []T6{v6}}
		compound.Components[6].Data = &slice[T7]{Data: []T7{v7}}
		compound.Components[7].Data = &slice[T8]{Data: []T8{v8}}
		compound.Components[8].Data = &slice[T9]{Data: []T9{v9}}
		compound.Components[9].Data = &slice[T10]{Data: []T10{v10}}
		compound.Components[10].Data = &slice[T11]{Data: []T11{v11}}
		compound.Components[11].Data = &slice[T12]{Data: []T12{v12}}
		compound.Components[12].Data = &slice[T13]{Data: []T13{v13}}
		compound.Components[13].Data = &slice[T14]{Data: []T14{v14}}
		compound.Components[14].Data = &slice[T15]{Data: []T15{v15}}

		return
	}
	compound.Components[0].Data.(*slice[T1]).append(v1)
	compound.Components[1].Data.(*slice[T2]).append(v2)
	compound.Components[2].Data.(*slice[T3]).append(v3)
	compound.Components[3].Data.(*slice[T4]).append(v4)
	compound.Components[4].Data.(*slice[T5]).append(v5)
	compound.Components[5].Data.(*slice[T6]).append(v6)
	compound.Components[6].Data.(*slice[T7]).append(v7)
	compound.Components[7].Data.(*slice[T8]).append(v8)
	compound.Components[8].Data.(*slice[T9]).append(v9)
	compound.Components[9].Data.(*slice[T10]).append(v10)
	compound.Components[10].Data.(*slice[T11]).append(v11)
	compound.Components[11].Data.(*slice[T12]).append(v12)
	compound.Components[12].Data.(*slice[T13]).append(v13)
	compound.Components[13].Data.(*slice[T14]).append(v14)
	compound.Components[14].Data.(*slice[T15]).append(v15)

}

func Set16[ID Int, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16 any](storage *Storage[ID], id ID, v1 T1, v2 T2, v3 T3, v4 T4, v5 T5, v6 T6, v7 T7, v8 T8, v9 T9, v10 T10, v11 T11, v12 T12, v13 T13, v14 T14, v15 T15, v16 T16) {
	components := []int{storage.componentEnsure(v1), storage.componentEnsure(v2), storage.componentEnsure(v3), storage.componentEnsure(v4), storage.componentEnsure(v5), storage.componentEnsure(v6), storage.componentEnsure(v7), storage.componentEnsure(v8), storage.componentEnsure(v9), storage.componentEnsure(v10), storage.componentEnsure(v11), storage.componentEnsure(v12), storage.componentEnsure(v13), storage.componentEnsure(v14), storage.componentEnsure(v15), storage.componentEnsure(v16)}
	hashes := []int{componentHash(v1), componentHash(v2), componentHash(v3), componentHash(v4), componentHash(v5), componentHash(v6), componentHash(v7), componentHash(v8), componentHash(v9), componentHash(v10), componentHash(v11), componentHash(v12), componentHash(v13), componentHash(v14), componentHash(v15), componentHash(v16)}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.Entitys = append(compound.Entitys, id)
	if compound.Components[0].Data == nil {
		compound.Components[0].Data = &slice[T1]{Data: []T1{v1}}
		compound.Components[1].Data = &slice[T2]{Data: []T2{v2}}
		compound.Components[2].Data = &slice[T3]{Data: []T3{v3}}
		compound.Components[3].Data = &slice[T4]{Data: []T4{v4}}
		compound.Components[4].Data = &slice[T5]{Data: []T5{v5}}
		compound.Components[5].Data = &slice[T6]{Data: []T6{v6}}
		compound.Components[6].Data = &slice[T7]{Data: []T7{v7}}
		compound.Components[7].Data = &slice[T8]{Data: []T8{v8}}
		compound.Components[8].Data = &slice[T9]{Data: []T9{v9}}
		compound.Components[9].Data = &slice[T10]{Data: []T10{v10}}
		compound.Components[10].Data = &slice[T11]{Data: []T11{v11}}
		compound.Components[11].Data = &slice[T12]{Data: []T12{v12}}
		compound.Components[12].Data = &slice[T13]{Data: []T13{v13}}
		compound.Components[13].Data = &slice[T14]{Data: []T14{v14}}
		compound.Components[14].Data = &slice[T15]{Data: []T15{v15}}
		compound.Components[15].Data = &slice[T16]{Data: []T16{v16}}

		return
	}
	compound.Components[0].Data.(*slice[T1]).append(v1)
	compound.Components[1].Data.(*slice[T2]).append(v2)
	compound.Components[2].Data.(*slice[T3]).append(v3)
	compound.Components[3].Data.(*slice[T4]).append(v4)
	compound.Components[4].Data.(*slice[T5]).append(v5)
	compound.Components[5].Data.(*slice[T6]).append(v6)
	compound.Components[6].Data.(*slice[T7]).append(v7)
	compound.Components[7].Data.(*slice[T8]).append(v8)
	compound.Components[8].Data.(*slice[T9]).append(v9)
	compound.Components[9].Data.(*slice[T10]).append(v10)
	compound.Components[10].Data.(*slice[T11]).append(v11)
	compound.Components[11].Data.(*slice[T12]).append(v12)
	compound.Components[12].Data.(*slice[T13]).append(v13)
	compound.Components[13].Data.(*slice[T14]).append(v14)
	compound.Components[14].Data.(*slice[T15]).append(v15)
	compound.Components[15].Data.(*slice[T16]).append(v16)

}

func Set17[ID Int, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17 any](storage *Storage[ID], id ID, v1 T1, v2 T2, v3 T3, v4 T4, v5 T5, v6 T6, v7 T7, v8 T8, v9 T9, v10 T10, v11 T11, v12 T12, v13 T13, v14 T14, v15 T15, v16 T16, v17 T17) {
	components := []int{storage.componentEnsure(v1), storage.componentEnsure(v2), storage.componentEnsure(v3), storage.componentEnsure(v4), storage.componentEnsure(v5), storage.componentEnsure(v6), storage.componentEnsure(v7), storage.componentEnsure(v8), storage.componentEnsure(v9), storage.componentEnsure(v10), storage.componentEnsure(v11), storage.componentEnsure(v12), storage.componentEnsure(v13), storage.componentEnsure(v14), storage.componentEnsure(v15), storage.componentEnsure(v16), storage.componentEnsure(v17)}
	hashes := []int{componentHash(v1), componentHash(v2), componentHash(v3), componentHash(v4), componentHash(v5), componentHash(v6), componentHash(v7), componentHash(v8), componentHash(v9), componentHash(v10), componentHash(v11), componentHash(v12), componentHash(v13), componentHash(v14), componentHash(v15), componentHash(v16), componentHash(v17)}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.Entitys = append(compound.Entitys, id)
	if compound.Components[0].Data == nil {
		compound.Components[0].Data = &slice[T1]{Data: []T1{v1}}
		compound.Components[1].Data = &slice[T2]{Data: []T2{v2}}
		compound.Components[2].Data = &slice[T3]{Data: []T3{v3}}
		compound.Components[3].Data = &slice[T4]{Data: []T4{v4}}
		compound.Components[4].Data = &slice[T5]{Data: []T5{v5}}
		compound.Components[5].Data = &slice[T6]{Data: []T6{v6}}
		compound.Components[6].Data = &slice[T7]{Data: []T7{v7}}
		compound.Components[7].Data = &slice[T8]{Data: []T8{v8}}
		compound.Components[8].Data = &slice[T9]{Data: []T9{v9}}
		compound.Components[9].Data = &slice[T10]{Data: []T10{v10}}
		compound.Components[10].Data = &slice[T11]{Data: []T11{v11}}
		compound.Components[11].Data = &slice[T12]{Data: []T12{v12}}
		compound.Components[12].Data = &slice[T13]{Data: []T13{v13}}
		compound.Components[13].Data = &slice[T14]{Data: []T14{v14}}
		compound.Components[14].Data = &slice[T15]{Data: []T15{v15}}
		compound.Components[15].Data = &slice[T16]{Data: []T16{v16}}
		compound.Components[16].Data = &slice[T17]{Data: []T17{v17}}

		return
	}
	compound.Components[0].Data.(*slice[T1]).append(v1)
	compound.Components[1].Data.(*slice[T2]).append(v2)
	compound.Components[2].Data.(*slice[T3]).append(v3)
	compound.Components[3].Data.(*slice[T4]).append(v4)
	compound.Components[4].Data.(*slice[T5]).append(v5)
	compound.Components[5].Data.(*slice[T6]).append(v6)
	compound.Components[6].Data.(*slice[T7]).append(v7)
	compound.Components[7].Data.(*slice[T8]).append(v8)
	compound.Components[8].Data.(*slice[T9]).append(v9)
	compound.Components[9].Data.(*slice[T10]).append(v10)
	compound.Components[10].Data.(*slice[T11]).append(v11)
	compound.Components[11].Data.(*slice[T12]).append(v12)
	compound.Components[12].Data.(*slice[T13]).append(v13)
	compound.Components[13].Data.(*slice[T14]).append(v14)
	compound.Components[14].Data.(*slice[T15]).append(v15)
	compound.Components[15].Data.(*slice[T16]).append(v16)
	compound.Components[16].Data.(*slice[T17]).append(v17)

}

func Set18[ID Int, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18 any](storage *Storage[ID], id ID, v1 T1, v2 T2, v3 T3, v4 T4, v5 T5, v6 T6, v7 T7, v8 T8, v9 T9, v10 T10, v11 T11, v12 T12, v13 T13, v14 T14, v15 T15, v16 T16, v17 T17, v18 T18) {
	components := []int{storage.componentEnsure(v1), storage.componentEnsure(v2), storage.componentEnsure(v3), storage.componentEnsure(v4), storage.componentEnsure(v5), storage.componentEnsure(v6), storage.componentEnsure(v7), storage.componentEnsure(v8), storage.componentEnsure(v9), storage.componentEnsure(v10), storage.componentEnsure(v11), storage.componentEnsure(v12), storage.componentEnsure(v13), storage.componentEnsure(v14), storage.componentEnsure(v15), storage.componentEnsure(v16), storage.componentEnsure(v17), storage.componentEnsure(v18)}
	hashes := []int{componentHash(v1), componentHash(v2), componentHash(v3), componentHash(v4), componentHash(v5), componentHash(v6), componentHash(v7), componentHash(v8), componentHash(v9), componentHash(v10), componentHash(v11), componentHash(v12), componentHash(v13), componentHash(v14), componentHash(v15), componentHash(v16), componentHash(v17), componentHash(v18)}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.Entitys = append(compound.Entitys, id)
	if compound.Components[0].Data == nil {
		compound.Components[0].Data = &slice[T1]{Data: []T1{v1}}
		compound.Components[1].Data = &slice[T2]{Data: []T2{v2}}
		compound.Components[2].Data = &slice[T3]{Data: []T3{v3}}
		compound.Components[3].Data = &slice[T4]{Data: []T4{v4}}
		compound.Components[4].Data = &slice[T5]{Data: []T5{v5}}
		compound.Components[5].Data = &slice[T6]{Data: []T6{v6}}
		compound.Components[6].Data = &slice[T7]{Data: []T7{v7}}
		compound.Components[7].Data = &slice[T8]{Data: []T8{v8}}
		compound.Components[8].Data = &slice[T9]{Data: []T9{v9}}
		compound.Components[9].Data = &slice[T10]{Data: []T10{v10}}
		compound.Components[10].Data = &slice[T11]{Data: []T11{v11}}
		compound.Components[11].Data = &slice[T12]{Data: []T12{v12}}
		compound.Components[12].Data = &slice[T13]{Data: []T13{v13}}
		compound.Components[13].Data = &slice[T14]{Data: []T14{v14}}
		compound.Components[14].Data = &slice[T15]{Data: []T15{v15}}
		compound.Components[15].Data = &slice[T16]{Data: []T16{v16}}
		compound.Components[16].Data = &slice[T17]{Data: []T17{v17}}
		compound.Components[17].Data = &slice[T18]{Data: []T18{v18}}

		return
	}
	compound.Components[0].Data.(*slice[T1]).append(v1)
	compound.Components[1].Data.(*slice[T2]).append(v2)
	compound.Components[2].Data.(*slice[T3]).append(v3)
	compound.Components[3].Data.(*slice[T4]).append(v4)
	compound.Components[4].Data.(*slice[T5]).append(v5)
	compound.Components[5].Data.(*slice[T6]).append(v6)
	compound.Components[6].Data.(*slice[T7]).append(v7)
	compound.Components[7].Data.(*slice[T8]).append(v8)
	compound.Components[8].Data.(*slice[T9]).append(v9)
	compound.Components[9].Data.(*slice[T10]).append(v10)
	compound.Components[10].Data.(*slice[T11]).append(v11)
	compound.Components[11].Data.(*slice[T12]).append(v12)
	compound.Components[12].Data.(*slice[T13]).append(v13)
	compound.Components[13].Data.(*slice[T14]).append(v14)
	compound.Components[14].Data.(*slice[T15]).append(v15)
	compound.Components[15].Data.(*slice[T16]).append(v16)
	compound.Components[16].Data.(*slice[T17]).append(v17)
	compound.Components[17].Data.(*slice[T18]).append(v18)

}

func Set19[ID Int, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19 any](storage *Storage[ID], id ID, v1 T1, v2 T2, v3 T3, v4 T4, v5 T5, v6 T6, v7 T7, v8 T8, v9 T9, v10 T10, v11 T11, v12 T12, v13 T13, v14 T14, v15 T15, v16 T16, v17 T17, v18 T18, v19 T19) {
	components := []int{storage.componentEnsure(v1), storage.componentEnsure(v2), storage.componentEnsure(v3), storage.componentEnsure(v4), storage.componentEnsure(v5), storage.componentEnsure(v6), storage.componentEnsure(v7), storage.componentEnsure(v8), storage.componentEnsure(v9), storage.componentEnsure(v10), storage.componentEnsure(v11), storage.componentEnsure(v12), storage.componentEnsure(v13), storage.componentEnsure(v14), storage.componentEnsure(v15), storage.componentEnsure(v16), storage.componentEnsure(v17), storage.componentEnsure(v18), storage.componentEnsure(v19)}
	hashes := []int{componentHash(v1), componentHash(v2), componentHash(v3), componentHash(v4), componentHash(v5), componentHash(v6), componentHash(v7), componentHash(v8), componentHash(v9), componentHash(v10), componentHash(v11), componentHash(v12), componentHash(v13), componentHash(v14), componentHash(v15), componentHash(v16), componentHash(v17), componentHash(v18), componentHash(v19)}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.Entitys = append(compound.Entitys, id)
	if compound.Components[0].Data == nil {
		compound.Components[0].Data = &slice[T1]{Data: []T1{v1}}
		compound.Components[1].Data = &slice[T2]{Data: []T2{v2}}
		compound.Components[2].Data = &slice[T3]{Data: []T3{v3}}
		compound.Components[3].Data = &slice[T4]{Data: []T4{v4}}
		compound.Components[4].Data = &slice[T5]{Data: []T5{v5}}
		compound.Components[5].Data = &slice[T6]{Data: []T6{v6}}
		compound.Components[6].Data = &slice[T7]{Data: []T7{v7}}
		compound.Components[7].Data = &slice[T8]{Data: []T8{v8}}
		compound.Components[8].Data = &slice[T9]{Data: []T9{v9}}
		compound.Components[9].Data = &slice[T10]{Data: []T10{v10}}
		compound.Components[10].Data = &slice[T11]{Data: []T11{v11}}
		compound.Components[11].Data = &slice[T12]{Data: []T12{v12}}
		compound.Components[12].Data = &slice[T13]{Data: []T13{v13}}
		compound.Components[13].Data = &slice[T14]{Data: []T14{v14}}
		compound.Components[14].Data = &slice[T15]{Data: []T15{v15}}
		compound.Components[15].Data = &slice[T16]{Data: []T16{v16}}
		compound.Components[16].Data = &slice[T17]{Data: []T17{v17}}
		compound.Components[17].Data = &slice[T18]{Data: []T18{v18}}
		compound.Components[18].Data = &slice[T19]{Data: []T19{v19}}

		return
	}
	compound.Components[0].Data.(*slice[T1]).append(v1)
	compound.Components[1].Data.(*slice[T2]).append(v2)
	compound.Components[2].Data.(*slice[T3]).append(v3)
	compound.Components[3].Data.(*slice[T4]).append(v4)
	compound.Components[4].Data.(*slice[T5]).append(v5)
	compound.Components[5].Data.(*slice[T6]).append(v6)
	compound.Components[6].Data.(*slice[T7]).append(v7)
	compound.Components[7].Data.(*slice[T8]).append(v8)
	compound.Components[8].Data.(*slice[T9]).append(v9)
	compound.Components[9].Data.(*slice[T10]).append(v10)
	compound.Components[10].Data.(*slice[T11]).append(v11)
	compound.Components[11].Data.(*slice[T12]).append(v12)
	compound.Components[12].Data.(*slice[T13]).append(v13)
	compound.Components[13].Data.(*slice[T14]).append(v14)
	compound.Components[14].Data.(*slice[T15]).append(v15)
	compound.Components[15].Data.(*slice[T16]).append(v16)
	compound.Components[16].Data.(*slice[T17]).append(v17)
	compound.Components[17].Data.(*slice[T18]).append(v18)
	compound.Components[18].Data.(*slice[T19]).append(v19)

}

func Set20[ID Int, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20 any](storage *Storage[ID], id ID, v1 T1, v2 T2, v3 T3, v4 T4, v5 T5, v6 T6, v7 T7, v8 T8, v9 T9, v10 T10, v11 T11, v12 T12, v13 T13, v14 T14, v15 T15, v16 T16, v17 T17, v18 T18, v19 T19, v20 T20) {
	components := []int{storage.componentEnsure(v1), storage.componentEnsure(v2), storage.componentEnsure(v3), storage.componentEnsure(v4), storage.componentEnsure(v5), storage.componentEnsure(v6), storage.componentEnsure(v7), storage.componentEnsure(v8), storage.componentEnsure(v9), storage.componentEnsure(v10), storage.componentEnsure(v11), storage.componentEnsure(v12), storage.componentEnsure(v13), storage.componentEnsure(v14), storage.componentEnsure(v15), storage.componentEnsure(v16), storage.componentEnsure(v17), storage.componentEnsure(v18), storage.componentEnsure(v19), storage.componentEnsure(v20)}
	hashes := []int{componentHash(v1), componentHash(v2), componentHash(v3), componentHash(v4), componentHash(v5), componentHash(v6), componentHash(v7), componentHash(v8), componentHash(v9), componentHash(v10), componentHash(v11), componentHash(v12), componentHash(v13), componentHash(v14), componentHash(v15), componentHash(v16), componentHash(v17), componentHash(v18), componentHash(v19), componentHash(v20)}
	entity := Entity{Compound: storage.compoundEnsure(components, hashes)}
	storage.Entitys[id] = entity
	compound := storage.Compounds[entity.Compound]
	compound.Entitys = append(compound.Entitys, id)
	if compound.Components[0].Data == nil {
		compound.Components[0].Data = &slice[T1]{Data: []T1{v1}}
		compound.Components[1].Data = &slice[T2]{Data: []T2{v2}}
		compound.Components[2].Data = &slice[T3]{Data: []T3{v3}}
		compound.Components[3].Data = &slice[T4]{Data: []T4{v4}}
		compound.Components[4].Data = &slice[T5]{Data: []T5{v5}}
		compound.Components[5].Data = &slice[T6]{Data: []T6{v6}}
		compound.Components[6].Data = &slice[T7]{Data: []T7{v7}}
		compound.Components[7].Data = &slice[T8]{Data: []T8{v8}}
		compound.Components[8].Data = &slice[T9]{Data: []T9{v9}}
		compound.Components[9].Data = &slice[T10]{Data: []T10{v10}}
		compound.Components[10].Data = &slice[T11]{Data: []T11{v11}}
		compound.Components[11].Data = &slice[T12]{Data: []T12{v12}}
		compound.Components[12].Data = &slice[T13]{Data: []T13{v13}}
		compound.Components[13].Data = &slice[T14]{Data: []T14{v14}}
		compound.Components[14].Data = &slice[T15]{Data: []T15{v15}}
		compound.Components[15].Data = &slice[T16]{Data: []T16{v16}}
		compound.Components[16].Data = &slice[T17]{Data: []T17{v17}}
		compound.Components[17].Data = &slice[T18]{Data: []T18{v18}}
		compound.Components[18].Data = &slice[T19]{Data: []T19{v19}}
		compound.Components[19].Data = &slice[T20]{Data: []T20{v20}}

		return
	}
	compound.Components[0].Data.(*slice[T1]).append(v1)
	compound.Components[1].Data.(*slice[T2]).append(v2)
	compound.Components[2].Data.(*slice[T3]).append(v3)
	compound.Components[3].Data.(*slice[T4]).append(v4)
	compound.Components[4].Data.(*slice[T5]).append(v5)
	compound.Components[5].Data.(*slice[T6]).append(v6)
	compound.Components[6].Data.(*slice[T7]).append(v7)
	compound.Components[7].Data.(*slice[T8]).append(v8)
	compound.Components[8].Data.(*slice[T9]).append(v9)
	compound.Components[9].Data.(*slice[T10]).append(v10)
	compound.Components[10].Data.(*slice[T11]).append(v11)
	compound.Components[11].Data.(*slice[T12]).append(v12)
	compound.Components[12].Data.(*slice[T13]).append(v13)
	compound.Components[13].Data.(*slice[T14]).append(v14)
	compound.Components[14].Data.(*slice[T15]).append(v15)
	compound.Components[15].Data.(*slice[T16]).append(v16)
	compound.Components[16].Data.(*slice[T17]).append(v17)
	compound.Components[17].Data.(*slice[T18]).append(v18)
	compound.Components[18].Data.(*slice[T19]).append(v19)
	compound.Components[19].Data.(*slice[T20]).append(v20)

}

type Q1[ID Int, T1 any] struct {
	storage    *Storage[ID]
	Components [1]int
	Errors     []error
}
type Q1Option struct {
	Optional [1]bool
	Stop     *bool
	Hash     *ComponentHash
}
type Q2[ID Int, T1 any, T2 any] struct {
	storage    *Storage[ID]
	Components [2]int
	Errors     []error
}
type Q2Option struct {
	Optional [2]bool
	Stop     *bool
	Hash     *ComponentHash
}
type Q3[ID Int, T1 any, T2 any, T3 any] struct {
	storage    *Storage[ID]
	Components [3]int
	Errors     []error
}
type Q3Option struct {
	Optional [3]bool
	Stop     *bool
	Hash     *ComponentHash
}
type Q4[ID Int, T1 any, T2 any, T3 any, T4 any] struct {
	storage    *Storage[ID]
	Components [4]int
	Errors     []error
}
type Q4Option struct {
	Optional [4]bool
	Stop     *bool
	Hash     *ComponentHash
}
type Q5[ID Int, T1 any, T2 any, T3 any, T4 any, T5 any] struct {
	storage    *Storage[ID]
	Components [5]int
	Errors     []error
}
type Q5Option struct {
	Optional [5]bool
	Stop     *bool
	Hash     *ComponentHash
}
type Q6[ID Int, T1 any, T2 any, T3 any, T4 any, T5 any, T6 any] struct {
	storage    *Storage[ID]
	Components [6]int
	Errors     []error
}
type Q6Option struct {
	Optional [6]bool
	Stop     *bool
	Hash     *ComponentHash
}
type Q7[ID Int, T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any] struct {
	storage    *Storage[ID]
	Components [7]int
	Errors     []error
}
type Q7Option struct {
	Optional [7]bool
	Stop     *bool
	Hash     *ComponentHash
}
type Q8[ID Int, T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any] struct {
	storage    *Storage[ID]
	Components [8]int
	Errors     []error
}
type Q8Option struct {
	Optional [8]bool
	Stop     *bool
	Hash     *ComponentHash
}
type Q9[ID Int, T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any] struct {
	storage    *Storage[ID]
	Components [9]int
	Errors     []error
}
type Q9Option struct {
	Optional [9]bool
	Stop     *bool
	Hash     *ComponentHash
}
type Q10[ID Int, T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any] struct {
	storage    *Storage[ID]
	Components [10]int
	Errors     []error
}
type Q10Option struct {
	Optional [10]bool
	Stop     *bool
	Hash     *ComponentHash
}
type Q11[ID Int, T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any] struct {
	storage    *Storage[ID]
	Components [11]int
	Errors     []error
}
type Q11Option struct {
	Optional [11]bool
	Stop     *bool
	Hash     *ComponentHash
}
type Q12[ID Int, T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any] struct {
	storage    *Storage[ID]
	Components [12]int
	Errors     []error
}
type Q12Option struct {
	Optional [12]bool
	Stop     *bool
	Hash     *ComponentHash
}
type Q13[ID Int, T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any] struct {
	storage    *Storage[ID]
	Components [13]int
	Errors     []error
}
type Q13Option struct {
	Optional [13]bool
	Stop     *bool
	Hash     *ComponentHash
}
type Q14[ID Int, T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any] struct {
	storage    *Storage[ID]
	Components [14]int
	Errors     []error
}
type Q14Option struct {
	Optional [14]bool
	Stop     *bool
	Hash     *ComponentHash
}
type Q15[ID Int, T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, T15 any] struct {
	storage    *Storage[ID]
	Components [15]int
	Errors     []error
}
type Q15Option struct {
	Optional [15]bool
	Stop     *bool
	Hash     *ComponentHash
}
type Q16[ID Int, T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, T15 any, T16 any] struct {
	storage    *Storage[ID]
	Components [16]int
	Errors     []error
}
type Q16Option struct {
	Optional [16]bool
	Stop     *bool
	Hash     *ComponentHash
}
type Q17[ID Int, T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, T15 any, T16 any, T17 any] struct {
	storage    *Storage[ID]
	Components [17]int
	Errors     []error
}
type Q17Option struct {
	Optional [17]bool
	Stop     *bool
	Hash     *ComponentHash
}
type Q18[ID Int, T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, T15 any, T16 any, T17 any, T18 any] struct {
	storage    *Storage[ID]
	Components [18]int
	Errors     []error
}
type Q18Option struct {
	Optional [18]bool
	Stop     *bool
	Hash     *ComponentHash
}
type Q19[ID Int, T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, T15 any, T16 any, T17 any, T18 any, T19 any] struct {
	storage    *Storage[ID]
	Components [19]int
	Errors     []error
}
type Q19Option struct {
	Optional [19]bool
	Stop     *bool
	Hash     *ComponentHash
}
type Q20[ID Int, T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, T15 any, T16 any, T17 any, T18 any, T19 any, T20 any] struct {
	storage    *Storage[ID]
	Components [20]int
	Errors     []error
}
type Q20Option struct {
	Optional [20]bool
	Stop     *bool
	Hash     *ComponentHash
}

func Query1[T1 any, ID Int](storage *Storage[ID]) *Q1[ID, T1] {
	q := &Q1[ID, T1]{storage: storage}
	{
		name := typeName[T1]()
		id, ok := storage.getComponent(name)
		q.Components[0] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 1 \"%s\" does not exist", name))
		}
	}
	return q
}

func Query2[T1 any, T2 any, ID Int](storage *Storage[ID]) *Q2[ID, T1, T2] {
	q := &Q2[ID, T1, T2]{storage: storage}
	{
		name := typeName[T1]()
		id, ok := storage.getComponent(name)
		q.Components[0] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 1 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T2]()
		id, ok := storage.getComponent(name)
		q.Components[1] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 2 \"%s\" does not exist", name))
		}
	}
	return q
}

func Query3[T1 any, T2 any, T3 any, ID Int](storage *Storage[ID]) *Q3[ID, T1, T2, T3] {
	q := &Q3[ID, T1, T2, T3]{storage: storage}
	{
		name := typeName[T1]()
		id, ok := storage.getComponent(name)
		q.Components[0] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 1 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T2]()
		id, ok := storage.getComponent(name)
		q.Components[1] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 2 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T3]()
		id, ok := storage.getComponent(name)
		q.Components[2] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 3 \"%s\" does not exist", name))
		}
	}
	return q
}

func Query4[T1 any, T2 any, T3 any, T4 any, ID Int](storage *Storage[ID]) *Q4[ID, T1, T2, T3, T4] {
	q := &Q4[ID, T1, T2, T3, T4]{storage: storage}
	{
		name := typeName[T1]()
		id, ok := storage.getComponent(name)
		q.Components[0] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 1 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T2]()
		id, ok := storage.getComponent(name)
		q.Components[1] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 2 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T3]()
		id, ok := storage.getComponent(name)
		q.Components[2] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 3 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T4]()
		id, ok := storage.getComponent(name)
		q.Components[3] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 4 \"%s\" does not exist", name))
		}
	}
	return q
}

func Query5[T1 any, T2 any, T3 any, T4 any, T5 any, ID Int](storage *Storage[ID]) *Q5[ID, T1, T2, T3, T4, T5] {
	q := &Q5[ID, T1, T2, T3, T4, T5]{storage: storage}
	{
		name := typeName[T1]()
		id, ok := storage.getComponent(name)
		q.Components[0] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 1 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T2]()
		id, ok := storage.getComponent(name)
		q.Components[1] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 2 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T3]()
		id, ok := storage.getComponent(name)
		q.Components[2] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 3 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T4]()
		id, ok := storage.getComponent(name)
		q.Components[3] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 4 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T5]()
		id, ok := storage.getComponent(name)
		q.Components[4] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 5 \"%s\" does not exist", name))
		}
	}
	return q
}

func Query6[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, ID Int](storage *Storage[ID]) *Q6[ID, T1, T2, T3, T4, T5, T6] {
	q := &Q6[ID, T1, T2, T3, T4, T5, T6]{storage: storage}
	{
		name := typeName[T1]()
		id, ok := storage.getComponent(name)
		q.Components[0] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 1 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T2]()
		id, ok := storage.getComponent(name)
		q.Components[1] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 2 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T3]()
		id, ok := storage.getComponent(name)
		q.Components[2] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 3 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T4]()
		id, ok := storage.getComponent(name)
		q.Components[3] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 4 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T5]()
		id, ok := storage.getComponent(name)
		q.Components[4] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 5 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T6]()
		id, ok := storage.getComponent(name)
		q.Components[5] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 6 \"%s\" does not exist", name))
		}
	}
	return q
}

func Query7[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, ID Int](storage *Storage[ID]) *Q7[ID, T1, T2, T3, T4, T5, T6, T7] {
	q := &Q7[ID, T1, T2, T3, T4, T5, T6, T7]{storage: storage}
	{
		name := typeName[T1]()
		id, ok := storage.getComponent(name)
		q.Components[0] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 1 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T2]()
		id, ok := storage.getComponent(name)
		q.Components[1] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 2 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T3]()
		id, ok := storage.getComponent(name)
		q.Components[2] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 3 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T4]()
		id, ok := storage.getComponent(name)
		q.Components[3] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 4 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T5]()
		id, ok := storage.getComponent(name)
		q.Components[4] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 5 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T6]()
		id, ok := storage.getComponent(name)
		q.Components[5] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 6 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T7]()
		id, ok := storage.getComponent(name)
		q.Components[6] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 7 \"%s\" does not exist", name))
		}
	}
	return q
}

func Query8[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, ID Int](storage *Storage[ID]) *Q8[ID, T1, T2, T3, T4, T5, T6, T7, T8] {
	q := &Q8[ID, T1, T2, T3, T4, T5, T6, T7, T8]{storage: storage}
	{
		name := typeName[T1]()
		id, ok := storage.getComponent(name)
		q.Components[0] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 1 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T2]()
		id, ok := storage.getComponent(name)
		q.Components[1] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 2 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T3]()
		id, ok := storage.getComponent(name)
		q.Components[2] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 3 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T4]()
		id, ok := storage.getComponent(name)
		q.Components[3] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 4 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T5]()
		id, ok := storage.getComponent(name)
		q.Components[4] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 5 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T6]()
		id, ok := storage.getComponent(name)
		q.Components[5] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 6 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T7]()
		id, ok := storage.getComponent(name)
		q.Components[6] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 7 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T8]()
		id, ok := storage.getComponent(name)
		q.Components[7] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 8 \"%s\" does not exist", name))
		}
	}
	return q
}

func Query9[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, ID Int](storage *Storage[ID]) *Q9[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9] {
	q := &Q9[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9]{storage: storage}
	{
		name := typeName[T1]()
		id, ok := storage.getComponent(name)
		q.Components[0] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 1 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T2]()
		id, ok := storage.getComponent(name)
		q.Components[1] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 2 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T3]()
		id, ok := storage.getComponent(name)
		q.Components[2] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 3 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T4]()
		id, ok := storage.getComponent(name)
		q.Components[3] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 4 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T5]()
		id, ok := storage.getComponent(name)
		q.Components[4] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 5 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T6]()
		id, ok := storage.getComponent(name)
		q.Components[5] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 6 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T7]()
		id, ok := storage.getComponent(name)
		q.Components[6] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 7 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T8]()
		id, ok := storage.getComponent(name)
		q.Components[7] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 8 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T9]()
		id, ok := storage.getComponent(name)
		q.Components[8] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 9 \"%s\" does not exist", name))
		}
	}
	return q
}

func Query10[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, ID Int](storage *Storage[ID]) *Q10[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10] {
	q := &Q10[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]{storage: storage}
	{
		name := typeName[T1]()
		id, ok := storage.getComponent(name)
		q.Components[0] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 1 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T2]()
		id, ok := storage.getComponent(name)
		q.Components[1] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 2 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T3]()
		id, ok := storage.getComponent(name)
		q.Components[2] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 3 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T4]()
		id, ok := storage.getComponent(name)
		q.Components[3] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 4 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T5]()
		id, ok := storage.getComponent(name)
		q.Components[4] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 5 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T6]()
		id, ok := storage.getComponent(name)
		q.Components[5] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 6 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T7]()
		id, ok := storage.getComponent(name)
		q.Components[6] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 7 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T8]()
		id, ok := storage.getComponent(name)
		q.Components[7] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 8 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T9]()
		id, ok := storage.getComponent(name)
		q.Components[8] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 9 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T10]()
		id, ok := storage.getComponent(name)
		q.Components[9] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 10 \"%s\" does not exist", name))
		}
	}
	return q
}

func Query11[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, ID Int](storage *Storage[ID]) *Q11[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11] {
	q := &Q11[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11]{storage: storage}
	{
		name := typeName[T1]()
		id, ok := storage.getComponent(name)
		q.Components[0] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 1 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T2]()
		id, ok := storage.getComponent(name)
		q.Components[1] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 2 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T3]()
		id, ok := storage.getComponent(name)
		q.Components[2] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 3 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T4]()
		id, ok := storage.getComponent(name)
		q.Components[3] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 4 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T5]()
		id, ok := storage.getComponent(name)
		q.Components[4] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 5 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T6]()
		id, ok := storage.getComponent(name)
		q.Components[5] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 6 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T7]()
		id, ok := storage.getComponent(name)
		q.Components[6] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 7 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T8]()
		id, ok := storage.getComponent(name)
		q.Components[7] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 8 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T9]()
		id, ok := storage.getComponent(name)
		q.Components[8] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 9 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T10]()
		id, ok := storage.getComponent(name)
		q.Components[9] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 10 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T11]()
		id, ok := storage.getComponent(name)
		q.Components[10] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 11 \"%s\" does not exist", name))
		}
	}
	return q
}

func Query12[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, ID Int](storage *Storage[ID]) *Q12[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12] {
	q := &Q12[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12]{storage: storage}
	{
		name := typeName[T1]()
		id, ok := storage.getComponent(name)
		q.Components[0] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 1 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T2]()
		id, ok := storage.getComponent(name)
		q.Components[1] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 2 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T3]()
		id, ok := storage.getComponent(name)
		q.Components[2] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 3 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T4]()
		id, ok := storage.getComponent(name)
		q.Components[3] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 4 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T5]()
		id, ok := storage.getComponent(name)
		q.Components[4] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 5 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T6]()
		id, ok := storage.getComponent(name)
		q.Components[5] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 6 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T7]()
		id, ok := storage.getComponent(name)
		q.Components[6] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 7 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T8]()
		id, ok := storage.getComponent(name)
		q.Components[7] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 8 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T9]()
		id, ok := storage.getComponent(name)
		q.Components[8] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 9 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T10]()
		id, ok := storage.getComponent(name)
		q.Components[9] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 10 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T11]()
		id, ok := storage.getComponent(name)
		q.Components[10] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 11 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T12]()
		id, ok := storage.getComponent(name)
		q.Components[11] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 12 \"%s\" does not exist", name))
		}
	}
	return q
}

func Query13[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, ID Int](storage *Storage[ID]) *Q13[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13] {
	q := &Q13[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13]{storage: storage}
	{
		name := typeName[T1]()
		id, ok := storage.getComponent(name)
		q.Components[0] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 1 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T2]()
		id, ok := storage.getComponent(name)
		q.Components[1] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 2 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T3]()
		id, ok := storage.getComponent(name)
		q.Components[2] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 3 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T4]()
		id, ok := storage.getComponent(name)
		q.Components[3] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 4 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T5]()
		id, ok := storage.getComponent(name)
		q.Components[4] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 5 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T6]()
		id, ok := storage.getComponent(name)
		q.Components[5] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 6 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T7]()
		id, ok := storage.getComponent(name)
		q.Components[6] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 7 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T8]()
		id, ok := storage.getComponent(name)
		q.Components[7] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 8 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T9]()
		id, ok := storage.getComponent(name)
		q.Components[8] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 9 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T10]()
		id, ok := storage.getComponent(name)
		q.Components[9] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 10 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T11]()
		id, ok := storage.getComponent(name)
		q.Components[10] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 11 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T12]()
		id, ok := storage.getComponent(name)
		q.Components[11] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 12 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T13]()
		id, ok := storage.getComponent(name)
		q.Components[12] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 13 \"%s\" does not exist", name))
		}
	}
	return q
}

func Query14[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, ID Int](storage *Storage[ID]) *Q14[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14] {
	q := &Q14[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14]{storage: storage}
	{
		name := typeName[T1]()
		id, ok := storage.getComponent(name)
		q.Components[0] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 1 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T2]()
		id, ok := storage.getComponent(name)
		q.Components[1] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 2 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T3]()
		id, ok := storage.getComponent(name)
		q.Components[2] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 3 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T4]()
		id, ok := storage.getComponent(name)
		q.Components[3] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 4 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T5]()
		id, ok := storage.getComponent(name)
		q.Components[4] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 5 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T6]()
		id, ok := storage.getComponent(name)
		q.Components[5] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 6 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T7]()
		id, ok := storage.getComponent(name)
		q.Components[6] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 7 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T8]()
		id, ok := storage.getComponent(name)
		q.Components[7] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 8 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T9]()
		id, ok := storage.getComponent(name)
		q.Components[8] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 9 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T10]()
		id, ok := storage.getComponent(name)
		q.Components[9] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 10 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T11]()
		id, ok := storage.getComponent(name)
		q.Components[10] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 11 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T12]()
		id, ok := storage.getComponent(name)
		q.Components[11] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 12 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T13]()
		id, ok := storage.getComponent(name)
		q.Components[12] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 13 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T14]()
		id, ok := storage.getComponent(name)
		q.Components[13] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 14 \"%s\" does not exist", name))
		}
	}
	return q
}

func Query15[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, T15 any, ID Int](storage *Storage[ID]) *Q15[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15] {
	q := &Q15[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15]{storage: storage}
	{
		name := typeName[T1]()
		id, ok := storage.getComponent(name)
		q.Components[0] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 1 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T2]()
		id, ok := storage.getComponent(name)
		q.Components[1] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 2 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T3]()
		id, ok := storage.getComponent(name)
		q.Components[2] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 3 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T4]()
		id, ok := storage.getComponent(name)
		q.Components[3] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 4 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T5]()
		id, ok := storage.getComponent(name)
		q.Components[4] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 5 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T6]()
		id, ok := storage.getComponent(name)
		q.Components[5] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 6 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T7]()
		id, ok := storage.getComponent(name)
		q.Components[6] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 7 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T8]()
		id, ok := storage.getComponent(name)
		q.Components[7] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 8 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T9]()
		id, ok := storage.getComponent(name)
		q.Components[8] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 9 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T10]()
		id, ok := storage.getComponent(name)
		q.Components[9] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 10 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T11]()
		id, ok := storage.getComponent(name)
		q.Components[10] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 11 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T12]()
		id, ok := storage.getComponent(name)
		q.Components[11] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 12 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T13]()
		id, ok := storage.getComponent(name)
		q.Components[12] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 13 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T14]()
		id, ok := storage.getComponent(name)
		q.Components[13] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 14 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T15]()
		id, ok := storage.getComponent(name)
		q.Components[14] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 15 \"%s\" does not exist", name))
		}
	}
	return q
}

func Query16[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, T15 any, T16 any, ID Int](storage *Storage[ID]) *Q16[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16] {
	q := &Q16[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16]{storage: storage}
	{
		name := typeName[T1]()
		id, ok := storage.getComponent(name)
		q.Components[0] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 1 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T2]()
		id, ok := storage.getComponent(name)
		q.Components[1] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 2 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T3]()
		id, ok := storage.getComponent(name)
		q.Components[2] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 3 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T4]()
		id, ok := storage.getComponent(name)
		q.Components[3] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 4 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T5]()
		id, ok := storage.getComponent(name)
		q.Components[4] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 5 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T6]()
		id, ok := storage.getComponent(name)
		q.Components[5] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 6 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T7]()
		id, ok := storage.getComponent(name)
		q.Components[6] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 7 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T8]()
		id, ok := storage.getComponent(name)
		q.Components[7] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 8 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T9]()
		id, ok := storage.getComponent(name)
		q.Components[8] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 9 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T10]()
		id, ok := storage.getComponent(name)
		q.Components[9] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 10 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T11]()
		id, ok := storage.getComponent(name)
		q.Components[10] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 11 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T12]()
		id, ok := storage.getComponent(name)
		q.Components[11] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 12 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T13]()
		id, ok := storage.getComponent(name)
		q.Components[12] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 13 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T14]()
		id, ok := storage.getComponent(name)
		q.Components[13] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 14 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T15]()
		id, ok := storage.getComponent(name)
		q.Components[14] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 15 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T16]()
		id, ok := storage.getComponent(name)
		q.Components[15] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 16 \"%s\" does not exist", name))
		}
	}
	return q
}

func Query17[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, T15 any, T16 any, T17 any, ID Int](storage *Storage[ID]) *Q17[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17] {
	q := &Q17[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17]{storage: storage}
	{
		name := typeName[T1]()
		id, ok := storage.getComponent(name)
		q.Components[0] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 1 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T2]()
		id, ok := storage.getComponent(name)
		q.Components[1] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 2 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T3]()
		id, ok := storage.getComponent(name)
		q.Components[2] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 3 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T4]()
		id, ok := storage.getComponent(name)
		q.Components[3] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 4 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T5]()
		id, ok := storage.getComponent(name)
		q.Components[4] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 5 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T6]()
		id, ok := storage.getComponent(name)
		q.Components[5] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 6 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T7]()
		id, ok := storage.getComponent(name)
		q.Components[6] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 7 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T8]()
		id, ok := storage.getComponent(name)
		q.Components[7] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 8 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T9]()
		id, ok := storage.getComponent(name)
		q.Components[8] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 9 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T10]()
		id, ok := storage.getComponent(name)
		q.Components[9] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 10 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T11]()
		id, ok := storage.getComponent(name)
		q.Components[10] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 11 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T12]()
		id, ok := storage.getComponent(name)
		q.Components[11] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 12 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T13]()
		id, ok := storage.getComponent(name)
		q.Components[12] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 13 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T14]()
		id, ok := storage.getComponent(name)
		q.Components[13] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 14 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T15]()
		id, ok := storage.getComponent(name)
		q.Components[14] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 15 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T16]()
		id, ok := storage.getComponent(name)
		q.Components[15] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 16 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T17]()
		id, ok := storage.getComponent(name)
		q.Components[16] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 17 \"%s\" does not exist", name))
		}
	}
	return q
}

func Query18[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, T15 any, T16 any, T17 any, T18 any, ID Int](storage *Storage[ID]) *Q18[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18] {
	q := &Q18[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18]{storage: storage}
	{
		name := typeName[T1]()
		id, ok := storage.getComponent(name)
		q.Components[0] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 1 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T2]()
		id, ok := storage.getComponent(name)
		q.Components[1] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 2 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T3]()
		id, ok := storage.getComponent(name)
		q.Components[2] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 3 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T4]()
		id, ok := storage.getComponent(name)
		q.Components[3] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 4 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T5]()
		id, ok := storage.getComponent(name)
		q.Components[4] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 5 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T6]()
		id, ok := storage.getComponent(name)
		q.Components[5] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 6 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T7]()
		id, ok := storage.getComponent(name)
		q.Components[6] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 7 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T8]()
		id, ok := storage.getComponent(name)
		q.Components[7] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 8 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T9]()
		id, ok := storage.getComponent(name)
		q.Components[8] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 9 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T10]()
		id, ok := storage.getComponent(name)
		q.Components[9] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 10 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T11]()
		id, ok := storage.getComponent(name)
		q.Components[10] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 11 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T12]()
		id, ok := storage.getComponent(name)
		q.Components[11] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 12 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T13]()
		id, ok := storage.getComponent(name)
		q.Components[12] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 13 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T14]()
		id, ok := storage.getComponent(name)
		q.Components[13] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 14 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T15]()
		id, ok := storage.getComponent(name)
		q.Components[14] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 15 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T16]()
		id, ok := storage.getComponent(name)
		q.Components[15] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 16 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T17]()
		id, ok := storage.getComponent(name)
		q.Components[16] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 17 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T18]()
		id, ok := storage.getComponent(name)
		q.Components[17] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 18 \"%s\" does not exist", name))
		}
	}
	return q
}

func Query19[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, T15 any, T16 any, T17 any, T18 any, T19 any, ID Int](storage *Storage[ID]) *Q19[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19] {
	q := &Q19[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19]{storage: storage}
	{
		name := typeName[T1]()
		id, ok := storage.getComponent(name)
		q.Components[0] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 1 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T2]()
		id, ok := storage.getComponent(name)
		q.Components[1] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 2 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T3]()
		id, ok := storage.getComponent(name)
		q.Components[2] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 3 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T4]()
		id, ok := storage.getComponent(name)
		q.Components[3] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 4 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T5]()
		id, ok := storage.getComponent(name)
		q.Components[4] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 5 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T6]()
		id, ok := storage.getComponent(name)
		q.Components[5] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 6 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T7]()
		id, ok := storage.getComponent(name)
		q.Components[6] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 7 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T8]()
		id, ok := storage.getComponent(name)
		q.Components[7] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 8 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T9]()
		id, ok := storage.getComponent(name)
		q.Components[8] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 9 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T10]()
		id, ok := storage.getComponent(name)
		q.Components[9] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 10 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T11]()
		id, ok := storage.getComponent(name)
		q.Components[10] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 11 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T12]()
		id, ok := storage.getComponent(name)
		q.Components[11] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 12 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T13]()
		id, ok := storage.getComponent(name)
		q.Components[12] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 13 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T14]()
		id, ok := storage.getComponent(name)
		q.Components[13] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 14 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T15]()
		id, ok := storage.getComponent(name)
		q.Components[14] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 15 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T16]()
		id, ok := storage.getComponent(name)
		q.Components[15] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 16 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T17]()
		id, ok := storage.getComponent(name)
		q.Components[16] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 17 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T18]()
		id, ok := storage.getComponent(name)
		q.Components[17] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 18 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T19]()
		id, ok := storage.getComponent(name)
		q.Components[18] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 19 \"%s\" does not exist", name))
		}
	}
	return q
}

func Query20[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, T15 any, T16 any, T17 any, T18 any, T19 any, T20 any, ID Int](storage *Storage[ID]) *Q20[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20] {
	q := &Q20[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20]{storage: storage}
	{
		name := typeName[T1]()
		id, ok := storage.getComponent(name)
		q.Components[0] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 1 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T2]()
		id, ok := storage.getComponent(name)
		q.Components[1] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 2 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T3]()
		id, ok := storage.getComponent(name)
		q.Components[2] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 3 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T4]()
		id, ok := storage.getComponent(name)
		q.Components[3] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 4 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T5]()
		id, ok := storage.getComponent(name)
		q.Components[4] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 5 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T6]()
		id, ok := storage.getComponent(name)
		q.Components[5] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 6 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T7]()
		id, ok := storage.getComponent(name)
		q.Components[6] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 7 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T8]()
		id, ok := storage.getComponent(name)
		q.Components[7] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 8 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T9]()
		id, ok := storage.getComponent(name)
		q.Components[8] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 9 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T10]()
		id, ok := storage.getComponent(name)
		q.Components[9] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 10 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T11]()
		id, ok := storage.getComponent(name)
		q.Components[10] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 11 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T12]()
		id, ok := storage.getComponent(name)
		q.Components[11] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 12 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T13]()
		id, ok := storage.getComponent(name)
		q.Components[12] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 13 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T14]()
		id, ok := storage.getComponent(name)
		q.Components[13] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 14 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T15]()
		id, ok := storage.getComponent(name)
		q.Components[14] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 15 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T16]()
		id, ok := storage.getComponent(name)
		q.Components[15] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 16 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T17]()
		id, ok := storage.getComponent(name)
		q.Components[16] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 17 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T18]()
		id, ok := storage.getComponent(name)
		q.Components[17] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 18 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T19]()
		id, ok := storage.getComponent(name)
		q.Components[18] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 19 \"%s\" does not exist", name))
		}
	}
	{
		name := typeName[T20]()
		id, ok := storage.getComponent(name)
		q.Components[19] = id
		if !ok {
			q.Errors = append(q.Errors, fmt.Errorf("component 20 \"%s\" does not exist", name))
		}
	}
	return q
}

func (q *Q1[ID, T1]) Each(fn func(ID, *T1), queryOptions ...Q1Option) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q1Option
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
LOOP:
	for id, compound := range q.storage.Compounds {
		var v1s []T1

		for _, component := range compound.Components {
			if options.Hash != nil && component.ID == options.Hash.ID && component.Hash != options.Hash.Hash {
				continue LOOP
			}
			if component.ID == q.Components[0] {
				v1s = component.Data.(*slice[T1]).Data
				continue
			}

		}
		if v1s == nil && !options.Optional[0] {
			continue
		}

		if compound.EntitysRemoved != nil {
			total := len(compound.EntitysRemoved)
			if total == len(compound.Entitys) {
				q.storage.Compounds = sliceRemove(q.storage.Compounds, id)
				continue
			}
			skipID, skipCount := compound.EntitysRemoved[0], 0
			if !compound.cleanupTime.Swap(true) {
				idxRemove := make([]int, total)
				for idx, id := range compound.Entitys {
					if id == skipID {
						idxRemove[skipCount] = idx
						skipCount++
						if skipCount < total {
							skipID = compound.EntitysRemoved[skipCount]
						}
						continue
					}
					fn(id, getOptional(v1s, idx))
					if *options.Stop {
						return
					}
				}
				// Remove multiple indexes needs to be done in reverse so we don't mess up the indexes
				for i := len(idxRemove) - 1; i >= 0; i-- {
					idx := idxRemove[i]
					compound.Entitys = sliceRemove(compound.Entitys, idx)
					for _, component := range compound.Components {
						component.Data.remove(idx)
					}
				}
				compound.EntitysRemoved = nil
				compound.cleanupTime.Store(false)
				continue
			}
			for idx, id := range compound.Entitys {
				if id == skipID {
					skipCount++
					if skipCount < total {
						skipID = compound.EntitysRemoved[skipCount]
					}
					continue
				}
				fn(id, getOptional(v1s, idx))
				if *options.Stop {
					return
				}
			}
			continue
		}
		// Loop
		for idx, id := range compound.Entitys {
			fn(id, getOptional(v1s, idx))
			if *options.Stop {
				return
			}
		}
	}
}

func (q *Q2[ID, T1, T2]) Each(fn func(ID, *T1, *T2), queryOptions ...Q2Option) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q2Option
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
LOOP:
	for id, compound := range q.storage.Compounds {
		var v1s []T1
		var v2s []T2

		for _, component := range compound.Components {
			if options.Hash != nil && component.ID == options.Hash.ID && component.Hash != options.Hash.Hash {
				continue LOOP
			}
			if component.ID == q.Components[0] {
				v1s = component.Data.(*slice[T1]).Data
				continue
			}
			if component.ID == q.Components[1] {
				v2s = component.Data.(*slice[T2]).Data
				continue
			}

		}
		if v1s == nil && !options.Optional[0] {
			continue
		}
		if v2s == nil && !options.Optional[1] {
			continue
		}

		if compound.EntitysRemoved != nil {
			total := len(compound.EntitysRemoved)
			if total == len(compound.Entitys) {
				q.storage.Compounds = sliceRemove(q.storage.Compounds, id)
				continue
			}
			skipID, skipCount := compound.EntitysRemoved[0], 0
			if !compound.cleanupTime.Swap(true) {
				idxRemove := make([]int, total)
				for idx, id := range compound.Entitys {
					if id == skipID {
						idxRemove[skipCount] = idx
						skipCount++
						if skipCount < total {
							skipID = compound.EntitysRemoved[skipCount]
						}
						continue
					}
					fn(id, getOptional(v1s, idx), getOptional(v2s, idx))
					if *options.Stop {
						return
					}
				}
				// Remove multiple indexes needs to be done in reverse so we don't mess up the indexes
				for i := len(idxRemove) - 1; i >= 0; i-- {
					idx := idxRemove[i]
					compound.Entitys = sliceRemove(compound.Entitys, idx)
					for _, component := range compound.Components {
						component.Data.remove(idx)
					}
				}
				compound.EntitysRemoved = nil
				compound.cleanupTime.Store(false)
				continue
			}
			for idx, id := range compound.Entitys {
				if id == skipID {
					skipCount++
					if skipCount < total {
						skipID = compound.EntitysRemoved[skipCount]
					}
					continue
				}
				fn(id, getOptional(v1s, idx), getOptional(v2s, idx))
				if *options.Stop {
					return
				}
			}
			continue
		}
		// Loop
		for idx, id := range compound.Entitys {
			fn(id, getOptional(v1s, idx), getOptional(v2s, idx))
			if *options.Stop {
				return
			}
		}
	}
}

func (q *Q3[ID, T1, T2, T3]) Each(fn func(ID, *T1, *T2, *T3), queryOptions ...Q3Option) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q3Option
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
LOOP:
	for id, compound := range q.storage.Compounds {
		var v1s []T1
		var v2s []T2
		var v3s []T3

		for _, component := range compound.Components {
			if options.Hash != nil && component.ID == options.Hash.ID && component.Hash != options.Hash.Hash {
				continue LOOP
			}
			if component.ID == q.Components[0] {
				v1s = component.Data.(*slice[T1]).Data
				continue
			}
			if component.ID == q.Components[1] {
				v2s = component.Data.(*slice[T2]).Data
				continue
			}
			if component.ID == q.Components[2] {
				v3s = component.Data.(*slice[T3]).Data
				continue
			}

		}
		if v1s == nil && !options.Optional[0] {
			continue
		}
		if v2s == nil && !options.Optional[1] {
			continue
		}
		if v3s == nil && !options.Optional[2] {
			continue
		}

		if compound.EntitysRemoved != nil {
			total := len(compound.EntitysRemoved)
			if total == len(compound.Entitys) {
				q.storage.Compounds = sliceRemove(q.storage.Compounds, id)
				continue
			}
			skipID, skipCount := compound.EntitysRemoved[0], 0
			if !compound.cleanupTime.Swap(true) {
				idxRemove := make([]int, total)
				for idx, id := range compound.Entitys {
					if id == skipID {
						idxRemove[skipCount] = idx
						skipCount++
						if skipCount < total {
							skipID = compound.EntitysRemoved[skipCount]
						}
						continue
					}
					fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx))
					if *options.Stop {
						return
					}
				}
				// Remove multiple indexes needs to be done in reverse so we don't mess up the indexes
				for i := len(idxRemove) - 1; i >= 0; i-- {
					idx := idxRemove[i]
					compound.Entitys = sliceRemove(compound.Entitys, idx)
					for _, component := range compound.Components {
						component.Data.remove(idx)
					}
				}
				compound.EntitysRemoved = nil
				compound.cleanupTime.Store(false)
				continue
			}
			for idx, id := range compound.Entitys {
				if id == skipID {
					skipCount++
					if skipCount < total {
						skipID = compound.EntitysRemoved[skipCount]
					}
					continue
				}
				fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx))
				if *options.Stop {
					return
				}
			}
			continue
		}
		// Loop
		for idx, id := range compound.Entitys {
			fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx))
			if *options.Stop {
				return
			}
		}
	}
}

func (q *Q4[ID, T1, T2, T3, T4]) Each(fn func(ID, *T1, *T2, *T3, *T4), queryOptions ...Q4Option) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q4Option
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
LOOP:
	for id, compound := range q.storage.Compounds {
		var v1s []T1
		var v2s []T2
		var v3s []T3
		var v4s []T4

		for _, component := range compound.Components {
			if options.Hash != nil && component.ID == options.Hash.ID && component.Hash != options.Hash.Hash {
				continue LOOP
			}
			if component.ID == q.Components[0] {
				v1s = component.Data.(*slice[T1]).Data
				continue
			}
			if component.ID == q.Components[1] {
				v2s = component.Data.(*slice[T2]).Data
				continue
			}
			if component.ID == q.Components[2] {
				v3s = component.Data.(*slice[T3]).Data
				continue
			}
			if component.ID == q.Components[3] {
				v4s = component.Data.(*slice[T4]).Data
				continue
			}

		}
		if v1s == nil && !options.Optional[0] {
			continue
		}
		if v2s == nil && !options.Optional[1] {
			continue
		}
		if v3s == nil && !options.Optional[2] {
			continue
		}
		if v4s == nil && !options.Optional[3] {
			continue
		}

		if compound.EntitysRemoved != nil {
			total := len(compound.EntitysRemoved)
			if total == len(compound.Entitys) {
				q.storage.Compounds = sliceRemove(q.storage.Compounds, id)
				continue
			}
			skipID, skipCount := compound.EntitysRemoved[0], 0
			if !compound.cleanupTime.Swap(true) {
				idxRemove := make([]int, total)
				for idx, id := range compound.Entitys {
					if id == skipID {
						idxRemove[skipCount] = idx
						skipCount++
						if skipCount < total {
							skipID = compound.EntitysRemoved[skipCount]
						}
						continue
					}
					fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx))
					if *options.Stop {
						return
					}
				}
				// Remove multiple indexes needs to be done in reverse so we don't mess up the indexes
				for i := len(idxRemove) - 1; i >= 0; i-- {
					idx := idxRemove[i]
					compound.Entitys = sliceRemove(compound.Entitys, idx)
					for _, component := range compound.Components {
						component.Data.remove(idx)
					}
				}
				compound.EntitysRemoved = nil
				compound.cleanupTime.Store(false)
				continue
			}
			for idx, id := range compound.Entitys {
				if id == skipID {
					skipCount++
					if skipCount < total {
						skipID = compound.EntitysRemoved[skipCount]
					}
					continue
				}
				fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx))
				if *options.Stop {
					return
				}
			}
			continue
		}
		// Loop
		for idx, id := range compound.Entitys {
			fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx))
			if *options.Stop {
				return
			}
		}
	}
}

func (q *Q5[ID, T1, T2, T3, T4, T5]) Each(fn func(ID, *T1, *T2, *T3, *T4, *T5), queryOptions ...Q5Option) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q5Option
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
LOOP:
	for id, compound := range q.storage.Compounds {
		var v1s []T1
		var v2s []T2
		var v3s []T3
		var v4s []T4
		var v5s []T5

		for _, component := range compound.Components {
			if options.Hash != nil && component.ID == options.Hash.ID && component.Hash != options.Hash.Hash {
				continue LOOP
			}
			if component.ID == q.Components[0] {
				v1s = component.Data.(*slice[T1]).Data
				continue
			}
			if component.ID == q.Components[1] {
				v2s = component.Data.(*slice[T2]).Data
				continue
			}
			if component.ID == q.Components[2] {
				v3s = component.Data.(*slice[T3]).Data
				continue
			}
			if component.ID == q.Components[3] {
				v4s = component.Data.(*slice[T4]).Data
				continue
			}
			if component.ID == q.Components[4] {
				v5s = component.Data.(*slice[T5]).Data
				continue
			}

		}
		if v1s == nil && !options.Optional[0] {
			continue
		}
		if v2s == nil && !options.Optional[1] {
			continue
		}
		if v3s == nil && !options.Optional[2] {
			continue
		}
		if v4s == nil && !options.Optional[3] {
			continue
		}
		if v5s == nil && !options.Optional[4] {
			continue
		}

		if compound.EntitysRemoved != nil {
			total := len(compound.EntitysRemoved)
			if total == len(compound.Entitys) {
				q.storage.Compounds = sliceRemove(q.storage.Compounds, id)
				continue
			}
			skipID, skipCount := compound.EntitysRemoved[0], 0
			if !compound.cleanupTime.Swap(true) {
				idxRemove := make([]int, total)
				for idx, id := range compound.Entitys {
					if id == skipID {
						idxRemove[skipCount] = idx
						skipCount++
						if skipCount < total {
							skipID = compound.EntitysRemoved[skipCount]
						}
						continue
					}
					fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx))
					if *options.Stop {
						return
					}
				}
				// Remove multiple indexes needs to be done in reverse so we don't mess up the indexes
				for i := len(idxRemove) - 1; i >= 0; i-- {
					idx := idxRemove[i]
					compound.Entitys = sliceRemove(compound.Entitys, idx)
					for _, component := range compound.Components {
						component.Data.remove(idx)
					}
				}
				compound.EntitysRemoved = nil
				compound.cleanupTime.Store(false)
				continue
			}
			for idx, id := range compound.Entitys {
				if id == skipID {
					skipCount++
					if skipCount < total {
						skipID = compound.EntitysRemoved[skipCount]
					}
					continue
				}
				fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx))
				if *options.Stop {
					return
				}
			}
			continue
		}
		// Loop
		for idx, id := range compound.Entitys {
			fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx))
			if *options.Stop {
				return
			}
		}
	}
}

func (q *Q6[ID, T1, T2, T3, T4, T5, T6]) Each(fn func(ID, *T1, *T2, *T3, *T4, *T5, *T6), queryOptions ...Q6Option) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q6Option
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
LOOP:
	for id, compound := range q.storage.Compounds {
		var v1s []T1
		var v2s []T2
		var v3s []T3
		var v4s []T4
		var v5s []T5
		var v6s []T6

		for _, component := range compound.Components {
			if options.Hash != nil && component.ID == options.Hash.ID && component.Hash != options.Hash.Hash {
				continue LOOP
			}
			if component.ID == q.Components[0] {
				v1s = component.Data.(*slice[T1]).Data
				continue
			}
			if component.ID == q.Components[1] {
				v2s = component.Data.(*slice[T2]).Data
				continue
			}
			if component.ID == q.Components[2] {
				v3s = component.Data.(*slice[T3]).Data
				continue
			}
			if component.ID == q.Components[3] {
				v4s = component.Data.(*slice[T4]).Data
				continue
			}
			if component.ID == q.Components[4] {
				v5s = component.Data.(*slice[T5]).Data
				continue
			}
			if component.ID == q.Components[5] {
				v6s = component.Data.(*slice[T6]).Data
				continue
			}

		}
		if v1s == nil && !options.Optional[0] {
			continue
		}
		if v2s == nil && !options.Optional[1] {
			continue
		}
		if v3s == nil && !options.Optional[2] {
			continue
		}
		if v4s == nil && !options.Optional[3] {
			continue
		}
		if v5s == nil && !options.Optional[4] {
			continue
		}
		if v6s == nil && !options.Optional[5] {
			continue
		}

		if compound.EntitysRemoved != nil {
			total := len(compound.EntitysRemoved)
			if total == len(compound.Entitys) {
				q.storage.Compounds = sliceRemove(q.storage.Compounds, id)
				continue
			}
			skipID, skipCount := compound.EntitysRemoved[0], 0
			if !compound.cleanupTime.Swap(true) {
				idxRemove := make([]int, total)
				for idx, id := range compound.Entitys {
					if id == skipID {
						idxRemove[skipCount] = idx
						skipCount++
						if skipCount < total {
							skipID = compound.EntitysRemoved[skipCount]
						}
						continue
					}
					fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx))
					if *options.Stop {
						return
					}
				}
				// Remove multiple indexes needs to be done in reverse so we don't mess up the indexes
				for i := len(idxRemove) - 1; i >= 0; i-- {
					idx := idxRemove[i]
					compound.Entitys = sliceRemove(compound.Entitys, idx)
					for _, component := range compound.Components {
						component.Data.remove(idx)
					}
				}
				compound.EntitysRemoved = nil
				compound.cleanupTime.Store(false)
				continue
			}
			for idx, id := range compound.Entitys {
				if id == skipID {
					skipCount++
					if skipCount < total {
						skipID = compound.EntitysRemoved[skipCount]
					}
					continue
				}
				fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx))
				if *options.Stop {
					return
				}
			}
			continue
		}
		// Loop
		for idx, id := range compound.Entitys {
			fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx))
			if *options.Stop {
				return
			}
		}
	}
}

func (q *Q7[ID, T1, T2, T3, T4, T5, T6, T7]) Each(fn func(ID, *T1, *T2, *T3, *T4, *T5, *T6, *T7), queryOptions ...Q7Option) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q7Option
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
LOOP:
	for id, compound := range q.storage.Compounds {
		var v1s []T1
		var v2s []T2
		var v3s []T3
		var v4s []T4
		var v5s []T5
		var v6s []T6
		var v7s []T7

		for _, component := range compound.Components {
			if options.Hash != nil && component.ID == options.Hash.ID && component.Hash != options.Hash.Hash {
				continue LOOP
			}
			if component.ID == q.Components[0] {
				v1s = component.Data.(*slice[T1]).Data
				continue
			}
			if component.ID == q.Components[1] {
				v2s = component.Data.(*slice[T2]).Data
				continue
			}
			if component.ID == q.Components[2] {
				v3s = component.Data.(*slice[T3]).Data
				continue
			}
			if component.ID == q.Components[3] {
				v4s = component.Data.(*slice[T4]).Data
				continue
			}
			if component.ID == q.Components[4] {
				v5s = component.Data.(*slice[T5]).Data
				continue
			}
			if component.ID == q.Components[5] {
				v6s = component.Data.(*slice[T6]).Data
				continue
			}
			if component.ID == q.Components[6] {
				v7s = component.Data.(*slice[T7]).Data
				continue
			}

		}
		if v1s == nil && !options.Optional[0] {
			continue
		}
		if v2s == nil && !options.Optional[1] {
			continue
		}
		if v3s == nil && !options.Optional[2] {
			continue
		}
		if v4s == nil && !options.Optional[3] {
			continue
		}
		if v5s == nil && !options.Optional[4] {
			continue
		}
		if v6s == nil && !options.Optional[5] {
			continue
		}
		if v7s == nil && !options.Optional[6] {
			continue
		}

		if compound.EntitysRemoved != nil {
			total := len(compound.EntitysRemoved)
			if total == len(compound.Entitys) {
				q.storage.Compounds = sliceRemove(q.storage.Compounds, id)
				continue
			}
			skipID, skipCount := compound.EntitysRemoved[0], 0
			if !compound.cleanupTime.Swap(true) {
				idxRemove := make([]int, total)
				for idx, id := range compound.Entitys {
					if id == skipID {
						idxRemove[skipCount] = idx
						skipCount++
						if skipCount < total {
							skipID = compound.EntitysRemoved[skipCount]
						}
						continue
					}
					fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx))
					if *options.Stop {
						return
					}
				}
				// Remove multiple indexes needs to be done in reverse so we don't mess up the indexes
				for i := len(idxRemove) - 1; i >= 0; i-- {
					idx := idxRemove[i]
					compound.Entitys = sliceRemove(compound.Entitys, idx)
					for _, component := range compound.Components {
						component.Data.remove(idx)
					}
				}
				compound.EntitysRemoved = nil
				compound.cleanupTime.Store(false)
				continue
			}
			for idx, id := range compound.Entitys {
				if id == skipID {
					skipCount++
					if skipCount < total {
						skipID = compound.EntitysRemoved[skipCount]
					}
					continue
				}
				fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx))
				if *options.Stop {
					return
				}
			}
			continue
		}
		// Loop
		for idx, id := range compound.Entitys {
			fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx))
			if *options.Stop {
				return
			}
		}
	}
}

func (q *Q8[ID, T1, T2, T3, T4, T5, T6, T7, T8]) Each(fn func(ID, *T1, *T2, *T3, *T4, *T5, *T6, *T7, *T8), queryOptions ...Q8Option) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q8Option
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
LOOP:
	for id, compound := range q.storage.Compounds {
		var v1s []T1
		var v2s []T2
		var v3s []T3
		var v4s []T4
		var v5s []T5
		var v6s []T6
		var v7s []T7
		var v8s []T8

		for _, component := range compound.Components {
			if options.Hash != nil && component.ID == options.Hash.ID && component.Hash != options.Hash.Hash {
				continue LOOP
			}
			if component.ID == q.Components[0] {
				v1s = component.Data.(*slice[T1]).Data
				continue
			}
			if component.ID == q.Components[1] {
				v2s = component.Data.(*slice[T2]).Data
				continue
			}
			if component.ID == q.Components[2] {
				v3s = component.Data.(*slice[T3]).Data
				continue
			}
			if component.ID == q.Components[3] {
				v4s = component.Data.(*slice[T4]).Data
				continue
			}
			if component.ID == q.Components[4] {
				v5s = component.Data.(*slice[T5]).Data
				continue
			}
			if component.ID == q.Components[5] {
				v6s = component.Data.(*slice[T6]).Data
				continue
			}
			if component.ID == q.Components[6] {
				v7s = component.Data.(*slice[T7]).Data
				continue
			}
			if component.ID == q.Components[7] {
				v8s = component.Data.(*slice[T8]).Data
				continue
			}

		}
		if v1s == nil && !options.Optional[0] {
			continue
		}
		if v2s == nil && !options.Optional[1] {
			continue
		}
		if v3s == nil && !options.Optional[2] {
			continue
		}
		if v4s == nil && !options.Optional[3] {
			continue
		}
		if v5s == nil && !options.Optional[4] {
			continue
		}
		if v6s == nil && !options.Optional[5] {
			continue
		}
		if v7s == nil && !options.Optional[6] {
			continue
		}
		if v8s == nil && !options.Optional[7] {
			continue
		}

		if compound.EntitysRemoved != nil {
			total := len(compound.EntitysRemoved)
			if total == len(compound.Entitys) {
				q.storage.Compounds = sliceRemove(q.storage.Compounds, id)
				continue
			}
			skipID, skipCount := compound.EntitysRemoved[0], 0
			if !compound.cleanupTime.Swap(true) {
				idxRemove := make([]int, total)
				for idx, id := range compound.Entitys {
					if id == skipID {
						idxRemove[skipCount] = idx
						skipCount++
						if skipCount < total {
							skipID = compound.EntitysRemoved[skipCount]
						}
						continue
					}
					fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx))
					if *options.Stop {
						return
					}
				}
				// Remove multiple indexes needs to be done in reverse so we don't mess up the indexes
				for i := len(idxRemove) - 1; i >= 0; i-- {
					idx := idxRemove[i]
					compound.Entitys = sliceRemove(compound.Entitys, idx)
					for _, component := range compound.Components {
						component.Data.remove(idx)
					}
				}
				compound.EntitysRemoved = nil
				compound.cleanupTime.Store(false)
				continue
			}
			for idx, id := range compound.Entitys {
				if id == skipID {
					skipCount++
					if skipCount < total {
						skipID = compound.EntitysRemoved[skipCount]
					}
					continue
				}
				fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx))
				if *options.Stop {
					return
				}
			}
			continue
		}
		// Loop
		for idx, id := range compound.Entitys {
			fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx))
			if *options.Stop {
				return
			}
		}
	}
}

func (q *Q9[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9]) Each(fn func(ID, *T1, *T2, *T3, *T4, *T5, *T6, *T7, *T8, *T9), queryOptions ...Q9Option) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q9Option
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
LOOP:
	for id, compound := range q.storage.Compounds {
		var v1s []T1
		var v2s []T2
		var v3s []T3
		var v4s []T4
		var v5s []T5
		var v6s []T6
		var v7s []T7
		var v8s []T8
		var v9s []T9

		for _, component := range compound.Components {
			if options.Hash != nil && component.ID == options.Hash.ID && component.Hash != options.Hash.Hash {
				continue LOOP
			}
			if component.ID == q.Components[0] {
				v1s = component.Data.(*slice[T1]).Data
				continue
			}
			if component.ID == q.Components[1] {
				v2s = component.Data.(*slice[T2]).Data
				continue
			}
			if component.ID == q.Components[2] {
				v3s = component.Data.(*slice[T3]).Data
				continue
			}
			if component.ID == q.Components[3] {
				v4s = component.Data.(*slice[T4]).Data
				continue
			}
			if component.ID == q.Components[4] {
				v5s = component.Data.(*slice[T5]).Data
				continue
			}
			if component.ID == q.Components[5] {
				v6s = component.Data.(*slice[T6]).Data
				continue
			}
			if component.ID == q.Components[6] {
				v7s = component.Data.(*slice[T7]).Data
				continue
			}
			if component.ID == q.Components[7] {
				v8s = component.Data.(*slice[T8]).Data
				continue
			}
			if component.ID == q.Components[8] {
				v9s = component.Data.(*slice[T9]).Data
				continue
			}

		}
		if v1s == nil && !options.Optional[0] {
			continue
		}
		if v2s == nil && !options.Optional[1] {
			continue
		}
		if v3s == nil && !options.Optional[2] {
			continue
		}
		if v4s == nil && !options.Optional[3] {
			continue
		}
		if v5s == nil && !options.Optional[4] {
			continue
		}
		if v6s == nil && !options.Optional[5] {
			continue
		}
		if v7s == nil && !options.Optional[6] {
			continue
		}
		if v8s == nil && !options.Optional[7] {
			continue
		}
		if v9s == nil && !options.Optional[8] {
			continue
		}

		if compound.EntitysRemoved != nil {
			total := len(compound.EntitysRemoved)
			if total == len(compound.Entitys) {
				q.storage.Compounds = sliceRemove(q.storage.Compounds, id)
				continue
			}
			skipID, skipCount := compound.EntitysRemoved[0], 0
			if !compound.cleanupTime.Swap(true) {
				idxRemove := make([]int, total)
				for idx, id := range compound.Entitys {
					if id == skipID {
						idxRemove[skipCount] = idx
						skipCount++
						if skipCount < total {
							skipID = compound.EntitysRemoved[skipCount]
						}
						continue
					}
					fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx))
					if *options.Stop {
						return
					}
				}
				// Remove multiple indexes needs to be done in reverse so we don't mess up the indexes
				for i := len(idxRemove) - 1; i >= 0; i-- {
					idx := idxRemove[i]
					compound.Entitys = sliceRemove(compound.Entitys, idx)
					for _, component := range compound.Components {
						component.Data.remove(idx)
					}
				}
				compound.EntitysRemoved = nil
				compound.cleanupTime.Store(false)
				continue
			}
			for idx, id := range compound.Entitys {
				if id == skipID {
					skipCount++
					if skipCount < total {
						skipID = compound.EntitysRemoved[skipCount]
					}
					continue
				}
				fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx))
				if *options.Stop {
					return
				}
			}
			continue
		}
		// Loop
		for idx, id := range compound.Entitys {
			fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx))
			if *options.Stop {
				return
			}
		}
	}
}

func (q *Q10[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]) Each(fn func(ID, *T1, *T2, *T3, *T4, *T5, *T6, *T7, *T8, *T9, *T10), queryOptions ...Q10Option) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q10Option
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
LOOP:
	for id, compound := range q.storage.Compounds {
		var v1s []T1
		var v2s []T2
		var v3s []T3
		var v4s []T4
		var v5s []T5
		var v6s []T6
		var v7s []T7
		var v8s []T8
		var v9s []T9
		var v10s []T10

		for _, component := range compound.Components {
			if options.Hash != nil && component.ID == options.Hash.ID && component.Hash != options.Hash.Hash {
				continue LOOP
			}
			if component.ID == q.Components[0] {
				v1s = component.Data.(*slice[T1]).Data
				continue
			}
			if component.ID == q.Components[1] {
				v2s = component.Data.(*slice[T2]).Data
				continue
			}
			if component.ID == q.Components[2] {
				v3s = component.Data.(*slice[T3]).Data
				continue
			}
			if component.ID == q.Components[3] {
				v4s = component.Data.(*slice[T4]).Data
				continue
			}
			if component.ID == q.Components[4] {
				v5s = component.Data.(*slice[T5]).Data
				continue
			}
			if component.ID == q.Components[5] {
				v6s = component.Data.(*slice[T6]).Data
				continue
			}
			if component.ID == q.Components[6] {
				v7s = component.Data.(*slice[T7]).Data
				continue
			}
			if component.ID == q.Components[7] {
				v8s = component.Data.(*slice[T8]).Data
				continue
			}
			if component.ID == q.Components[8] {
				v9s = component.Data.(*slice[T9]).Data
				continue
			}
			if component.ID == q.Components[9] {
				v10s = component.Data.(*slice[T10]).Data
				continue
			}

		}
		if v1s == nil && !options.Optional[0] {
			continue
		}
		if v2s == nil && !options.Optional[1] {
			continue
		}
		if v3s == nil && !options.Optional[2] {
			continue
		}
		if v4s == nil && !options.Optional[3] {
			continue
		}
		if v5s == nil && !options.Optional[4] {
			continue
		}
		if v6s == nil && !options.Optional[5] {
			continue
		}
		if v7s == nil && !options.Optional[6] {
			continue
		}
		if v8s == nil && !options.Optional[7] {
			continue
		}
		if v9s == nil && !options.Optional[8] {
			continue
		}
		if v10s == nil && !options.Optional[9] {
			continue
		}

		if compound.EntitysRemoved != nil {
			total := len(compound.EntitysRemoved)
			if total == len(compound.Entitys) {
				q.storage.Compounds = sliceRemove(q.storage.Compounds, id)
				continue
			}
			skipID, skipCount := compound.EntitysRemoved[0], 0
			if !compound.cleanupTime.Swap(true) {
				idxRemove := make([]int, total)
				for idx, id := range compound.Entitys {
					if id == skipID {
						idxRemove[skipCount] = idx
						skipCount++
						if skipCount < total {
							skipID = compound.EntitysRemoved[skipCount]
						}
						continue
					}
					fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx))
					if *options.Stop {
						return
					}
				}
				// Remove multiple indexes needs to be done in reverse so we don't mess up the indexes
				for i := len(idxRemove) - 1; i >= 0; i-- {
					idx := idxRemove[i]
					compound.Entitys = sliceRemove(compound.Entitys, idx)
					for _, component := range compound.Components {
						component.Data.remove(idx)
					}
				}
				compound.EntitysRemoved = nil
				compound.cleanupTime.Store(false)
				continue
			}
			for idx, id := range compound.Entitys {
				if id == skipID {
					skipCount++
					if skipCount < total {
						skipID = compound.EntitysRemoved[skipCount]
					}
					continue
				}
				fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx))
				if *options.Stop {
					return
				}
			}
			continue
		}
		// Loop
		for idx, id := range compound.Entitys {
			fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx))
			if *options.Stop {
				return
			}
		}
	}
}

func (q *Q11[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11]) Each(fn func(ID, *T1, *T2, *T3, *T4, *T5, *T6, *T7, *T8, *T9, *T10, *T11), queryOptions ...Q11Option) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q11Option
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
LOOP:
	for id, compound := range q.storage.Compounds {
		var v1s []T1
		var v2s []T2
		var v3s []T3
		var v4s []T4
		var v5s []T5
		var v6s []T6
		var v7s []T7
		var v8s []T8
		var v9s []T9
		var v10s []T10
		var v11s []T11

		for _, component := range compound.Components {
			if options.Hash != nil && component.ID == options.Hash.ID && component.Hash != options.Hash.Hash {
				continue LOOP
			}
			if component.ID == q.Components[0] {
				v1s = component.Data.(*slice[T1]).Data
				continue
			}
			if component.ID == q.Components[1] {
				v2s = component.Data.(*slice[T2]).Data
				continue
			}
			if component.ID == q.Components[2] {
				v3s = component.Data.(*slice[T3]).Data
				continue
			}
			if component.ID == q.Components[3] {
				v4s = component.Data.(*slice[T4]).Data
				continue
			}
			if component.ID == q.Components[4] {
				v5s = component.Data.(*slice[T5]).Data
				continue
			}
			if component.ID == q.Components[5] {
				v6s = component.Data.(*slice[T6]).Data
				continue
			}
			if component.ID == q.Components[6] {
				v7s = component.Data.(*slice[T7]).Data
				continue
			}
			if component.ID == q.Components[7] {
				v8s = component.Data.(*slice[T8]).Data
				continue
			}
			if component.ID == q.Components[8] {
				v9s = component.Data.(*slice[T9]).Data
				continue
			}
			if component.ID == q.Components[9] {
				v10s = component.Data.(*slice[T10]).Data
				continue
			}
			if component.ID == q.Components[10] {
				v11s = component.Data.(*slice[T11]).Data
				continue
			}

		}
		if v1s == nil && !options.Optional[0] {
			continue
		}
		if v2s == nil && !options.Optional[1] {
			continue
		}
		if v3s == nil && !options.Optional[2] {
			continue
		}
		if v4s == nil && !options.Optional[3] {
			continue
		}
		if v5s == nil && !options.Optional[4] {
			continue
		}
		if v6s == nil && !options.Optional[5] {
			continue
		}
		if v7s == nil && !options.Optional[6] {
			continue
		}
		if v8s == nil && !options.Optional[7] {
			continue
		}
		if v9s == nil && !options.Optional[8] {
			continue
		}
		if v10s == nil && !options.Optional[9] {
			continue
		}
		if v11s == nil && !options.Optional[10] {
			continue
		}

		if compound.EntitysRemoved != nil {
			total := len(compound.EntitysRemoved)
			if total == len(compound.Entitys) {
				q.storage.Compounds = sliceRemove(q.storage.Compounds, id)
				continue
			}
			skipID, skipCount := compound.EntitysRemoved[0], 0
			if !compound.cleanupTime.Swap(true) {
				idxRemove := make([]int, total)
				for idx, id := range compound.Entitys {
					if id == skipID {
						idxRemove[skipCount] = idx
						skipCount++
						if skipCount < total {
							skipID = compound.EntitysRemoved[skipCount]
						}
						continue
					}
					fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx))
					if *options.Stop {
						return
					}
				}
				// Remove multiple indexes needs to be done in reverse so we don't mess up the indexes
				for i := len(idxRemove) - 1; i >= 0; i-- {
					idx := idxRemove[i]
					compound.Entitys = sliceRemove(compound.Entitys, idx)
					for _, component := range compound.Components {
						component.Data.remove(idx)
					}
				}
				compound.EntitysRemoved = nil
				compound.cleanupTime.Store(false)
				continue
			}
			for idx, id := range compound.Entitys {
				if id == skipID {
					skipCount++
					if skipCount < total {
						skipID = compound.EntitysRemoved[skipCount]
					}
					continue
				}
				fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx))
				if *options.Stop {
					return
				}
			}
			continue
		}
		// Loop
		for idx, id := range compound.Entitys {
			fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx))
			if *options.Stop {
				return
			}
		}
	}
}

func (q *Q12[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12]) Each(fn func(ID, *T1, *T2, *T3, *T4, *T5, *T6, *T7, *T8, *T9, *T10, *T11, *T12), queryOptions ...Q12Option) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q12Option
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
LOOP:
	for id, compound := range q.storage.Compounds {
		var v1s []T1
		var v2s []T2
		var v3s []T3
		var v4s []T4
		var v5s []T5
		var v6s []T6
		var v7s []T7
		var v8s []T8
		var v9s []T9
		var v10s []T10
		var v11s []T11
		var v12s []T12

		for _, component := range compound.Components {
			if options.Hash != nil && component.ID == options.Hash.ID && component.Hash != options.Hash.Hash {
				continue LOOP
			}
			if component.ID == q.Components[0] {
				v1s = component.Data.(*slice[T1]).Data
				continue
			}
			if component.ID == q.Components[1] {
				v2s = component.Data.(*slice[T2]).Data
				continue
			}
			if component.ID == q.Components[2] {
				v3s = component.Data.(*slice[T3]).Data
				continue
			}
			if component.ID == q.Components[3] {
				v4s = component.Data.(*slice[T4]).Data
				continue
			}
			if component.ID == q.Components[4] {
				v5s = component.Data.(*slice[T5]).Data
				continue
			}
			if component.ID == q.Components[5] {
				v6s = component.Data.(*slice[T6]).Data
				continue
			}
			if component.ID == q.Components[6] {
				v7s = component.Data.(*slice[T7]).Data
				continue
			}
			if component.ID == q.Components[7] {
				v8s = component.Data.(*slice[T8]).Data
				continue
			}
			if component.ID == q.Components[8] {
				v9s = component.Data.(*slice[T9]).Data
				continue
			}
			if component.ID == q.Components[9] {
				v10s = component.Data.(*slice[T10]).Data
				continue
			}
			if component.ID == q.Components[10] {
				v11s = component.Data.(*slice[T11]).Data
				continue
			}
			if component.ID == q.Components[11] {
				v12s = component.Data.(*slice[T12]).Data
				continue
			}

		}
		if v1s == nil && !options.Optional[0] {
			continue
		}
		if v2s == nil && !options.Optional[1] {
			continue
		}
		if v3s == nil && !options.Optional[2] {
			continue
		}
		if v4s == nil && !options.Optional[3] {
			continue
		}
		if v5s == nil && !options.Optional[4] {
			continue
		}
		if v6s == nil && !options.Optional[5] {
			continue
		}
		if v7s == nil && !options.Optional[6] {
			continue
		}
		if v8s == nil && !options.Optional[7] {
			continue
		}
		if v9s == nil && !options.Optional[8] {
			continue
		}
		if v10s == nil && !options.Optional[9] {
			continue
		}
		if v11s == nil && !options.Optional[10] {
			continue
		}
		if v12s == nil && !options.Optional[11] {
			continue
		}

		if compound.EntitysRemoved != nil {
			total := len(compound.EntitysRemoved)
			if total == len(compound.Entitys) {
				q.storage.Compounds = sliceRemove(q.storage.Compounds, id)
				continue
			}
			skipID, skipCount := compound.EntitysRemoved[0], 0
			if !compound.cleanupTime.Swap(true) {
				idxRemove := make([]int, total)
				for idx, id := range compound.Entitys {
					if id == skipID {
						idxRemove[skipCount] = idx
						skipCount++
						if skipCount < total {
							skipID = compound.EntitysRemoved[skipCount]
						}
						continue
					}
					fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx))
					if *options.Stop {
						return
					}
				}
				// Remove multiple indexes needs to be done in reverse so we don't mess up the indexes
				for i := len(idxRemove) - 1; i >= 0; i-- {
					idx := idxRemove[i]
					compound.Entitys = sliceRemove(compound.Entitys, idx)
					for _, component := range compound.Components {
						component.Data.remove(idx)
					}
				}
				compound.EntitysRemoved = nil
				compound.cleanupTime.Store(false)
				continue
			}
			for idx, id := range compound.Entitys {
				if id == skipID {
					skipCount++
					if skipCount < total {
						skipID = compound.EntitysRemoved[skipCount]
					}
					continue
				}
				fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx))
				if *options.Stop {
					return
				}
			}
			continue
		}
		// Loop
		for idx, id := range compound.Entitys {
			fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx))
			if *options.Stop {
				return
			}
		}
	}
}

func (q *Q13[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13]) Each(fn func(ID, *T1, *T2, *T3, *T4, *T5, *T6, *T7, *T8, *T9, *T10, *T11, *T12, *T13), queryOptions ...Q13Option) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q13Option
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
LOOP:
	for id, compound := range q.storage.Compounds {
		var v1s []T1
		var v2s []T2
		var v3s []T3
		var v4s []T4
		var v5s []T5
		var v6s []T6
		var v7s []T7
		var v8s []T8
		var v9s []T9
		var v10s []T10
		var v11s []T11
		var v12s []T12
		var v13s []T13

		for _, component := range compound.Components {
			if options.Hash != nil && component.ID == options.Hash.ID && component.Hash != options.Hash.Hash {
				continue LOOP
			}
			if component.ID == q.Components[0] {
				v1s = component.Data.(*slice[T1]).Data
				continue
			}
			if component.ID == q.Components[1] {
				v2s = component.Data.(*slice[T2]).Data
				continue
			}
			if component.ID == q.Components[2] {
				v3s = component.Data.(*slice[T3]).Data
				continue
			}
			if component.ID == q.Components[3] {
				v4s = component.Data.(*slice[T4]).Data
				continue
			}
			if component.ID == q.Components[4] {
				v5s = component.Data.(*slice[T5]).Data
				continue
			}
			if component.ID == q.Components[5] {
				v6s = component.Data.(*slice[T6]).Data
				continue
			}
			if component.ID == q.Components[6] {
				v7s = component.Data.(*slice[T7]).Data
				continue
			}
			if component.ID == q.Components[7] {
				v8s = component.Data.(*slice[T8]).Data
				continue
			}
			if component.ID == q.Components[8] {
				v9s = component.Data.(*slice[T9]).Data
				continue
			}
			if component.ID == q.Components[9] {
				v10s = component.Data.(*slice[T10]).Data
				continue
			}
			if component.ID == q.Components[10] {
				v11s = component.Data.(*slice[T11]).Data
				continue
			}
			if component.ID == q.Components[11] {
				v12s = component.Data.(*slice[T12]).Data
				continue
			}
			if component.ID == q.Components[12] {
				v13s = component.Data.(*slice[T13]).Data
				continue
			}

		}
		if v1s == nil && !options.Optional[0] {
			continue
		}
		if v2s == nil && !options.Optional[1] {
			continue
		}
		if v3s == nil && !options.Optional[2] {
			continue
		}
		if v4s == nil && !options.Optional[3] {
			continue
		}
		if v5s == nil && !options.Optional[4] {
			continue
		}
		if v6s == nil && !options.Optional[5] {
			continue
		}
		if v7s == nil && !options.Optional[6] {
			continue
		}
		if v8s == nil && !options.Optional[7] {
			continue
		}
		if v9s == nil && !options.Optional[8] {
			continue
		}
		if v10s == nil && !options.Optional[9] {
			continue
		}
		if v11s == nil && !options.Optional[10] {
			continue
		}
		if v12s == nil && !options.Optional[11] {
			continue
		}
		if v13s == nil && !options.Optional[12] {
			continue
		}

		if compound.EntitysRemoved != nil {
			total := len(compound.EntitysRemoved)
			if total == len(compound.Entitys) {
				q.storage.Compounds = sliceRemove(q.storage.Compounds, id)
				continue
			}
			skipID, skipCount := compound.EntitysRemoved[0], 0
			if !compound.cleanupTime.Swap(true) {
				idxRemove := make([]int, total)
				for idx, id := range compound.Entitys {
					if id == skipID {
						idxRemove[skipCount] = idx
						skipCount++
						if skipCount < total {
							skipID = compound.EntitysRemoved[skipCount]
						}
						continue
					}
					fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx), getOptional(v13s, idx))
					if *options.Stop {
						return
					}
				}
				// Remove multiple indexes needs to be done in reverse so we don't mess up the indexes
				for i := len(idxRemove) - 1; i >= 0; i-- {
					idx := idxRemove[i]
					compound.Entitys = sliceRemove(compound.Entitys, idx)
					for _, component := range compound.Components {
						component.Data.remove(idx)
					}
				}
				compound.EntitysRemoved = nil
				compound.cleanupTime.Store(false)
				continue
			}
			for idx, id := range compound.Entitys {
				if id == skipID {
					skipCount++
					if skipCount < total {
						skipID = compound.EntitysRemoved[skipCount]
					}
					continue
				}
				fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx), getOptional(v13s, idx))
				if *options.Stop {
					return
				}
			}
			continue
		}
		// Loop
		for idx, id := range compound.Entitys {
			fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx), getOptional(v13s, idx))
			if *options.Stop {
				return
			}
		}
	}
}

func (q *Q14[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14]) Each(fn func(ID, *T1, *T2, *T3, *T4, *T5, *T6, *T7, *T8, *T9, *T10, *T11, *T12, *T13, *T14), queryOptions ...Q14Option) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q14Option
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
LOOP:
	for id, compound := range q.storage.Compounds {
		var v1s []T1
		var v2s []T2
		var v3s []T3
		var v4s []T4
		var v5s []T5
		var v6s []T6
		var v7s []T7
		var v8s []T8
		var v9s []T9
		var v10s []T10
		var v11s []T11
		var v12s []T12
		var v13s []T13
		var v14s []T14

		for _, component := range compound.Components {
			if options.Hash != nil && component.ID == options.Hash.ID && component.Hash != options.Hash.Hash {
				continue LOOP
			}
			if component.ID == q.Components[0] {
				v1s = component.Data.(*slice[T1]).Data
				continue
			}
			if component.ID == q.Components[1] {
				v2s = component.Data.(*slice[T2]).Data
				continue
			}
			if component.ID == q.Components[2] {
				v3s = component.Data.(*slice[T3]).Data
				continue
			}
			if component.ID == q.Components[3] {
				v4s = component.Data.(*slice[T4]).Data
				continue
			}
			if component.ID == q.Components[4] {
				v5s = component.Data.(*slice[T5]).Data
				continue
			}
			if component.ID == q.Components[5] {
				v6s = component.Data.(*slice[T6]).Data
				continue
			}
			if component.ID == q.Components[6] {
				v7s = component.Data.(*slice[T7]).Data
				continue
			}
			if component.ID == q.Components[7] {
				v8s = component.Data.(*slice[T8]).Data
				continue
			}
			if component.ID == q.Components[8] {
				v9s = component.Data.(*slice[T9]).Data
				continue
			}
			if component.ID == q.Components[9] {
				v10s = component.Data.(*slice[T10]).Data
				continue
			}
			if component.ID == q.Components[10] {
				v11s = component.Data.(*slice[T11]).Data
				continue
			}
			if component.ID == q.Components[11] {
				v12s = component.Data.(*slice[T12]).Data
				continue
			}
			if component.ID == q.Components[12] {
				v13s = component.Data.(*slice[T13]).Data
				continue
			}
			if component.ID == q.Components[13] {
				v14s = component.Data.(*slice[T14]).Data
				continue
			}

		}
		if v1s == nil && !options.Optional[0] {
			continue
		}
		if v2s == nil && !options.Optional[1] {
			continue
		}
		if v3s == nil && !options.Optional[2] {
			continue
		}
		if v4s == nil && !options.Optional[3] {
			continue
		}
		if v5s == nil && !options.Optional[4] {
			continue
		}
		if v6s == nil && !options.Optional[5] {
			continue
		}
		if v7s == nil && !options.Optional[6] {
			continue
		}
		if v8s == nil && !options.Optional[7] {
			continue
		}
		if v9s == nil && !options.Optional[8] {
			continue
		}
		if v10s == nil && !options.Optional[9] {
			continue
		}
		if v11s == nil && !options.Optional[10] {
			continue
		}
		if v12s == nil && !options.Optional[11] {
			continue
		}
		if v13s == nil && !options.Optional[12] {
			continue
		}
		if v14s == nil && !options.Optional[13] {
			continue
		}

		if compound.EntitysRemoved != nil {
			total := len(compound.EntitysRemoved)
			if total == len(compound.Entitys) {
				q.storage.Compounds = sliceRemove(q.storage.Compounds, id)
				continue
			}
			skipID, skipCount := compound.EntitysRemoved[0], 0
			if !compound.cleanupTime.Swap(true) {
				idxRemove := make([]int, total)
				for idx, id := range compound.Entitys {
					if id == skipID {
						idxRemove[skipCount] = idx
						skipCount++
						if skipCount < total {
							skipID = compound.EntitysRemoved[skipCount]
						}
						continue
					}
					fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx), getOptional(v13s, idx), getOptional(v14s, idx))
					if *options.Stop {
						return
					}
				}
				// Remove multiple indexes needs to be done in reverse so we don't mess up the indexes
				for i := len(idxRemove) - 1; i >= 0; i-- {
					idx := idxRemove[i]
					compound.Entitys = sliceRemove(compound.Entitys, idx)
					for _, component := range compound.Components {
						component.Data.remove(idx)
					}
				}
				compound.EntitysRemoved = nil
				compound.cleanupTime.Store(false)
				continue
			}
			for idx, id := range compound.Entitys {
				if id == skipID {
					skipCount++
					if skipCount < total {
						skipID = compound.EntitysRemoved[skipCount]
					}
					continue
				}
				fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx), getOptional(v13s, idx), getOptional(v14s, idx))
				if *options.Stop {
					return
				}
			}
			continue
		}
		// Loop
		for idx, id := range compound.Entitys {
			fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx), getOptional(v13s, idx), getOptional(v14s, idx))
			if *options.Stop {
				return
			}
		}
	}
}

func (q *Q15[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15]) Each(fn func(ID, *T1, *T2, *T3, *T4, *T5, *T6, *T7, *T8, *T9, *T10, *T11, *T12, *T13, *T14, *T15), queryOptions ...Q15Option) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q15Option
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
LOOP:
	for id, compound := range q.storage.Compounds {
		var v1s []T1
		var v2s []T2
		var v3s []T3
		var v4s []T4
		var v5s []T5
		var v6s []T6
		var v7s []T7
		var v8s []T8
		var v9s []T9
		var v10s []T10
		var v11s []T11
		var v12s []T12
		var v13s []T13
		var v14s []T14
		var v15s []T15

		for _, component := range compound.Components {
			if options.Hash != nil && component.ID == options.Hash.ID && component.Hash != options.Hash.Hash {
				continue LOOP
			}
			if component.ID == q.Components[0] {
				v1s = component.Data.(*slice[T1]).Data
				continue
			}
			if component.ID == q.Components[1] {
				v2s = component.Data.(*slice[T2]).Data
				continue
			}
			if component.ID == q.Components[2] {
				v3s = component.Data.(*slice[T3]).Data
				continue
			}
			if component.ID == q.Components[3] {
				v4s = component.Data.(*slice[T4]).Data
				continue
			}
			if component.ID == q.Components[4] {
				v5s = component.Data.(*slice[T5]).Data
				continue
			}
			if component.ID == q.Components[5] {
				v6s = component.Data.(*slice[T6]).Data
				continue
			}
			if component.ID == q.Components[6] {
				v7s = component.Data.(*slice[T7]).Data
				continue
			}
			if component.ID == q.Components[7] {
				v8s = component.Data.(*slice[T8]).Data
				continue
			}
			if component.ID == q.Components[8] {
				v9s = component.Data.(*slice[T9]).Data
				continue
			}
			if component.ID == q.Components[9] {
				v10s = component.Data.(*slice[T10]).Data
				continue
			}
			if component.ID == q.Components[10] {
				v11s = component.Data.(*slice[T11]).Data
				continue
			}
			if component.ID == q.Components[11] {
				v12s = component.Data.(*slice[T12]).Data
				continue
			}
			if component.ID == q.Components[12] {
				v13s = component.Data.(*slice[T13]).Data
				continue
			}
			if component.ID == q.Components[13] {
				v14s = component.Data.(*slice[T14]).Data
				continue
			}
			if component.ID == q.Components[14] {
				v15s = component.Data.(*slice[T15]).Data
				continue
			}

		}
		if v1s == nil && !options.Optional[0] {
			continue
		}
		if v2s == nil && !options.Optional[1] {
			continue
		}
		if v3s == nil && !options.Optional[2] {
			continue
		}
		if v4s == nil && !options.Optional[3] {
			continue
		}
		if v5s == nil && !options.Optional[4] {
			continue
		}
		if v6s == nil && !options.Optional[5] {
			continue
		}
		if v7s == nil && !options.Optional[6] {
			continue
		}
		if v8s == nil && !options.Optional[7] {
			continue
		}
		if v9s == nil && !options.Optional[8] {
			continue
		}
		if v10s == nil && !options.Optional[9] {
			continue
		}
		if v11s == nil && !options.Optional[10] {
			continue
		}
		if v12s == nil && !options.Optional[11] {
			continue
		}
		if v13s == nil && !options.Optional[12] {
			continue
		}
		if v14s == nil && !options.Optional[13] {
			continue
		}
		if v15s == nil && !options.Optional[14] {
			continue
		}

		if compound.EntitysRemoved != nil {
			total := len(compound.EntitysRemoved)
			if total == len(compound.Entitys) {
				q.storage.Compounds = sliceRemove(q.storage.Compounds, id)
				continue
			}
			skipID, skipCount := compound.EntitysRemoved[0], 0
			if !compound.cleanupTime.Swap(true) {
				idxRemove := make([]int, total)
				for idx, id := range compound.Entitys {
					if id == skipID {
						idxRemove[skipCount] = idx
						skipCount++
						if skipCount < total {
							skipID = compound.EntitysRemoved[skipCount]
						}
						continue
					}
					fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx), getOptional(v13s, idx), getOptional(v14s, idx), getOptional(v15s, idx))
					if *options.Stop {
						return
					}
				}
				// Remove multiple indexes needs to be done in reverse so we don't mess up the indexes
				for i := len(idxRemove) - 1; i >= 0; i-- {
					idx := idxRemove[i]
					compound.Entitys = sliceRemove(compound.Entitys, idx)
					for _, component := range compound.Components {
						component.Data.remove(idx)
					}
				}
				compound.EntitysRemoved = nil
				compound.cleanupTime.Store(false)
				continue
			}
			for idx, id := range compound.Entitys {
				if id == skipID {
					skipCount++
					if skipCount < total {
						skipID = compound.EntitysRemoved[skipCount]
					}
					continue
				}
				fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx), getOptional(v13s, idx), getOptional(v14s, idx), getOptional(v15s, idx))
				if *options.Stop {
					return
				}
			}
			continue
		}
		// Loop
		for idx, id := range compound.Entitys {
			fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx), getOptional(v13s, idx), getOptional(v14s, idx), getOptional(v15s, idx))
			if *options.Stop {
				return
			}
		}
	}
}

func (q *Q16[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16]) Each(fn func(ID, *T1, *T2, *T3, *T4, *T5, *T6, *T7, *T8, *T9, *T10, *T11, *T12, *T13, *T14, *T15, *T16), queryOptions ...Q16Option) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q16Option
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
LOOP:
	for id, compound := range q.storage.Compounds {
		var v1s []T1
		var v2s []T2
		var v3s []T3
		var v4s []T4
		var v5s []T5
		var v6s []T6
		var v7s []T7
		var v8s []T8
		var v9s []T9
		var v10s []T10
		var v11s []T11
		var v12s []T12
		var v13s []T13
		var v14s []T14
		var v15s []T15
		var v16s []T16

		for _, component := range compound.Components {
			if options.Hash != nil && component.ID == options.Hash.ID && component.Hash != options.Hash.Hash {
				continue LOOP
			}
			if component.ID == q.Components[0] {
				v1s = component.Data.(*slice[T1]).Data
				continue
			}
			if component.ID == q.Components[1] {
				v2s = component.Data.(*slice[T2]).Data
				continue
			}
			if component.ID == q.Components[2] {
				v3s = component.Data.(*slice[T3]).Data
				continue
			}
			if component.ID == q.Components[3] {
				v4s = component.Data.(*slice[T4]).Data
				continue
			}
			if component.ID == q.Components[4] {
				v5s = component.Data.(*slice[T5]).Data
				continue
			}
			if component.ID == q.Components[5] {
				v6s = component.Data.(*slice[T6]).Data
				continue
			}
			if component.ID == q.Components[6] {
				v7s = component.Data.(*slice[T7]).Data
				continue
			}
			if component.ID == q.Components[7] {
				v8s = component.Data.(*slice[T8]).Data
				continue
			}
			if component.ID == q.Components[8] {
				v9s = component.Data.(*slice[T9]).Data
				continue
			}
			if component.ID == q.Components[9] {
				v10s = component.Data.(*slice[T10]).Data
				continue
			}
			if component.ID == q.Components[10] {
				v11s = component.Data.(*slice[T11]).Data
				continue
			}
			if component.ID == q.Components[11] {
				v12s = component.Data.(*slice[T12]).Data
				continue
			}
			if component.ID == q.Components[12] {
				v13s = component.Data.(*slice[T13]).Data
				continue
			}
			if component.ID == q.Components[13] {
				v14s = component.Data.(*slice[T14]).Data
				continue
			}
			if component.ID == q.Components[14] {
				v15s = component.Data.(*slice[T15]).Data
				continue
			}
			if component.ID == q.Components[15] {
				v16s = component.Data.(*slice[T16]).Data
				continue
			}

		}
		if v1s == nil && !options.Optional[0] {
			continue
		}
		if v2s == nil && !options.Optional[1] {
			continue
		}
		if v3s == nil && !options.Optional[2] {
			continue
		}
		if v4s == nil && !options.Optional[3] {
			continue
		}
		if v5s == nil && !options.Optional[4] {
			continue
		}
		if v6s == nil && !options.Optional[5] {
			continue
		}
		if v7s == nil && !options.Optional[6] {
			continue
		}
		if v8s == nil && !options.Optional[7] {
			continue
		}
		if v9s == nil && !options.Optional[8] {
			continue
		}
		if v10s == nil && !options.Optional[9] {
			continue
		}
		if v11s == nil && !options.Optional[10] {
			continue
		}
		if v12s == nil && !options.Optional[11] {
			continue
		}
		if v13s == nil && !options.Optional[12] {
			continue
		}
		if v14s == nil && !options.Optional[13] {
			continue
		}
		if v15s == nil && !options.Optional[14] {
			continue
		}
		if v16s == nil && !options.Optional[15] {
			continue
		}

		if compound.EntitysRemoved != nil {
			total := len(compound.EntitysRemoved)
			if total == len(compound.Entitys) {
				q.storage.Compounds = sliceRemove(q.storage.Compounds, id)
				continue
			}
			skipID, skipCount := compound.EntitysRemoved[0], 0
			if !compound.cleanupTime.Swap(true) {
				idxRemove := make([]int, total)
				for idx, id := range compound.Entitys {
					if id == skipID {
						idxRemove[skipCount] = idx
						skipCount++
						if skipCount < total {
							skipID = compound.EntitysRemoved[skipCount]
						}
						continue
					}
					fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx), getOptional(v13s, idx), getOptional(v14s, idx), getOptional(v15s, idx), getOptional(v16s, idx))
					if *options.Stop {
						return
					}
				}
				// Remove multiple indexes needs to be done in reverse so we don't mess up the indexes
				for i := len(idxRemove) - 1; i >= 0; i-- {
					idx := idxRemove[i]
					compound.Entitys = sliceRemove(compound.Entitys, idx)
					for _, component := range compound.Components {
						component.Data.remove(idx)
					}
				}
				compound.EntitysRemoved = nil
				compound.cleanupTime.Store(false)
				continue
			}
			for idx, id := range compound.Entitys {
				if id == skipID {
					skipCount++
					if skipCount < total {
						skipID = compound.EntitysRemoved[skipCount]
					}
					continue
				}
				fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx), getOptional(v13s, idx), getOptional(v14s, idx), getOptional(v15s, idx), getOptional(v16s, idx))
				if *options.Stop {
					return
				}
			}
			continue
		}
		// Loop
		for idx, id := range compound.Entitys {
			fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx), getOptional(v13s, idx), getOptional(v14s, idx), getOptional(v15s, idx), getOptional(v16s, idx))
			if *options.Stop {
				return
			}
		}
	}
}

func (q *Q17[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17]) Each(fn func(ID, *T1, *T2, *T3, *T4, *T5, *T6, *T7, *T8, *T9, *T10, *T11, *T12, *T13, *T14, *T15, *T16, *T17), queryOptions ...Q17Option) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q17Option
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
LOOP:
	for id, compound := range q.storage.Compounds {
		var v1s []T1
		var v2s []T2
		var v3s []T3
		var v4s []T4
		var v5s []T5
		var v6s []T6
		var v7s []T7
		var v8s []T8
		var v9s []T9
		var v10s []T10
		var v11s []T11
		var v12s []T12
		var v13s []T13
		var v14s []T14
		var v15s []T15
		var v16s []T16
		var v17s []T17

		for _, component := range compound.Components {
			if options.Hash != nil && component.ID == options.Hash.ID && component.Hash != options.Hash.Hash {
				continue LOOP
			}
			if component.ID == q.Components[0] {
				v1s = component.Data.(*slice[T1]).Data
				continue
			}
			if component.ID == q.Components[1] {
				v2s = component.Data.(*slice[T2]).Data
				continue
			}
			if component.ID == q.Components[2] {
				v3s = component.Data.(*slice[T3]).Data
				continue
			}
			if component.ID == q.Components[3] {
				v4s = component.Data.(*slice[T4]).Data
				continue
			}
			if component.ID == q.Components[4] {
				v5s = component.Data.(*slice[T5]).Data
				continue
			}
			if component.ID == q.Components[5] {
				v6s = component.Data.(*slice[T6]).Data
				continue
			}
			if component.ID == q.Components[6] {
				v7s = component.Data.(*slice[T7]).Data
				continue
			}
			if component.ID == q.Components[7] {
				v8s = component.Data.(*slice[T8]).Data
				continue
			}
			if component.ID == q.Components[8] {
				v9s = component.Data.(*slice[T9]).Data
				continue
			}
			if component.ID == q.Components[9] {
				v10s = component.Data.(*slice[T10]).Data
				continue
			}
			if component.ID == q.Components[10] {
				v11s = component.Data.(*slice[T11]).Data
				continue
			}
			if component.ID == q.Components[11] {
				v12s = component.Data.(*slice[T12]).Data
				continue
			}
			if component.ID == q.Components[12] {
				v13s = component.Data.(*slice[T13]).Data
				continue
			}
			if component.ID == q.Components[13] {
				v14s = component.Data.(*slice[T14]).Data
				continue
			}
			if component.ID == q.Components[14] {
				v15s = component.Data.(*slice[T15]).Data
				continue
			}
			if component.ID == q.Components[15] {
				v16s = component.Data.(*slice[T16]).Data
				continue
			}
			if component.ID == q.Components[16] {
				v17s = component.Data.(*slice[T17]).Data
				continue
			}

		}
		if v1s == nil && !options.Optional[0] {
			continue
		}
		if v2s == nil && !options.Optional[1] {
			continue
		}
		if v3s == nil && !options.Optional[2] {
			continue
		}
		if v4s == nil && !options.Optional[3] {
			continue
		}
		if v5s == nil && !options.Optional[4] {
			continue
		}
		if v6s == nil && !options.Optional[5] {
			continue
		}
		if v7s == nil && !options.Optional[6] {
			continue
		}
		if v8s == nil && !options.Optional[7] {
			continue
		}
		if v9s == nil && !options.Optional[8] {
			continue
		}
		if v10s == nil && !options.Optional[9] {
			continue
		}
		if v11s == nil && !options.Optional[10] {
			continue
		}
		if v12s == nil && !options.Optional[11] {
			continue
		}
		if v13s == nil && !options.Optional[12] {
			continue
		}
		if v14s == nil && !options.Optional[13] {
			continue
		}
		if v15s == nil && !options.Optional[14] {
			continue
		}
		if v16s == nil && !options.Optional[15] {
			continue
		}
		if v17s == nil && !options.Optional[16] {
			continue
		}

		if compound.EntitysRemoved != nil {
			total := len(compound.EntitysRemoved)
			if total == len(compound.Entitys) {
				q.storage.Compounds = sliceRemove(q.storage.Compounds, id)
				continue
			}
			skipID, skipCount := compound.EntitysRemoved[0], 0
			if !compound.cleanupTime.Swap(true) {
				idxRemove := make([]int, total)
				for idx, id := range compound.Entitys {
					if id == skipID {
						idxRemove[skipCount] = idx
						skipCount++
						if skipCount < total {
							skipID = compound.EntitysRemoved[skipCount]
						}
						continue
					}
					fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx), getOptional(v13s, idx), getOptional(v14s, idx), getOptional(v15s, idx), getOptional(v16s, idx), getOptional(v17s, idx))
					if *options.Stop {
						return
					}
				}
				// Remove multiple indexes needs to be done in reverse so we don't mess up the indexes
				for i := len(idxRemove) - 1; i >= 0; i-- {
					idx := idxRemove[i]
					compound.Entitys = sliceRemove(compound.Entitys, idx)
					for _, component := range compound.Components {
						component.Data.remove(idx)
					}
				}
				compound.EntitysRemoved = nil
				compound.cleanupTime.Store(false)
				continue
			}
			for idx, id := range compound.Entitys {
				if id == skipID {
					skipCount++
					if skipCount < total {
						skipID = compound.EntitysRemoved[skipCount]
					}
					continue
				}
				fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx), getOptional(v13s, idx), getOptional(v14s, idx), getOptional(v15s, idx), getOptional(v16s, idx), getOptional(v17s, idx))
				if *options.Stop {
					return
				}
			}
			continue
		}
		// Loop
		for idx, id := range compound.Entitys {
			fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx), getOptional(v13s, idx), getOptional(v14s, idx), getOptional(v15s, idx), getOptional(v16s, idx), getOptional(v17s, idx))
			if *options.Stop {
				return
			}
		}
	}
}

func (q *Q18[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18]) Each(fn func(ID, *T1, *T2, *T3, *T4, *T5, *T6, *T7, *T8, *T9, *T10, *T11, *T12, *T13, *T14, *T15, *T16, *T17, *T18), queryOptions ...Q18Option) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q18Option
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
LOOP:
	for id, compound := range q.storage.Compounds {
		var v1s []T1
		var v2s []T2
		var v3s []T3
		var v4s []T4
		var v5s []T5
		var v6s []T6
		var v7s []T7
		var v8s []T8
		var v9s []T9
		var v10s []T10
		var v11s []T11
		var v12s []T12
		var v13s []T13
		var v14s []T14
		var v15s []T15
		var v16s []T16
		var v17s []T17
		var v18s []T18

		for _, component := range compound.Components {
			if options.Hash != nil && component.ID == options.Hash.ID && component.Hash != options.Hash.Hash {
				continue LOOP
			}
			if component.ID == q.Components[0] {
				v1s = component.Data.(*slice[T1]).Data
				continue
			}
			if component.ID == q.Components[1] {
				v2s = component.Data.(*slice[T2]).Data
				continue
			}
			if component.ID == q.Components[2] {
				v3s = component.Data.(*slice[T3]).Data
				continue
			}
			if component.ID == q.Components[3] {
				v4s = component.Data.(*slice[T4]).Data
				continue
			}
			if component.ID == q.Components[4] {
				v5s = component.Data.(*slice[T5]).Data
				continue
			}
			if component.ID == q.Components[5] {
				v6s = component.Data.(*slice[T6]).Data
				continue
			}
			if component.ID == q.Components[6] {
				v7s = component.Data.(*slice[T7]).Data
				continue
			}
			if component.ID == q.Components[7] {
				v8s = component.Data.(*slice[T8]).Data
				continue
			}
			if component.ID == q.Components[8] {
				v9s = component.Data.(*slice[T9]).Data
				continue
			}
			if component.ID == q.Components[9] {
				v10s = component.Data.(*slice[T10]).Data
				continue
			}
			if component.ID == q.Components[10] {
				v11s = component.Data.(*slice[T11]).Data
				continue
			}
			if component.ID == q.Components[11] {
				v12s = component.Data.(*slice[T12]).Data
				continue
			}
			if component.ID == q.Components[12] {
				v13s = component.Data.(*slice[T13]).Data
				continue
			}
			if component.ID == q.Components[13] {
				v14s = component.Data.(*slice[T14]).Data
				continue
			}
			if component.ID == q.Components[14] {
				v15s = component.Data.(*slice[T15]).Data
				continue
			}
			if component.ID == q.Components[15] {
				v16s = component.Data.(*slice[T16]).Data
				continue
			}
			if component.ID == q.Components[16] {
				v17s = component.Data.(*slice[T17]).Data
				continue
			}
			if component.ID == q.Components[17] {
				v18s = component.Data.(*slice[T18]).Data
				continue
			}

		}
		if v1s == nil && !options.Optional[0] {
			continue
		}
		if v2s == nil && !options.Optional[1] {
			continue
		}
		if v3s == nil && !options.Optional[2] {
			continue
		}
		if v4s == nil && !options.Optional[3] {
			continue
		}
		if v5s == nil && !options.Optional[4] {
			continue
		}
		if v6s == nil && !options.Optional[5] {
			continue
		}
		if v7s == nil && !options.Optional[6] {
			continue
		}
		if v8s == nil && !options.Optional[7] {
			continue
		}
		if v9s == nil && !options.Optional[8] {
			continue
		}
		if v10s == nil && !options.Optional[9] {
			continue
		}
		if v11s == nil && !options.Optional[10] {
			continue
		}
		if v12s == nil && !options.Optional[11] {
			continue
		}
		if v13s == nil && !options.Optional[12] {
			continue
		}
		if v14s == nil && !options.Optional[13] {
			continue
		}
		if v15s == nil && !options.Optional[14] {
			continue
		}
		if v16s == nil && !options.Optional[15] {
			continue
		}
		if v17s == nil && !options.Optional[16] {
			continue
		}
		if v18s == nil && !options.Optional[17] {
			continue
		}

		if compound.EntitysRemoved != nil {
			total := len(compound.EntitysRemoved)
			if total == len(compound.Entitys) {
				q.storage.Compounds = sliceRemove(q.storage.Compounds, id)
				continue
			}
			skipID, skipCount := compound.EntitysRemoved[0], 0
			if !compound.cleanupTime.Swap(true) {
				idxRemove := make([]int, total)
				for idx, id := range compound.Entitys {
					if id == skipID {
						idxRemove[skipCount] = idx
						skipCount++
						if skipCount < total {
							skipID = compound.EntitysRemoved[skipCount]
						}
						continue
					}
					fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx), getOptional(v13s, idx), getOptional(v14s, idx), getOptional(v15s, idx), getOptional(v16s, idx), getOptional(v17s, idx), getOptional(v18s, idx))
					if *options.Stop {
						return
					}
				}
				// Remove multiple indexes needs to be done in reverse so we don't mess up the indexes
				for i := len(idxRemove) - 1; i >= 0; i-- {
					idx := idxRemove[i]
					compound.Entitys = sliceRemove(compound.Entitys, idx)
					for _, component := range compound.Components {
						component.Data.remove(idx)
					}
				}
				compound.EntitysRemoved = nil
				compound.cleanupTime.Store(false)
				continue
			}
			for idx, id := range compound.Entitys {
				if id == skipID {
					skipCount++
					if skipCount < total {
						skipID = compound.EntitysRemoved[skipCount]
					}
					continue
				}
				fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx), getOptional(v13s, idx), getOptional(v14s, idx), getOptional(v15s, idx), getOptional(v16s, idx), getOptional(v17s, idx), getOptional(v18s, idx))
				if *options.Stop {
					return
				}
			}
			continue
		}
		// Loop
		for idx, id := range compound.Entitys {
			fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx), getOptional(v13s, idx), getOptional(v14s, idx), getOptional(v15s, idx), getOptional(v16s, idx), getOptional(v17s, idx), getOptional(v18s, idx))
			if *options.Stop {
				return
			}
		}
	}
}

func (q *Q19[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19]) Each(fn func(ID, *T1, *T2, *T3, *T4, *T5, *T6, *T7, *T8, *T9, *T10, *T11, *T12, *T13, *T14, *T15, *T16, *T17, *T18, *T19), queryOptions ...Q19Option) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q19Option
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
LOOP:
	for id, compound := range q.storage.Compounds {
		var v1s []T1
		var v2s []T2
		var v3s []T3
		var v4s []T4
		var v5s []T5
		var v6s []T6
		var v7s []T7
		var v8s []T8
		var v9s []T9
		var v10s []T10
		var v11s []T11
		var v12s []T12
		var v13s []T13
		var v14s []T14
		var v15s []T15
		var v16s []T16
		var v17s []T17
		var v18s []T18
		var v19s []T19

		for _, component := range compound.Components {
			if options.Hash != nil && component.ID == options.Hash.ID && component.Hash != options.Hash.Hash {
				continue LOOP
			}
			if component.ID == q.Components[0] {
				v1s = component.Data.(*slice[T1]).Data
				continue
			}
			if component.ID == q.Components[1] {
				v2s = component.Data.(*slice[T2]).Data
				continue
			}
			if component.ID == q.Components[2] {
				v3s = component.Data.(*slice[T3]).Data
				continue
			}
			if component.ID == q.Components[3] {
				v4s = component.Data.(*slice[T4]).Data
				continue
			}
			if component.ID == q.Components[4] {
				v5s = component.Data.(*slice[T5]).Data
				continue
			}
			if component.ID == q.Components[5] {
				v6s = component.Data.(*slice[T6]).Data
				continue
			}
			if component.ID == q.Components[6] {
				v7s = component.Data.(*slice[T7]).Data
				continue
			}
			if component.ID == q.Components[7] {
				v8s = component.Data.(*slice[T8]).Data
				continue
			}
			if component.ID == q.Components[8] {
				v9s = component.Data.(*slice[T9]).Data
				continue
			}
			if component.ID == q.Components[9] {
				v10s = component.Data.(*slice[T10]).Data
				continue
			}
			if component.ID == q.Components[10] {
				v11s = component.Data.(*slice[T11]).Data
				continue
			}
			if component.ID == q.Components[11] {
				v12s = component.Data.(*slice[T12]).Data
				continue
			}
			if component.ID == q.Components[12] {
				v13s = component.Data.(*slice[T13]).Data
				continue
			}
			if component.ID == q.Components[13] {
				v14s = component.Data.(*slice[T14]).Data
				continue
			}
			if component.ID == q.Components[14] {
				v15s = component.Data.(*slice[T15]).Data
				continue
			}
			if component.ID == q.Components[15] {
				v16s = component.Data.(*slice[T16]).Data
				continue
			}
			if component.ID == q.Components[16] {
				v17s = component.Data.(*slice[T17]).Data
				continue
			}
			if component.ID == q.Components[17] {
				v18s = component.Data.(*slice[T18]).Data
				continue
			}
			if component.ID == q.Components[18] {
				v19s = component.Data.(*slice[T19]).Data
				continue
			}

		}
		if v1s == nil && !options.Optional[0] {
			continue
		}
		if v2s == nil && !options.Optional[1] {
			continue
		}
		if v3s == nil && !options.Optional[2] {
			continue
		}
		if v4s == nil && !options.Optional[3] {
			continue
		}
		if v5s == nil && !options.Optional[4] {
			continue
		}
		if v6s == nil && !options.Optional[5] {
			continue
		}
		if v7s == nil && !options.Optional[6] {
			continue
		}
		if v8s == nil && !options.Optional[7] {
			continue
		}
		if v9s == nil && !options.Optional[8] {
			continue
		}
		if v10s == nil && !options.Optional[9] {
			continue
		}
		if v11s == nil && !options.Optional[10] {
			continue
		}
		if v12s == nil && !options.Optional[11] {
			continue
		}
		if v13s == nil && !options.Optional[12] {
			continue
		}
		if v14s == nil && !options.Optional[13] {
			continue
		}
		if v15s == nil && !options.Optional[14] {
			continue
		}
		if v16s == nil && !options.Optional[15] {
			continue
		}
		if v17s == nil && !options.Optional[16] {
			continue
		}
		if v18s == nil && !options.Optional[17] {
			continue
		}
		if v19s == nil && !options.Optional[18] {
			continue
		}

		if compound.EntitysRemoved != nil {
			total := len(compound.EntitysRemoved)
			if total == len(compound.Entitys) {
				q.storage.Compounds = sliceRemove(q.storage.Compounds, id)
				continue
			}
			skipID, skipCount := compound.EntitysRemoved[0], 0
			if !compound.cleanupTime.Swap(true) {
				idxRemove := make([]int, total)
				for idx, id := range compound.Entitys {
					if id == skipID {
						idxRemove[skipCount] = idx
						skipCount++
						if skipCount < total {
							skipID = compound.EntitysRemoved[skipCount]
						}
						continue
					}
					fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx), getOptional(v13s, idx), getOptional(v14s, idx), getOptional(v15s, idx), getOptional(v16s, idx), getOptional(v17s, idx), getOptional(v18s, idx), getOptional(v19s, idx))
					if *options.Stop {
						return
					}
				}
				// Remove multiple indexes needs to be done in reverse so we don't mess up the indexes
				for i := len(idxRemove) - 1; i >= 0; i-- {
					idx := idxRemove[i]
					compound.Entitys = sliceRemove(compound.Entitys, idx)
					for _, component := range compound.Components {
						component.Data.remove(idx)
					}
				}
				compound.EntitysRemoved = nil
				compound.cleanupTime.Store(false)
				continue
			}
			for idx, id := range compound.Entitys {
				if id == skipID {
					skipCount++
					if skipCount < total {
						skipID = compound.EntitysRemoved[skipCount]
					}
					continue
				}
				fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx), getOptional(v13s, idx), getOptional(v14s, idx), getOptional(v15s, idx), getOptional(v16s, idx), getOptional(v17s, idx), getOptional(v18s, idx), getOptional(v19s, idx))
				if *options.Stop {
					return
				}
			}
			continue
		}
		// Loop
		for idx, id := range compound.Entitys {
			fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx), getOptional(v13s, idx), getOptional(v14s, idx), getOptional(v15s, idx), getOptional(v16s, idx), getOptional(v17s, idx), getOptional(v18s, idx), getOptional(v19s, idx))
			if *options.Stop {
				return
			}
		}
	}
}

func (q *Q20[ID, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20]) Each(fn func(ID, *T1, *T2, *T3, *T4, *T5, *T6, *T7, *T8, *T9, *T10, *T11, *T12, *T13, *T14, *T15, *T16, *T17, *T18, *T19, *T20), queryOptions ...Q20Option) {
	// Skip if there is an error
	if q.Errors != nil {
		return
	}
	var options Q20Option
	if len(queryOptions) == 1 {
		options = queryOptions[0]
	}
	if options.Stop == nil {
		options.Stop = new(bool)
	}
	// Filter and run compounds
LOOP:
	for id, compound := range q.storage.Compounds {
		var v1s []T1
		var v2s []T2
		var v3s []T3
		var v4s []T4
		var v5s []T5
		var v6s []T6
		var v7s []T7
		var v8s []T8
		var v9s []T9
		var v10s []T10
		var v11s []T11
		var v12s []T12
		var v13s []T13
		var v14s []T14
		var v15s []T15
		var v16s []T16
		var v17s []T17
		var v18s []T18
		var v19s []T19
		var v20s []T20

		for _, component := range compound.Components {
			if options.Hash != nil && component.ID == options.Hash.ID && component.Hash != options.Hash.Hash {
				continue LOOP
			}
			if component.ID == q.Components[0] {
				v1s = component.Data.(*slice[T1]).Data
				continue
			}
			if component.ID == q.Components[1] {
				v2s = component.Data.(*slice[T2]).Data
				continue
			}
			if component.ID == q.Components[2] {
				v3s = component.Data.(*slice[T3]).Data
				continue
			}
			if component.ID == q.Components[3] {
				v4s = component.Data.(*slice[T4]).Data
				continue
			}
			if component.ID == q.Components[4] {
				v5s = component.Data.(*slice[T5]).Data
				continue
			}
			if component.ID == q.Components[5] {
				v6s = component.Data.(*slice[T6]).Data
				continue
			}
			if component.ID == q.Components[6] {
				v7s = component.Data.(*slice[T7]).Data
				continue
			}
			if component.ID == q.Components[7] {
				v8s = component.Data.(*slice[T8]).Data
				continue
			}
			if component.ID == q.Components[8] {
				v9s = component.Data.(*slice[T9]).Data
				continue
			}
			if component.ID == q.Components[9] {
				v10s = component.Data.(*slice[T10]).Data
				continue
			}
			if component.ID == q.Components[10] {
				v11s = component.Data.(*slice[T11]).Data
				continue
			}
			if component.ID == q.Components[11] {
				v12s = component.Data.(*slice[T12]).Data
				continue
			}
			if component.ID == q.Components[12] {
				v13s = component.Data.(*slice[T13]).Data
				continue
			}
			if component.ID == q.Components[13] {
				v14s = component.Data.(*slice[T14]).Data
				continue
			}
			if component.ID == q.Components[14] {
				v15s = component.Data.(*slice[T15]).Data
				continue
			}
			if component.ID == q.Components[15] {
				v16s = component.Data.(*slice[T16]).Data
				continue
			}
			if component.ID == q.Components[16] {
				v17s = component.Data.(*slice[T17]).Data
				continue
			}
			if component.ID == q.Components[17] {
				v18s = component.Data.(*slice[T18]).Data
				continue
			}
			if component.ID == q.Components[18] {
				v19s = component.Data.(*slice[T19]).Data
				continue
			}
			if component.ID == q.Components[19] {
				v20s = component.Data.(*slice[T20]).Data
				continue
			}

		}
		if v1s == nil && !options.Optional[0] {
			continue
		}
		if v2s == nil && !options.Optional[1] {
			continue
		}
		if v3s == nil && !options.Optional[2] {
			continue
		}
		if v4s == nil && !options.Optional[3] {
			continue
		}
		if v5s == nil && !options.Optional[4] {
			continue
		}
		if v6s == nil && !options.Optional[5] {
			continue
		}
		if v7s == nil && !options.Optional[6] {
			continue
		}
		if v8s == nil && !options.Optional[7] {
			continue
		}
		if v9s == nil && !options.Optional[8] {
			continue
		}
		if v10s == nil && !options.Optional[9] {
			continue
		}
		if v11s == nil && !options.Optional[10] {
			continue
		}
		if v12s == nil && !options.Optional[11] {
			continue
		}
		if v13s == nil && !options.Optional[12] {
			continue
		}
		if v14s == nil && !options.Optional[13] {
			continue
		}
		if v15s == nil && !options.Optional[14] {
			continue
		}
		if v16s == nil && !options.Optional[15] {
			continue
		}
		if v17s == nil && !options.Optional[16] {
			continue
		}
		if v18s == nil && !options.Optional[17] {
			continue
		}
		if v19s == nil && !options.Optional[18] {
			continue
		}
		if v20s == nil && !options.Optional[19] {
			continue
		}

		if compound.EntitysRemoved != nil {
			total := len(compound.EntitysRemoved)
			if total == len(compound.Entitys) {
				q.storage.Compounds = sliceRemove(q.storage.Compounds, id)
				continue
			}
			skipID, skipCount := compound.EntitysRemoved[0], 0
			if !compound.cleanupTime.Swap(true) {
				idxRemove := make([]int, total)
				for idx, id := range compound.Entitys {
					if id == skipID {
						idxRemove[skipCount] = idx
						skipCount++
						if skipCount < total {
							skipID = compound.EntitysRemoved[skipCount]
						}
						continue
					}
					fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx), getOptional(v13s, idx), getOptional(v14s, idx), getOptional(v15s, idx), getOptional(v16s, idx), getOptional(v17s, idx), getOptional(v18s, idx), getOptional(v19s, idx), getOptional(v20s, idx))
					if *options.Stop {
						return
					}
				}
				// Remove multiple indexes needs to be done in reverse so we don't mess up the indexes
				for i := len(idxRemove) - 1; i >= 0; i-- {
					idx := idxRemove[i]
					compound.Entitys = sliceRemove(compound.Entitys, idx)
					for _, component := range compound.Components {
						component.Data.remove(idx)
					}
				}
				compound.EntitysRemoved = nil
				compound.cleanupTime.Store(false)
				continue
			}
			for idx, id := range compound.Entitys {
				if id == skipID {
					skipCount++
					if skipCount < total {
						skipID = compound.EntitysRemoved[skipCount]
					}
					continue
				}
				fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx), getOptional(v13s, idx), getOptional(v14s, idx), getOptional(v15s, idx), getOptional(v16s, idx), getOptional(v17s, idx), getOptional(v18s, idx), getOptional(v19s, idx), getOptional(v20s, idx))
				if *options.Stop {
					return
				}
			}
			continue
		}
		// Loop
		for idx, id := range compound.Entitys {
			fn(id, getOptional(v1s, idx), getOptional(v2s, idx), getOptional(v3s, idx), getOptional(v4s, idx), getOptional(v5s, idx), getOptional(v6s, idx), getOptional(v7s, idx), getOptional(v8s, idx), getOptional(v9s, idx), getOptional(v10s, idx), getOptional(v11s, idx), getOptional(v12s, idx), getOptional(v13s, idx), getOptional(v14s, idx), getOptional(v15s, idx), getOptional(v16s, idx), getOptional(v17s, idx), getOptional(v18s, idx), getOptional(v19s, idx), getOptional(v20s, idx))
			if *options.Stop {
				return
			}
		}
	}
}
